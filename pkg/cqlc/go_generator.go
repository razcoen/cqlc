package cqlc

import (
	"bytes"
	"fmt"
	"github.com/razcoen/cqlc/pkg/gocqlhelpers"
	"github.com/razcoen/cqlc/pkg/strfmt"
	"go/format"
	"io"
	"maps"
	"slices"
	"text/template"
)

type goGenerator struct {
	keyspaceGoTemplate *template.Template
	queriesGoTemplate  *template.Template
	clientTemplate     *template.Template
}

func newGoGenerator() (*goGenerator, error) {
	tpl, err := template.New("keyspace-go-template").Parse(keyspaceGoTemplate)
	if err != nil {
		return nil, fmt.Errorf("parse keyspace go template: %w", err)
	}
	tpl2, err := template.New("queries-go-template").Parse(queriesGoTemplate)
	if err != nil {
		return nil, fmt.Errorf("parse queries go template: %w", err)
	}
	tpl3, err := template.New("client-template").Parse(clientTemplate)
	if err != nil {
		return nil, fmt.Errorf("parse client go template: %w", err)
	}
	return &goGenerator{keyspaceGoTemplate: tpl, queriesGoTemplate: tpl2, clientTemplate: tpl3}, nil
}

type generateKeyspaceStructsRequest struct {
	keyspace    *Keyspace
	packageName string
	out         io.Writer
}

var (
	// TODO: Create a header that is always appended
	keyspaceGoTemplate = `// Code generated by cqlc. DO NOT EDIT.

package {{.PackageName}}

{{- if gt (len .Imports) 0}}
import (
{{- end}}
{{- range .Imports}}
  "{{.}}"
{{- end}}
{{- if gt (len .Imports) 0}}
)
{{- end}}
{{range .Structs}}
// Table: {{.TableName}}
type {{.Name}} struct {
  {{- range .Fields }}
  {{ .Name }} {{ .GoType }}
  {{- end }}
}
{{end -}}
`

	clientTemplate = `// Code generated by cqlc. DO NOT EDIT.

package {{.PackageName}}

import (
	"github.com/gocql/gocql"
  "github.com/razcoen/cqlc/pkg/cqlc"
)

type Client struct {
	Session *gocql.Session
  Logger cqlc.Logger
}

func NewClient(session *gocql.Session, logger cqlc.Logger) *Client {
	return &Client{Session: session, Logger: logger}
}
`
	execQueryGoTemplate = `

`
	queriesGoTemplate = `// Code generated by cqlc. DO NOT EDIT.

package {{.PackageName}}

{{- if gt (len .Imports) 0}}
import (
{{- end}}
{{- range .Imports}}
  "{{.}}"
{{- end}}
{{- if gt (len .Imports) 0}}
)
{{- end}}

{{range .Queries}}
type {{.FuncName}}Params struct {
{{- range .Params}}
{{.Name}} {{.GoType}}
{{- end}}
}

type {{.FuncName}}Result struct {
{{- range .Selects}}
{{.Name}} {{.GoType}}
{{- end}}
}

func (c *Client) {{.FuncName}}(params {{.FuncName}}Params) ([]*{{.FuncName}}Result, error) {
}
{{end -}}
`
)

type queriesGoTemplateValue struct {
	PackageName string
	Imports     []string
	Queries     []struct {
		FuncName string
		Params   []fieldTemplateValue
		Selects  []fieldTemplateValue
	}
}

type fieldTemplateValue struct {
	Name   string
	GoType string
}

type keyspaceGoTemplateValue struct {
	PackageName string
	Imports     []string
	Structs     []struct {
		TableName string
		Name      string
		Fields    []fieldTemplateValue
	}
}

type generateKeyspaceStructsResponse struct {
	structByTableName map[string]*strct
}

func (gg *goGenerator) generateKeyspaceStructs(req *generateKeyspaceStructsRequest) (*generateKeyspaceStructsResponse, error) {
	v := keyspaceGoTemplateValue{
		PackageName: req.packageName,
		Structs: []struct {
			TableName string
			Name      string
			Fields    []fieldTemplateValue
		}{},
	}
	imports := make(map[string]bool)
	structByTableName := make(map[string]*strct, len(req.keyspace.Tables))
	for _, t := range req.keyspace.Tables {
		structName := strfmt.ToSingularPascalCase(t.Name)
		st := struct {
			TableName string
			Name      string
			Fields    []fieldTemplateValue
		}{
			TableName: t.Name,
			Name:      structName,
		}
		fieldByColumnName := make(map[string]*field)
		for _, c := range t.Columns {
			name := strfmt.ToSingularPascalCase(c.Name)
			goType, err := gocqlhelpers.ParseGoType(c.DataType)
			if err != nil {
				// TODO
				continue
			}
			if goType.ImportPath != "" {
				imports[goType.ImportPath] = true
			}
			st.Fields = append(st.Fields, fieldTemplateValue{Name: name, GoType: goType.Name})
			fieldByColumnName[c.Name] = &field{name: name, goType: goType}
		}
		v.Structs = append(v.Structs, st)
		structByTableName[t.Name] = &strct{
			name:              st.Name,
			fieldByColumnName: fieldByColumnName,
		}
	}
	v.Imports = slices.Collect(maps.Keys(imports))
	buf := &bytes.Buffer{}
	if err := gg.keyspaceGoTemplate.Execute(buf, v); err != nil {
		return nil, fmt.Errorf("execute keyspace template: %w", err)
	}
	out, err := format.Source(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("format out: %w", err)
	}
	if _, err := req.out.Write(out); err != nil {
		return nil, fmt.Errorf("write out: %w", err)
	}
	return &generateKeyspaceStructsResponse{structByTableName: structByTableName}, nil
}

type field struct {
	name   string
	goType *gocqlhelpers.GoType
}

type strct struct {
	name              string
	fieldByColumnName map[string]*field
}

type generateQueriesRequest struct {
	queries           []*Query
	structByTableName map[string]*strct
	packageName       string
	out               io.Writer
}

// TODO: Support keyspaces
func (gg *goGenerator) generateQueries(req *generateQueriesRequest) error {
	v := queriesGoTemplateValue{
		PackageName: req.packageName,
	}
	imports := make(map[string]bool)
	for _, q := range req.queries {
		params := make([]fieldTemplateValue, 0, len(q.Params))
		selects := make([]fieldTemplateValue, 0, len(q.Selects))
		strct := req.structByTableName[q.Table]
		for _, p := range q.Params {
			field := strct.fieldByColumnName[p]
			if field.goType.ImportPath != "" {
				imports[field.goType.ImportPath] = true
			}
			params = append(params, fieldTemplateValue{Name: field.name, GoType: field.goType.Name})
		}
		// TODO: Return the struct instead of copying the fields
		if len(q.Selects) == 1 && q.Selects[0] == "*" {
			for _, f := range strct.fieldByColumnName {
				if f.goType.ImportPath != "" {
					imports[f.goType.ImportPath] = true
				}
				selects = append(selects, fieldTemplateValue{Name: f.name, GoType: f.goType.Name})
			}
		} else {
			for _, s := range q.Selects {
				f := strct.fieldByColumnName[s]
				if f.goType.ImportPath != "" {
					imports[f.goType.ImportPath] = true
				}
				selects = append(selects, fieldTemplateValue{Name: f.name, GoType: f.goType.Name})
			}
		}
		v.Queries = append(v.Queries, struct {
			FuncName string
			Params   []fieldTemplateValue
			Selects  []fieldTemplateValue
		}{FuncName: q.FuncName, Params: params, Selects: selects})
	}
	v.Imports = slices.Collect(maps.Keys(imports))
	buf := &bytes.Buffer{}
	if err := gg.queriesGoTemplate.Execute(buf, v); err != nil {
		return fmt.Errorf("execute queries template: %w", err)
	}
	out, err := format.Source(buf.Bytes())
	if err != nil {
		return fmt.Errorf("format out: %w", err)
	}
	if _, err := req.out.Write(out); err != nil {
		return fmt.Errorf("write out: %w", err)
	}
	return nil
}

type generateClientRequest struct {
	packageName string
	out         io.Writer
}

type clientTemplateValue struct {
	PackageName string
}

func (gg *goGenerator) generateClient(req *generateClientRequest) error {
	buf := &bytes.Buffer{}
	if err := gg.clientTemplate.Execute(buf, &clientTemplateValue{PackageName: req.packageName}); err != nil {
		return fmt.Errorf("execute queries template: %w", err)
	}
	out, err := format.Source(buf.Bytes())
	if err != nil {
		return fmt.Errorf("format out: %w", err)
	}
	if _, err := req.out.Write(out); err != nil {
		return fmt.Errorf("write out: %w", err)
	}
	return nil
}

package golang

import (
	"path/filepath"
	"strings"

	"github.com/razcoen/cqlc/pkg/cqlc/codegen/sdk"
	"github.com/razcoen/cqlc/pkg/log"
)

func createHeader(ctx *sdk.Context, options *Options, logger log.Logger) string {
	var header strings.Builder
	_, _ = header.WriteString("// Code generated by cqlc. DO NOT EDIT.\n")
	if ctx == nil || ctx.Metadata == nil {
		return header.String()
	}
	if options == nil {
		options = &Options{}
	}
	type field struct {
		key   string
		value string
	}
	var (
		configPath  string
		schemaPath  string
		queriesPath string
	)
	if len(ctx.Metadata.ConfigPath) > 0 {
		var err error
		configPath, err = filepath.Rel(options.Out, ctx.Metadata.ConfigPath)
		if err != nil {
			// TODO: Warn that the relative path failed to be resolved
			configPath = ctx.Metadata.ConfigPath
		}
	}
	if len(ctx.Metadata.SchemaPath) > 0 {
		var err error
		schemaPath, err = filepath.Rel(options.Out, ctx.Metadata.SchemaPath)
		if err != nil {
			// TODO: Warn that the relative path failed to be resolved
			schemaPath = ctx.Metadata.SchemaPath
		}
	}
	if len(ctx.Metadata.QueriesPath) > 0 {
		var err error
		queriesPath, err = filepath.Rel(options.Out, ctx.Metadata.QueriesPath)
		if err != nil {
			// TODO: Warn that the relative path failed to be resolved
			queriesPath = ctx.Metadata.QueriesPath
		}
	}
	fields := []field{
		{key: "cqlc version", value: ctx.Metadata.Version},
		{key: "config", value: configPath},
		{key: "schema", value: schemaPath},
		{key: "queries", value: queriesPath},
	}
	for _, f := range fields {
		if len(f.value) > 0 {
			header.WriteString("// ")
			header.WriteString(f.key)
			header.WriteString(": ")
			header.WriteString(f.value)
			header.WriteString("\n")
		}
	}
	return header.String()
}

// Code generated from CQLParser.g4 by ANTLR 4.13.2. DO NOT EDIT.

package antlrcql // CQLParser
import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type CQLParser struct {
	*antlr.BaseParser
}

var CQLParserParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func cqlparserParserInit() {
	staticData := &CQLParserParserStaticData
	staticData.LiteralNames = []string{
		"", "'('", "')'", "'{'", "'}'", "'['", "']'", "','", "';'", "':'", "'.'",
		"'*'", "'/'", "'%'", "'+'", "'--'", "'-'", "'\"'", "'''", "'='", "'<'",
		"'>'", "'<='", "'>='", "'ADD'", "'AGGREGATE'", "'ALL'", "'ALLOW'", "'ALTER'",
		"'AND'", "'ANY'", "'APPLY'", "'AS'", "'ASC'", "'AUTHORIZE'", "'BATCH'",
		"'BEGIN'", "'BY'", "'CALLED'", "'CLUSTERING'", "'COLUMNFAMILY'", "'COMPACT'",
		"'CONSISTENCY'", "'CONTAINS'", "'CREATE'", "'CUSTOM'", "'DELETE'", "'DESC'",
		"'DESCRIBE'", "'DISTINCT'", "'DROP'", "'DURABLE_WRITES'", "'EACH_QUORUM'",
		"'ENTRIES'", "'EXECUTE'", "'EXISTS'", "'FALSE'", "'FILTERING'", "'FINALFUNC'",
		"'FROM'", "'FULL'", "'FUNCTION'", "'FUNCTIONS'", "'GRANT'", "'IF'",
		"'IN'", "'INDEX'", "'INFINITY'", "'INITCOND'", "'INPUT'", "'INSERT'",
		"'INTO'", "'IS'", "'JSON'", "'KEY'", "'KEYS'", "'KEYSPACE'", "'KEYSPACES'",
		"'LANGUAGE'", "'LEVEL'", "'LIMIT'", "'LOCAL_ONE'", "'LOCAL_QUORUM'",
		"'LOGGED'", "'LOGIN'", "'MATERIALIZED'", "'MODIFY'", "'NAN'", "'NORECURSIVE'",
		"'NOSUPERUSER'", "'NOT'", "'NULL'", "'OF'", "'ON'", "'ONE'", "'OPTIONS'",
		"'OR'", "'ORDER'", "'PARTITION'", "'PASSWORD'", "'PER'", "'PERMISSION'",
		"'PERMISSIONS'", "'PRIMARY'", "'QUORUM'", "'RENAME'", "'REPLACE'", "'REPLICATION'",
		"'RETURNS'", "'REVOKE'", "'ROLE'", "'ROLES'", "'SCHEMA'", "'SELECT'",
		"'SET'", "'SFUNC'", "'STATIC'", "'STORAGE'", "'STYPE'", "'SUPERUSER'",
		"'TABLE'", "'THREE'", "'TIMESTAMP'", "'TO'", "'TOKEN'", "'TRIGGER'",
		"'TRUE'", "'TRUNCATE'", "'TTL'", "'TWO'", "'TYPE'", "'UNLOGGED'", "'UPDATE'",
		"'USE'", "'USER'", "'USING'", "'UUID'", "'VALUES'", "'VIEW'", "'WHERE'",
		"'WITH'", "'WRITETIME'", "'ASCII'", "'BIGINT'", "'BLOB'", "'BOOLEAN'",
		"'COUNTER'", "'DATE'", "'DECIMAL'", "'DOUBLE'", "'FLOAT'", "'FROZEN'",
		"'INET'", "'INT'", "'LIST'", "'MAP'", "'SMALLINT'", "'TEXT'", "'TIMEUUID'",
		"'TIME'", "'TINYINT'", "'TUPLE'", "'VARCHAR'", "'VARINT'",
	}
	staticData.SymbolicNames = []string{
		"", "LR_BRACKET", "RR_BRACKET", "LC_BRACKET", "RC_BRACKET", "LS_BRACKET",
		"RS_BRACKET", "COMMA", "SEMI", "COLON", "DOT", "STAR", "DIVIDE", "MODULE",
		"PLUS", "MINUSMINUS", "MINUS", "DQUOTE", "SQUOTE", "OPERATOR_EQ", "OPERATOR_LT",
		"OPERATOR_GT", "OPERATOR_LTE", "OPERATOR_GTE", "K_ADD", "K_AGGREGATE",
		"K_ALL", "K_ALLOW", "K_ALTER", "K_AND", "K_ANY", "K_APPLY", "K_AS",
		"K_ASC", "K_AUTHORIZE", "K_BATCH", "K_BEGIN", "K_BY", "K_CALLED", "K_CLUSTERING",
		"K_COLUMNFAMILY", "K_COMPACT", "K_CONSISTENCY", "K_CONTAINS", "K_CREATE",
		"K_CUSTOM", "K_DELETE", "K_DESC", "K_DESCRIBE", "K_DISTINCT", "K_DROP",
		"K_DURABLE_WRITES", "K_EACH_QUORUM", "K_ENTRIES", "K_EXECUTE", "K_EXISTS",
		"K_FALSE", "K_FILTERING", "K_FINALFUNC", "K_FROM", "K_FULL", "K_FUNCTION",
		"K_FUNCTIONS", "K_GRANT", "K_IF", "K_IN", "K_INDEX", "K_INFINITY", "K_INITCOND",
		"K_INPUT", "K_INSERT", "K_INTO", "K_IS", "K_JSON", "K_KEY", "K_KEYS",
		"K_KEYSPACE", "K_KEYSPACES", "K_LANGUAGE", "K_LEVEL", "K_LIMIT", "K_LOCAL_ONE",
		"K_LOCAL_QUORUM", "K_LOGGED", "K_LOGIN", "K_MATERIALIZED", "K_MODIFY",
		"K_NAN", "K_NORECURSIVE", "K_NOSUPERUSER", "K_NOT", "K_NULL", "K_OF",
		"K_ON", "K_ONE", "K_OPTIONS", "K_OR", "K_ORDER", "K_PARTITION", "K_PASSWORD",
		"K_PER", "K_PERMISSION", "K_PERMISSIONS", "K_PRIMARY", "K_QUORUM", "K_RENAME",
		"K_REPLACE", "K_REPLICATION", "K_RETURNS", "K_REVOKE", "K_ROLE", "K_ROLES",
		"K_SCHEMA", "K_SELECT", "K_SET", "K_SFUNC", "K_STATIC", "K_STORAGE",
		"K_STYPE", "K_SUPERUSER", "K_TABLE", "K_THREE", "K_TIMESTAMP", "K_TO",
		"K_TOKEN", "K_TRIGGER", "K_TRUE", "K_TRUNCATE", "K_TTL", "K_TWO", "K_TYPE",
		"K_UNLOGGED", "K_UPDATE", "K_USE", "K_USER", "K_USING", "K_UUID", "K_VALUES",
		"K_VIEW", "K_WHERE", "K_WITH", "K_WRITETIME", "K_ASCII", "K_BIGINT",
		"K_BLOB", "K_BOOLEAN", "K_COUNTER", "K_DATE", "K_DECIMAL", "K_DOUBLE",
		"K_FLOAT", "K_FROZEN", "K_INET", "K_INT", "K_LIST", "K_MAP", "K_SMALLINT",
		"K_TEXT", "K_TIMEUUID", "K_TIME", "K_TINYINT", "K_TUPLE", "K_VARCHAR",
		"K_VARINT", "CODE_BLOCK", "STRING_LITERAL", "DECIMAL_LITERAL", "FLOAT_LITERAL",
		"HEXADECIMAL_LITERAL", "REAL_LITERAL", "OBJECT_NAME", "UUID", "SPACE",
		"SPEC_MYSQL_COMMENT", "COMMENT_INPUT", "LINE_COMMENT",
	}
	staticData.RuleNames = []string{
		"root", "cqls", "statementSeparator", "empty_", "cql", "revoke", "listRoles",
		"listPermissions", "grant", "priviledge", "resource", "createUser",
		"createRole", "createType", "typeMemberColumnList", "createTrigger",
		"createMaterializedView", "materializedViewWhere", "columnNotNullList",
		"columnNotNull", "materializedViewOptions", "createKeyspace", "createFunction",
		"codeBlock", "paramList", "returnMode", "createAggregate", "initCondDefinition",
		"initCondHash", "initCondHashItem", "initCondListNested", "initCondList",
		"orReplace", "alterUser", "userPassword", "userSuperUser", "alterType",
		"alterTypeOperation", "alterTypeRename", "alterTypeRenameList", "alterTypeRenameItem",
		"alterTypeAdd", "alterTypeAlterType", "alterTable", "alterTableOperation",
		"alterTableWith", "alterTableRename", "alterTableDropCompactStorage",
		"alterTableDropColumns", "alterTableDropColumnList", "alterTableAdd",
		"alterTableColumnDefinition", "alterRole", "roleWith", "roleWithOptions",
		"alterMaterializedView", "dropUser", "dropType", "dropMaterializedView",
		"dropAggregate", "dropFunction", "dropTrigger", "dropRole", "dropTable",
		"dropKeyspace", "dropIndex", "createTable", "withElement", "tableOptions",
		"clusteringOrder", "tableOptionItem", "tableOptionName", "tableOptionValue",
		"optionHash", "optionHashItem", "optionHashKey", "optionHashValue",
		"columnDefinitionList", "columnDefinition", "primaryKeyColumn", "primaryKeyElement",
		"primaryKeyDefinition", "singlePrimaryKey", "compoundKey", "compositeKey",
		"partitionKeyList", "clusteringKeyList", "partitionKey", "clusteringKey",
		"applyBatch", "beginBatch", "batchType", "alterKeyspace", "replicationList",
		"replicationListItem", "durableWrites", "use_", "truncate", "createIndex",
		"indexName", "indexColumnSpec", "indexKeysSpec", "indexEntriesSSpec",
		"indexFullSpec", "delete_", "deleteColumnList", "deleteColumnItem",
		"update", "ifSpec", "ifConditionList", "ifCondition", "assignments",
		"assignmentElement", "assignmentSet", "assignmentMap", "assignmentList",
		"assignmentTuple", "insert", "usingTtlTimestamp", "timestamp", "ttl",
		"usingTimestampSpec", "ifNotExist", "ifExist", "insertValuesSpec", "insertColumnSpec",
		"columnList", "expressionList", "expression", "select_", "allowFilteringSpec",
		"limitSpec", "fromSpec", "fromSpecElement", "orderSpec", "orderSpecElement",
		"whereSpec", "distinctSpec", "selectElements", "selectElement", "relationElements",
		"relationElement", "relalationContains", "relalationContainsKey", "functionCall",
		"functionArgs", "constant", "decimalLiteral", "floatLiteral", "stringLiteral",
		"booleanLiteral", "hexadecimalLiteral", "keyspace", "table", "column",
		"dataType", "dataTypeName", "dataTypeDefinition", "orderDirection",
		"role", "trigger", "triggerClass", "materializedView", "type_", "aggregate",
		"function_", "language", "user", "password", "hashKey", "param", "paramName",
		"kwAdd", "kwAggregate", "kwAll", "kwAllPermissions", "kwAllow", "kwAlter",
		"kwAnd", "kwApply", "kwAs", "kwAsc", "kwAuthorize", "kwBatch", "kwBegin",
		"kwBy", "kwCalled", "kwClustering", "kwCompact", "kwContains", "kwCreate",
		"kwDelete", "kwDesc", "kwDescibe", "kwDistinct", "kwDrop", "kwDurableWrites",
		"kwEntries", "kwExecute", "kwExists", "kwFiltering", "kwFinalfunc",
		"kwFrom", "kwFull", "kwFunction", "kwFunctions", "kwGrant", "kwIf",
		"kwIn", "kwIndex", "kwInitcond", "kwInput", "kwInsert", "kwInto", "kwIs",
		"kwJson", "kwKey", "kwKeys", "kwKeyspace", "kwKeyspaces", "kwLanguage",
		"kwLimit", "kwList", "kwLogged", "kwLogin", "kwMaterialized", "kwModify",
		"kwNosuperuser", "kwNorecursive", "kwNot", "kwNull", "kwOf", "kwOn",
		"kwOptions", "kwOr", "kwOrder", "kwPassword", "kwPrimary", "kwRename",
		"kwReplace", "kwReplication", "kwReturns", "kwRole", "kwRoles", "kwSelect",
		"kwSet", "kwSfunc", "kwStorage", "kwStype", "kwSuperuser", "kwTable",
		"kwTimestamp", "kwTo", "kwTrigger", "kwTruncate", "kwTtl", "kwType",
		"kwUnlogged", "kwUpdate", "kwUse", "kwUser", "kwUsing", "kwValues",
		"kwView", "kwWhere", "kwWith", "kwRevoke", "syntaxBracketLr", "syntaxBracketRr",
		"syntaxBracketLc", "syntaxBracketRc", "syntaxBracketLa", "syntaxBracketRa",
		"syntaxBracketLs", "syntaxBracketRs", "syntaxComma", "syntaxColon",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 175, 2321, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
		78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83,
		2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2,
		89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94,
		7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7,
		99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2,
		104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7,
		108, 2, 109, 7, 109, 2, 110, 7, 110, 2, 111, 7, 111, 2, 112, 7, 112, 2,
		113, 7, 113, 2, 114, 7, 114, 2, 115, 7, 115, 2, 116, 7, 116, 2, 117, 7,
		117, 2, 118, 7, 118, 2, 119, 7, 119, 2, 120, 7, 120, 2, 121, 7, 121, 2,
		122, 7, 122, 2, 123, 7, 123, 2, 124, 7, 124, 2, 125, 7, 125, 2, 126, 7,
		126, 2, 127, 7, 127, 2, 128, 7, 128, 2, 129, 7, 129, 2, 130, 7, 130, 2,
		131, 7, 131, 2, 132, 7, 132, 2, 133, 7, 133, 2, 134, 7, 134, 2, 135, 7,
		135, 2, 136, 7, 136, 2, 137, 7, 137, 2, 138, 7, 138, 2, 139, 7, 139, 2,
		140, 7, 140, 2, 141, 7, 141, 2, 142, 7, 142, 2, 143, 7, 143, 2, 144, 7,
		144, 2, 145, 7, 145, 2, 146, 7, 146, 2, 147, 7, 147, 2, 148, 7, 148, 2,
		149, 7, 149, 2, 150, 7, 150, 2, 151, 7, 151, 2, 152, 7, 152, 2, 153, 7,
		153, 2, 154, 7, 154, 2, 155, 7, 155, 2, 156, 7, 156, 2, 157, 7, 157, 2,
		158, 7, 158, 2, 159, 7, 159, 2, 160, 7, 160, 2, 161, 7, 161, 2, 162, 7,
		162, 2, 163, 7, 163, 2, 164, 7, 164, 2, 165, 7, 165, 2, 166, 7, 166, 2,
		167, 7, 167, 2, 168, 7, 168, 2, 169, 7, 169, 2, 170, 7, 170, 2, 171, 7,
		171, 2, 172, 7, 172, 2, 173, 7, 173, 2, 174, 7, 174, 2, 175, 7, 175, 2,
		176, 7, 176, 2, 177, 7, 177, 2, 178, 7, 178, 2, 179, 7, 179, 2, 180, 7,
		180, 2, 181, 7, 181, 2, 182, 7, 182, 2, 183, 7, 183, 2, 184, 7, 184, 2,
		185, 7, 185, 2, 186, 7, 186, 2, 187, 7, 187, 2, 188, 7, 188, 2, 189, 7,
		189, 2, 190, 7, 190, 2, 191, 7, 191, 2, 192, 7, 192, 2, 193, 7, 193, 2,
		194, 7, 194, 2, 195, 7, 195, 2, 196, 7, 196, 2, 197, 7, 197, 2, 198, 7,
		198, 2, 199, 7, 199, 2, 200, 7, 200, 2, 201, 7, 201, 2, 202, 7, 202, 2,
		203, 7, 203, 2, 204, 7, 204, 2, 205, 7, 205, 2, 206, 7, 206, 2, 207, 7,
		207, 2, 208, 7, 208, 2, 209, 7, 209, 2, 210, 7, 210, 2, 211, 7, 211, 2,
		212, 7, 212, 2, 213, 7, 213, 2, 214, 7, 214, 2, 215, 7, 215, 2, 216, 7,
		216, 2, 217, 7, 217, 2, 218, 7, 218, 2, 219, 7, 219, 2, 220, 7, 220, 2,
		221, 7, 221, 2, 222, 7, 222, 2, 223, 7, 223, 2, 224, 7, 224, 2, 225, 7,
		225, 2, 226, 7, 226, 2, 227, 7, 227, 2, 228, 7, 228, 2, 229, 7, 229, 2,
		230, 7, 230, 2, 231, 7, 231, 2, 232, 7, 232, 2, 233, 7, 233, 2, 234, 7,
		234, 2, 235, 7, 235, 2, 236, 7, 236, 2, 237, 7, 237, 2, 238, 7, 238, 2,
		239, 7, 239, 2, 240, 7, 240, 2, 241, 7, 241, 2, 242, 7, 242, 2, 243, 7,
		243, 2, 244, 7, 244, 2, 245, 7, 245, 2, 246, 7, 246, 2, 247, 7, 247, 2,
		248, 7, 248, 2, 249, 7, 249, 2, 250, 7, 250, 2, 251, 7, 251, 2, 252, 7,
		252, 2, 253, 7, 253, 2, 254, 7, 254, 2, 255, 7, 255, 2, 256, 7, 256, 2,
		257, 7, 257, 2, 258, 7, 258, 2, 259, 7, 259, 2, 260, 7, 260, 2, 261, 7,
		261, 2, 262, 7, 262, 2, 263, 7, 263, 2, 264, 7, 264, 2, 265, 7, 265, 2,
		266, 7, 266, 2, 267, 7, 267, 2, 268, 7, 268, 2, 269, 7, 269, 2, 270, 7,
		270, 2, 271, 7, 271, 2, 272, 7, 272, 2, 273, 7, 273, 2, 274, 7, 274, 2,
		275, 7, 275, 2, 276, 7, 276, 1, 0, 3, 0, 556, 8, 0, 1, 0, 3, 0, 559, 8,
		0, 1, 0, 1, 0, 1, 1, 1, 1, 3, 1, 565, 8, 1, 1, 1, 1, 1, 1, 1, 5, 1, 570,
		8, 1, 10, 1, 12, 1, 573, 9, 1, 1, 1, 1, 1, 3, 1, 577, 8, 1, 1, 1, 3, 1,
		580, 8, 1, 1, 1, 3, 1, 583, 8, 1, 1, 2, 1, 2, 1, 3, 1, 3, 1, 4, 1, 4, 1,
		4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1,
		4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1,
		4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 626,
		8, 4, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 6, 1, 6, 1, 6, 1, 6,
		1, 6, 3, 6, 640, 8, 6, 1, 6, 3, 6, 643, 8, 6, 1, 7, 1, 7, 1, 7, 1, 7, 1,
		7, 3, 7, 650, 8, 7, 1, 7, 1, 7, 1, 7, 3, 7, 655, 8, 7, 1, 8, 1, 8, 1, 8,
		1, 8, 1, 8, 1, 8, 1, 8, 1, 9, 1, 9, 3, 9, 666, 8, 9, 1, 9, 1, 9, 1, 9,
		1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 676, 8, 9, 1, 10, 1, 10, 1, 10, 1,
		10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 3, 10,
		691, 8, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1,
		10, 3, 10, 702, 8, 10, 1, 10, 1, 10, 1, 10, 3, 10, 707, 8, 10, 1, 10, 1,
		10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 3, 10, 716, 8, 10, 1, 11, 1, 11,
		1, 11, 3, 11, 721, 8, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 3,
		11, 729, 8, 11, 1, 12, 1, 12, 1, 12, 3, 12, 734, 8, 12, 1, 12, 1, 12, 3,
		12, 738, 8, 12, 1, 13, 1, 13, 1, 13, 3, 13, 743, 8, 13, 1, 13, 1, 13, 1,
		13, 3, 13, 748, 8, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 14, 1, 14,
		1, 14, 1, 14, 1, 14, 1, 14, 5, 14, 761, 8, 14, 10, 14, 12, 14, 764, 9,
		14, 1, 15, 1, 15, 1, 15, 3, 15, 769, 8, 15, 1, 15, 1, 15, 1, 15, 3, 15,
		774, 8, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 16, 1, 16, 1, 16, 1, 16, 3,
		16, 784, 8, 16, 1, 16, 1, 16, 1, 16, 3, 16, 789, 8, 16, 1, 16, 1, 16, 1,
		16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 3, 16, 799, 8, 16, 1, 16, 1, 16,
		1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 3, 16, 811, 8,
		16, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 3, 17, 818, 8, 17, 1, 18, 1, 18,
		1, 18, 1, 18, 5, 18, 824, 8, 18, 10, 18, 12, 18, 827, 9, 18, 1, 19, 1,
		19, 1, 19, 1, 19, 1, 19, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 3, 20,
		840, 8, 20, 1, 21, 1, 21, 1, 21, 3, 21, 845, 8, 21, 1, 21, 1, 21, 1, 21,
		1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 3, 21, 857, 8, 21, 1,
		22, 1, 22, 3, 22, 861, 8, 22, 1, 22, 1, 22, 3, 22, 865, 8, 22, 1, 22, 1,
		22, 1, 22, 3, 22, 870, 8, 22, 1, 22, 1, 22, 1, 22, 3, 22, 875, 8, 22, 1,
		22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 23, 1, 23,
		1, 24, 1, 24, 1, 24, 1, 24, 5, 24, 892, 8, 24, 10, 24, 12, 24, 895, 9,
		24, 1, 25, 1, 25, 1, 25, 1, 25, 3, 25, 901, 8, 25, 1, 25, 1, 25, 1, 25,
		1, 25, 1, 26, 1, 26, 3, 26, 909, 8, 26, 1, 26, 1, 26, 3, 26, 913, 8, 26,
		1, 26, 1, 26, 1, 26, 3, 26, 918, 8, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1,
		26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 27, 1, 27,
		1, 27, 1, 27, 3, 27, 937, 8, 27, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 5,
		28, 944, 8, 28, 10, 28, 12, 28, 947, 9, 28, 1, 28, 1, 28, 1, 29, 1, 29,
		1, 29, 1, 29, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 5, 30, 961, 8,
		30, 10, 30, 12, 30, 964, 9, 30, 1, 30, 1, 30, 1, 31, 1, 31, 1, 31, 1, 31,
		1, 31, 5, 31, 973, 8, 31, 10, 31, 12, 31, 976, 9, 31, 1, 31, 1, 31, 1,
		32, 1, 32, 1, 32, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 3, 33, 989,
		8, 33, 1, 34, 1, 34, 1, 34, 1, 35, 1, 35, 3, 35, 996, 8, 35, 1, 36, 1,
		36, 1, 36, 1, 36, 1, 36, 3, 36, 1003, 8, 36, 1, 36, 1, 36, 1, 36, 1, 37,
		1, 37, 1, 37, 3, 37, 1011, 8, 37, 1, 38, 1, 38, 1, 38, 1, 39, 1, 39, 1,
		39, 1, 39, 5, 39, 1020, 8, 39, 10, 39, 12, 39, 1023, 9, 39, 1, 40, 1, 40,
		1, 40, 1, 40, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 5, 41, 1036,
		8, 41, 10, 41, 12, 41, 1039, 9, 41, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42,
		1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 3, 43, 1051, 8, 43, 1, 43, 1, 43, 1,
		43, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 3, 44, 1061, 8, 44, 1, 45, 1, 45,
		1, 45, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 47, 1, 47, 1, 47, 1, 47, 1,
		48, 1, 48, 1, 48, 1, 49, 1, 49, 1, 49, 1, 49, 5, 49, 1082, 8, 49, 10, 49,
		12, 49, 1085, 9, 49, 1, 50, 1, 50, 1, 50, 1, 51, 1, 51, 1, 51, 1, 51, 1,
		51, 1, 51, 5, 51, 1096, 8, 51, 10, 51, 12, 51, 1099, 9, 51, 1, 52, 1, 52,
		1, 52, 1, 52, 3, 52, 1105, 8, 52, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 5,
		53, 1112, 8, 53, 10, 53, 12, 53, 1115, 9, 53, 1, 54, 1, 54, 1, 54, 1, 54,
		1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1,
		54, 1, 54, 3, 54, 1133, 8, 54, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55,
		3, 55, 1141, 8, 55, 1, 55, 1, 55, 1, 55, 1, 55, 3, 55, 1147, 8, 55, 1,
		56, 1, 56, 1, 56, 3, 56, 1152, 8, 56, 1, 56, 1, 56, 1, 57, 1, 57, 1, 57,
		3, 57, 1159, 8, 57, 1, 57, 1, 57, 1, 57, 3, 57, 1164, 8, 57, 1, 57, 1,
		57, 1, 58, 1, 58, 1, 58, 1, 58, 3, 58, 1172, 8, 58, 1, 58, 1, 58, 1, 58,
		3, 58, 1177, 8, 58, 1, 58, 1, 58, 1, 59, 1, 59, 1, 59, 3, 59, 1184, 8,
		59, 1, 59, 1, 59, 1, 59, 3, 59, 1189, 8, 59, 1, 59, 1, 59, 1, 60, 1, 60,
		1, 60, 3, 60, 1196, 8, 60, 1, 60, 1, 60, 1, 60, 3, 60, 1201, 8, 60, 1,
		60, 1, 60, 1, 61, 1, 61, 1, 61, 3, 61, 1208, 8, 61, 1, 61, 1, 61, 1, 61,
		1, 61, 1, 61, 3, 61, 1215, 8, 61, 1, 61, 1, 61, 1, 62, 1, 62, 1, 62, 3,
		62, 1222, 8, 62, 1, 62, 1, 62, 1, 63, 1, 63, 1, 63, 3, 63, 1229, 8, 63,
		1, 63, 1, 63, 1, 63, 3, 63, 1234, 8, 63, 1, 63, 1, 63, 1, 64, 1, 64, 1,
		64, 3, 64, 1241, 8, 64, 1, 64, 1, 64, 1, 65, 1, 65, 1, 65, 3, 65, 1248,
		8, 65, 1, 65, 1, 65, 1, 65, 3, 65, 1253, 8, 65, 1, 65, 1, 65, 1, 66, 1,
		66, 1, 66, 3, 66, 1260, 8, 66, 1, 66, 1, 66, 1, 66, 3, 66, 1265, 8, 66,
		1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 3, 66, 1272, 8, 66, 1, 67, 1, 67, 1,
		67, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 3, 68, 1282, 8, 68, 1, 68, 1, 68,
		1, 68, 1, 68, 3, 68, 1288, 8, 68, 1, 68, 1, 68, 1, 68, 1, 68, 5, 68, 1294,
		8, 68, 10, 68, 12, 68, 1297, 9, 68, 1, 68, 3, 68, 1300, 8, 68, 1, 69, 1,
		69, 1, 69, 1, 69, 1, 69, 1, 69, 3, 69, 1308, 8, 69, 1, 69, 1, 69, 1, 69,
		3, 69, 1313, 8, 69, 5, 69, 1315, 8, 69, 10, 69, 12, 69, 1318, 9, 69, 1,
		69, 1, 69, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 3, 70,
		1330, 8, 70, 1, 71, 1, 71, 1, 72, 1, 72, 3, 72, 1336, 8, 72, 1, 73, 1,
		73, 1, 73, 1, 73, 1, 73, 5, 73, 1343, 8, 73, 10, 73, 12, 73, 1346, 9, 73,
		1, 73, 1, 73, 1, 74, 1, 74, 1, 74, 1, 74, 1, 75, 1, 75, 1, 76, 1, 76, 3,
		76, 1358, 8, 76, 1, 77, 1, 77, 1, 77, 1, 77, 5, 77, 1364, 8, 77, 10, 77,
		12, 77, 1367, 9, 77, 1, 77, 1, 77, 1, 77, 3, 77, 1372, 8, 77, 1, 78, 1,
		78, 1, 78, 3, 78, 1377, 8, 78, 1, 79, 1, 79, 1, 79, 1, 80, 1, 80, 1, 80,
		1, 80, 1, 80, 1, 80, 1, 81, 1, 81, 1, 81, 3, 81, 1391, 8, 81, 1, 82, 1,
		82, 1, 83, 1, 83, 1, 83, 1, 83, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84,
		1, 85, 1, 85, 1, 85, 1, 85, 5, 85, 1409, 8, 85, 10, 85, 12, 85, 1412, 9,
		85, 1, 86, 1, 86, 1, 86, 1, 86, 5, 86, 1418, 8, 86, 10, 86, 12, 86, 1421,
		9, 86, 1, 87, 1, 87, 1, 88, 1, 88, 1, 89, 1, 89, 1, 89, 1, 90, 1, 90, 3,
		90, 1432, 8, 90, 1, 90, 1, 90, 3, 90, 1436, 8, 90, 1, 91, 1, 91, 3, 91,
		1440, 8, 91, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1,
		92, 1, 92, 1, 92, 1, 92, 3, 92, 1454, 8, 92, 1, 93, 1, 93, 1, 93, 1, 93,
		5, 93, 1460, 8, 93, 10, 93, 12, 93, 1463, 9, 93, 1, 94, 1, 94, 1, 94, 1,
		94, 1, 94, 1, 94, 3, 94, 1471, 8, 94, 1, 95, 1, 95, 1, 95, 1, 95, 1, 96,
		1, 96, 1, 96, 1, 97, 1, 97, 3, 97, 1482, 8, 97, 1, 97, 1, 97, 1, 97, 3,
		97, 1487, 8, 97, 1, 97, 1, 97, 1, 98, 1, 98, 1, 98, 3, 98, 1494, 8, 98,
		1, 98, 3, 98, 1497, 8, 98, 1, 98, 1, 98, 1, 98, 1, 98, 3, 98, 1503, 8,
		98, 1, 98, 1, 98, 1, 98, 1, 98, 1, 98, 1, 99, 1, 99, 3, 99, 1512, 8, 99,
		1, 100, 1, 100, 1, 100, 1, 100, 3, 100, 1518, 8, 100, 1, 101, 1, 101, 1,
		101, 1, 101, 1, 101, 1, 102, 1, 102, 1, 102, 1, 102, 1, 102, 1, 103, 1,
		103, 1, 103, 1, 103, 1, 103, 1, 104, 3, 104, 1536, 8, 104, 1, 104, 1, 104,
		3, 104, 1540, 8, 104, 1, 104, 1, 104, 3, 104, 1544, 8, 104, 1, 104, 1,
		104, 1, 104, 3, 104, 1549, 8, 104, 1, 105, 1, 105, 1, 105, 1, 105, 5, 105,
		1555, 8, 105, 10, 105, 12, 105, 1558, 9, 105, 1, 106, 1, 106, 1, 106, 1,
		106, 1, 106, 3, 106, 1565, 8, 106, 1, 106, 1, 106, 3, 106, 1569, 8, 106,
		1, 107, 3, 107, 1572, 8, 107, 1, 107, 1, 107, 1, 107, 1, 107, 3, 107, 1578,
		8, 107, 1, 107, 1, 107, 3, 107, 1582, 8, 107, 1, 107, 1, 107, 1, 107, 1,
		107, 1, 107, 3, 107, 1589, 8, 107, 1, 108, 1, 108, 1, 108, 1, 109, 1, 109,
		1, 109, 1, 109, 5, 109, 1598, 8, 109, 10, 109, 12, 109, 1601, 9, 109, 1,
		110, 1, 110, 1, 110, 1, 110, 1, 111, 1, 111, 1, 111, 1, 111, 5, 111, 1611,
		8, 111, 10, 111, 12, 111, 1614, 9, 111, 1, 112, 1, 112, 1, 112, 1, 112,
		1, 112, 1, 112, 3, 112, 1622, 8, 112, 1, 112, 1, 112, 1, 112, 1, 112, 1,
		112, 1, 112, 1, 112, 1, 112, 1, 112, 1, 112, 1, 112, 1, 112, 1, 112, 1,
		112, 1, 112, 1, 112, 1, 112, 1, 112, 1, 112, 1, 112, 1, 112, 1, 112, 1,
		112, 1, 112, 1, 112, 1, 112, 1, 112, 1, 112, 1, 112, 1, 112, 1, 112, 1,
		112, 1, 112, 1, 112, 1, 112, 1, 112, 1, 112, 1, 112, 1, 112, 1, 112, 1,
		112, 1, 112, 1, 112, 1, 112, 1, 112, 3, 112, 1669, 8, 112, 1, 113, 1, 113,
		1, 113, 1, 113, 1, 113, 5, 113, 1676, 8, 113, 10, 113, 12, 113, 1679, 9,
		113, 3, 113, 1681, 8, 113, 1, 113, 1, 113, 1, 114, 1, 114, 1, 114, 1, 114,
		1, 114, 1, 114, 1, 114, 1, 114, 1, 114, 1, 114, 5, 114, 1695, 8, 114, 10,
		114, 12, 114, 1698, 9, 114, 1, 114, 1, 114, 1, 115, 1, 115, 1, 115, 1,
		115, 1, 115, 5, 115, 1707, 8, 115, 10, 115, 12, 115, 1710, 9, 115, 1, 115,
		1, 115, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 5, 116, 1719, 8, 116, 10,
		116, 12, 116, 1722, 9, 116, 1, 116, 1, 116, 1, 117, 3, 117, 1727, 8, 117,
		1, 117, 1, 117, 1, 117, 1, 117, 1, 117, 3, 117, 1734, 8, 117, 1, 117, 1,
		117, 3, 117, 1738, 8, 117, 1, 117, 1, 117, 3, 117, 1742, 8, 117, 1, 117,
		3, 117, 1745, 8, 117, 1, 118, 1, 118, 1, 118, 1, 118, 1, 118, 1, 118, 1,
		118, 1, 118, 1, 118, 1, 118, 1, 118, 1, 118, 1, 118, 1, 118, 1, 118, 1,
		118, 3, 118, 1763, 8, 118, 1, 119, 1, 119, 1, 119, 1, 120, 1, 120, 1, 120,
		1, 121, 1, 121, 1, 121, 1, 122, 1, 122, 1, 122, 1, 122, 1, 123, 1, 123,
		1, 123, 1, 124, 1, 124, 1, 124, 1, 124, 1, 124, 1, 124, 1, 124, 1, 124,
		3, 124, 1789, 8, 124, 1, 125, 1, 125, 1, 125, 1, 125, 1, 126, 1, 126, 1,
		126, 1, 126, 5, 126, 1799, 8, 126, 10, 126, 12, 126, 1802, 9, 126, 1, 127,
		1, 127, 1, 127, 1, 127, 5, 127, 1808, 8, 127, 10, 127, 12, 127, 1811, 9,
		127, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 3, 128, 1819, 8, 128,
		1, 129, 1, 129, 3, 129, 1823, 8, 129, 1, 129, 3, 129, 1826, 8, 129, 1,
		129, 1, 129, 1, 129, 3, 129, 1831, 8, 129, 1, 129, 3, 129, 1834, 8, 129,
		1, 129, 3, 129, 1837, 8, 129, 1, 129, 3, 129, 1840, 8, 129, 1, 130, 1,
		130, 1, 130, 1, 131, 1, 131, 1, 131, 1, 132, 1, 132, 1, 132, 1, 133, 1,
		133, 1, 133, 1, 133, 3, 133, 1855, 8, 133, 1, 134, 1, 134, 1, 134, 1, 134,
		1, 135, 1, 135, 1, 135, 3, 135, 1864, 8, 135, 1, 136, 1, 136, 1, 136, 1,
		137, 1, 137, 1, 138, 1, 138, 3, 138, 1873, 8, 138, 1, 138, 1, 138, 1, 138,
		5, 138, 1878, 8, 138, 10, 138, 12, 138, 1881, 9, 138, 1, 139, 1, 139, 1,
		139, 1, 139, 1, 139, 1, 139, 1, 139, 3, 139, 1890, 8, 139, 1, 139, 1, 139,
		1, 139, 1, 139, 3, 139, 1896, 8, 139, 3, 139, 1898, 8, 139, 1, 140, 1,
		140, 1, 140, 1, 140, 5, 140, 1904, 8, 140, 10, 140, 12, 140, 1907, 9, 140,
		1, 141, 1, 141, 1, 141, 1, 141, 1, 141, 1, 141, 1, 141, 1, 141, 1, 141,
		1, 141, 1, 141, 1, 141, 1, 141, 1, 141, 1, 141, 1, 141, 1, 141, 1, 141,
		1, 141, 1, 141, 3, 141, 1929, 8, 141, 1, 141, 1, 141, 1, 141, 1, 141, 1,
		141, 1, 141, 1, 141, 5, 141, 1938, 8, 141, 10, 141, 12, 141, 1941, 9, 141,
		1, 141, 1, 141, 1, 141, 1, 141, 1, 141, 1, 141, 1, 141, 5, 141, 1950, 8,
		141, 10, 141, 12, 141, 1953, 9, 141, 1, 141, 1, 141, 1, 141, 1, 141, 1,
		141, 1, 141, 1, 141, 5, 141, 1962, 8, 141, 10, 141, 12, 141, 1965, 9, 141,
		1, 141, 1, 141, 1, 141, 1, 141, 1, 141, 1, 141, 5, 141, 1973, 8, 141, 10,
		141, 12, 141, 1976, 9, 141, 1, 141, 1, 141, 3, 141, 1980, 8, 141, 1, 142,
		1, 142, 1, 142, 1, 142, 1, 143, 1, 143, 1, 143, 1, 143, 1, 143, 1, 143,
		1, 144, 1, 144, 1, 144, 1, 144, 1, 144, 1, 144, 1, 144, 3, 144, 1999, 8,
		144, 1, 144, 1, 144, 1, 144, 1, 144, 3, 144, 2005, 8, 144, 1, 145, 1, 145,
		1, 145, 3, 145, 2010, 8, 145, 1, 145, 1, 145, 1, 145, 1, 145, 3, 145, 2016,
		8, 145, 5, 145, 2018, 8, 145, 10, 145, 12, 145, 2021, 9, 145, 1, 146, 1,
		146, 1, 146, 1, 146, 1, 146, 1, 146, 1, 146, 1, 146, 3, 146, 2031, 8, 146,
		1, 147, 1, 147, 1, 148, 1, 148, 1, 149, 1, 149, 1, 150, 1, 150, 1, 151,
		1, 151, 1, 152, 1, 152, 1, 152, 1, 152, 3, 152, 2047, 8, 152, 1, 153, 1,
		153, 1, 153, 1, 153, 3, 153, 2053, 8, 153, 1, 154, 1, 154, 1, 154, 1, 154,
		3, 154, 2059, 8, 154, 1, 155, 1, 155, 3, 155, 2063, 8, 155, 1, 156, 1,
		156, 1, 157, 1, 157, 1, 157, 1, 157, 1, 157, 5, 157, 2072, 8, 157, 10,
		157, 12, 157, 2075, 9, 157, 1, 157, 1, 157, 1, 158, 1, 158, 3, 158, 2081,
		8, 158, 1, 159, 1, 159, 1, 160, 1, 160, 1, 161, 1, 161, 1, 162, 1, 162,
		1, 163, 1, 163, 1, 164, 1, 164, 1, 165, 1, 165, 1, 166, 1, 166, 1, 167,
		1, 167, 1, 168, 1, 168, 1, 169, 1, 169, 1, 170, 1, 170, 1, 170, 1, 171,
		1, 171, 1, 172, 1, 172, 1, 173, 1, 173, 1, 174, 1, 174, 1, 175, 1, 175,
		1, 175, 1, 176, 1, 176, 1, 177, 1, 177, 1, 178, 1, 178, 1, 179, 1, 179,
		1, 180, 1, 180, 1, 181, 1, 181, 1, 182, 1, 182, 1, 183, 1, 183, 1, 184,
		1, 184, 1, 185, 1, 185, 1, 186, 1, 186, 1, 187, 1, 187, 1, 188, 1, 188,
		1, 189, 1, 189, 1, 190, 1, 190, 1, 191, 1, 191, 1, 192, 1, 192, 1, 193,
		1, 193, 1, 194, 1, 194, 1, 195, 1, 195, 1, 196, 1, 196, 1, 197, 1, 197,
		1, 198, 1, 198, 1, 199, 1, 199, 1, 200, 1, 200, 1, 201, 1, 201, 1, 202,
		1, 202, 1, 203, 1, 203, 1, 204, 1, 204, 1, 205, 1, 205, 1, 206, 1, 206,
		1, 207, 1, 207, 1, 208, 1, 208, 1, 209, 1, 209, 1, 210, 1, 210, 1, 211,
		1, 211, 1, 212, 1, 212, 1, 213, 1, 213, 1, 214, 1, 214, 1, 215, 1, 215,
		1, 216, 1, 216, 1, 217, 1, 217, 1, 218, 1, 218, 1, 219, 1, 219, 1, 220,
		1, 220, 1, 221, 1, 221, 1, 222, 1, 222, 1, 223, 1, 223, 1, 224, 1, 224,
		1, 225, 1, 225, 1, 226, 1, 226, 1, 227, 1, 227, 1, 228, 1, 228, 1, 229,
		1, 229, 1, 230, 1, 230, 1, 231, 1, 231, 1, 232, 1, 232, 1, 233, 1, 233,
		1, 234, 1, 234, 1, 235, 1, 235, 1, 236, 1, 236, 1, 237, 1, 237, 1, 238,
		1, 238, 1, 239, 1, 239, 1, 240, 1, 240, 1, 241, 1, 241, 1, 242, 1, 242,
		1, 243, 1, 243, 1, 244, 1, 244, 1, 245, 1, 245, 1, 246, 1, 246, 1, 247,
		1, 247, 1, 248, 1, 248, 1, 249, 1, 249, 1, 250, 1, 250, 1, 251, 1, 251,
		1, 252, 1, 252, 1, 253, 1, 253, 1, 254, 1, 254, 1, 255, 1, 255, 1, 256,
		1, 256, 1, 257, 1, 257, 1, 258, 1, 258, 1, 259, 1, 259, 1, 260, 1, 260,
		1, 261, 1, 261, 1, 262, 1, 262, 1, 263, 1, 263, 1, 264, 1, 264, 1, 265,
		1, 265, 1, 266, 1, 266, 1, 267, 1, 267, 1, 268, 1, 268, 1, 269, 1, 269,
		1, 270, 1, 270, 1, 271, 1, 271, 1, 272, 1, 272, 1, 273, 1, 273, 1, 274,
		1, 274, 1, 275, 1, 275, 1, 276, 1, 276, 1, 276, 0, 0, 277, 0, 2, 4, 6,
		8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42,
		44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78,
		80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112,
		114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142,
		144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172,
		174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 202,
		204, 206, 208, 210, 212, 214, 216, 218, 220, 222, 224, 226, 228, 230, 232,
		234, 236, 238, 240, 242, 244, 246, 248, 250, 252, 254, 256, 258, 260, 262,
		264, 266, 268, 270, 272, 274, 276, 278, 280, 282, 284, 286, 288, 290, 292,
		294, 296, 298, 300, 302, 304, 306, 308, 310, 312, 314, 316, 318, 320, 322,
		324, 326, 328, 330, 332, 334, 336, 338, 340, 342, 344, 346, 348, 350, 352,
		354, 356, 358, 360, 362, 364, 366, 368, 370, 372, 374, 376, 378, 380, 382,
		384, 386, 388, 390, 392, 394, 396, 398, 400, 402, 404, 406, 408, 410, 412,
		414, 416, 418, 420, 422, 424, 426, 428, 430, 432, 434, 436, 438, 440, 442,
		444, 446, 448, 450, 452, 454, 456, 458, 460, 462, 464, 466, 468, 470, 472,
		474, 476, 478, 480, 482, 484, 486, 488, 490, 492, 494, 496, 498, 500, 502,
		504, 506, 508, 510, 512, 514, 516, 518, 520, 522, 524, 526, 528, 530, 532,
		534, 536, 538, 540, 542, 544, 546, 548, 550, 552, 0, 7, 1, 0, 164, 165,
		2, 0, 14, 14, 16, 16, 1, 0, 19, 23, 1, 0, 166, 167, 2, 0, 56, 56, 126,
		126, 5, 0, 114, 114, 122, 122, 136, 136, 142, 163, 170, 170, 2, 0, 69,
		69, 170, 170, 2319, 0, 555, 1, 0, 0, 0, 2, 571, 1, 0, 0, 0, 4, 584, 1,
		0, 0, 0, 6, 586, 1, 0, 0, 0, 8, 625, 1, 0, 0, 0, 10, 627, 1, 0, 0, 0, 12,
		634, 1, 0, 0, 0, 14, 644, 1, 0, 0, 0, 16, 656, 1, 0, 0, 0, 18, 675, 1,
		0, 0, 0, 20, 715, 1, 0, 0, 0, 22, 717, 1, 0, 0, 0, 24, 730, 1, 0, 0, 0,
		26, 739, 1, 0, 0, 0, 28, 754, 1, 0, 0, 0, 30, 765, 1, 0, 0, 0, 32, 779,
		1, 0, 0, 0, 34, 812, 1, 0, 0, 0, 36, 819, 1, 0, 0, 0, 38, 828, 1, 0, 0,
		0, 40, 839, 1, 0, 0, 0, 42, 841, 1, 0, 0, 0, 44, 858, 1, 0, 0, 0, 46, 885,
		1, 0, 0, 0, 48, 887, 1, 0, 0, 0, 50, 900, 1, 0, 0, 0, 52, 906, 1, 0, 0,
		0, 54, 936, 1, 0, 0, 0, 56, 938, 1, 0, 0, 0, 58, 950, 1, 0, 0, 0, 60, 954,
		1, 0, 0, 0, 62, 967, 1, 0, 0, 0, 64, 979, 1, 0, 0, 0, 66, 982, 1, 0, 0,
		0, 68, 990, 1, 0, 0, 0, 70, 995, 1, 0, 0, 0, 72, 997, 1, 0, 0, 0, 74, 1010,
		1, 0, 0, 0, 76, 1012, 1, 0, 0, 0, 78, 1015, 1, 0, 0, 0, 80, 1024, 1, 0,
		0, 0, 82, 1028, 1, 0, 0, 0, 84, 1040, 1, 0, 0, 0, 86, 1045, 1, 0, 0, 0,
		88, 1060, 1, 0, 0, 0, 90, 1062, 1, 0, 0, 0, 92, 1065, 1, 0, 0, 0, 94, 1070,
		1, 0, 0, 0, 96, 1074, 1, 0, 0, 0, 98, 1077, 1, 0, 0, 0, 100, 1086, 1, 0,
		0, 0, 102, 1089, 1, 0, 0, 0, 104, 1100, 1, 0, 0, 0, 106, 1106, 1, 0, 0,
		0, 108, 1132, 1, 0, 0, 0, 110, 1134, 1, 0, 0, 0, 112, 1148, 1, 0, 0, 0,
		114, 1155, 1, 0, 0, 0, 116, 1167, 1, 0, 0, 0, 118, 1180, 1, 0, 0, 0, 120,
		1192, 1, 0, 0, 0, 122, 1204, 1, 0, 0, 0, 124, 1218, 1, 0, 0, 0, 126, 1225,
		1, 0, 0, 0, 128, 1237, 1, 0, 0, 0, 130, 1244, 1, 0, 0, 0, 132, 1256, 1,
		0, 0, 0, 134, 1273, 1, 0, 0, 0, 136, 1299, 1, 0, 0, 0, 138, 1301, 1, 0,
		0, 0, 140, 1329, 1, 0, 0, 0, 142, 1331, 1, 0, 0, 0, 144, 1335, 1, 0, 0,
		0, 146, 1337, 1, 0, 0, 0, 148, 1349, 1, 0, 0, 0, 150, 1353, 1, 0, 0, 0,
		152, 1357, 1, 0, 0, 0, 154, 1359, 1, 0, 0, 0, 156, 1373, 1, 0, 0, 0, 158,
		1378, 1, 0, 0, 0, 160, 1381, 1, 0, 0, 0, 162, 1390, 1, 0, 0, 0, 164, 1392,
		1, 0, 0, 0, 166, 1394, 1, 0, 0, 0, 168, 1398, 1, 0, 0, 0, 170, 1404, 1,
		0, 0, 0, 172, 1413, 1, 0, 0, 0, 174, 1422, 1, 0, 0, 0, 176, 1424, 1, 0,
		0, 0, 178, 1426, 1, 0, 0, 0, 180, 1429, 1, 0, 0, 0, 182, 1439, 1, 0, 0,
		0, 184, 1441, 1, 0, 0, 0, 186, 1455, 1, 0, 0, 0, 188, 1470, 1, 0, 0, 0,
		190, 1472, 1, 0, 0, 0, 192, 1476, 1, 0, 0, 0, 194, 1479, 1, 0, 0, 0, 196,
		1490, 1, 0, 0, 0, 198, 1511, 1, 0, 0, 0, 200, 1517, 1, 0, 0, 0, 202, 1519,
		1, 0, 0, 0, 204, 1524, 1, 0, 0, 0, 206, 1529, 1, 0, 0, 0, 208, 1535, 1,
		0, 0, 0, 210, 1550, 1, 0, 0, 0, 212, 1568, 1, 0, 0, 0, 214, 1571, 1, 0,
		0, 0, 216, 1590, 1, 0, 0, 0, 218, 1593, 1, 0, 0, 0, 220, 1602, 1, 0, 0,
		0, 222, 1606, 1, 0, 0, 0, 224, 1668, 1, 0, 0, 0, 226, 1670, 1, 0, 0, 0,
		228, 1684, 1, 0, 0, 0, 230, 1701, 1, 0, 0, 0, 232, 1713, 1, 0, 0, 0, 234,
		1726, 1, 0, 0, 0, 236, 1762, 1, 0, 0, 0, 238, 1764, 1, 0, 0, 0, 240, 1767,
		1, 0, 0, 0, 242, 1770, 1, 0, 0, 0, 244, 1773, 1, 0, 0, 0, 246, 1777, 1,
		0, 0, 0, 248, 1788, 1, 0, 0, 0, 250, 1790, 1, 0, 0, 0, 252, 1794, 1, 0,
		0, 0, 254, 1803, 1, 0, 0, 0, 256, 1818, 1, 0, 0, 0, 258, 1820, 1, 0, 0,
		0, 260, 1841, 1, 0, 0, 0, 262, 1844, 1, 0, 0, 0, 264, 1847, 1, 0, 0, 0,
		266, 1854, 1, 0, 0, 0, 268, 1856, 1, 0, 0, 0, 270, 1860, 1, 0, 0, 0, 272,
		1865, 1, 0, 0, 0, 274, 1868, 1, 0, 0, 0, 276, 1872, 1, 0, 0, 0, 278, 1897,
		1, 0, 0, 0, 280, 1899, 1, 0, 0, 0, 282, 1979, 1, 0, 0, 0, 284, 1981, 1,
		0, 0, 0, 286, 1985, 1, 0, 0, 0, 288, 2004, 1, 0, 0, 0, 290, 2009, 1, 0,
		0, 0, 292, 2030, 1, 0, 0, 0, 294, 2032, 1, 0, 0, 0, 296, 2034, 1, 0, 0,
		0, 298, 2036, 1, 0, 0, 0, 300, 2038, 1, 0, 0, 0, 302, 2040, 1, 0, 0, 0,
		304, 2046, 1, 0, 0, 0, 306, 2052, 1, 0, 0, 0, 308, 2058, 1, 0, 0, 0, 310,
		2060, 1, 0, 0, 0, 312, 2064, 1, 0, 0, 0, 314, 2066, 1, 0, 0, 0, 316, 2080,
		1, 0, 0, 0, 318, 2082, 1, 0, 0, 0, 320, 2084, 1, 0, 0, 0, 322, 2086, 1,
		0, 0, 0, 324, 2088, 1, 0, 0, 0, 326, 2090, 1, 0, 0, 0, 328, 2092, 1, 0,
		0, 0, 330, 2094, 1, 0, 0, 0, 332, 2096, 1, 0, 0, 0, 334, 2098, 1, 0, 0,
		0, 336, 2100, 1, 0, 0, 0, 338, 2102, 1, 0, 0, 0, 340, 2104, 1, 0, 0, 0,
		342, 2107, 1, 0, 0, 0, 344, 2109, 1, 0, 0, 0, 346, 2111, 1, 0, 0, 0, 348,
		2113, 1, 0, 0, 0, 350, 2115, 1, 0, 0, 0, 352, 2118, 1, 0, 0, 0, 354, 2120,
		1, 0, 0, 0, 356, 2122, 1, 0, 0, 0, 358, 2124, 1, 0, 0, 0, 360, 2126, 1,
		0, 0, 0, 362, 2128, 1, 0, 0, 0, 364, 2130, 1, 0, 0, 0, 366, 2132, 1, 0,
		0, 0, 368, 2134, 1, 0, 0, 0, 370, 2136, 1, 0, 0, 0, 372, 2138, 1, 0, 0,
		0, 374, 2140, 1, 0, 0, 0, 376, 2142, 1, 0, 0, 0, 378, 2144, 1, 0, 0, 0,
		380, 2146, 1, 0, 0, 0, 382, 2148, 1, 0, 0, 0, 384, 2150, 1, 0, 0, 0, 386,
		2152, 1, 0, 0, 0, 388, 2154, 1, 0, 0, 0, 390, 2156, 1, 0, 0, 0, 392, 2158,
		1, 0, 0, 0, 394, 2160, 1, 0, 0, 0, 396, 2162, 1, 0, 0, 0, 398, 2164, 1,
		0, 0, 0, 400, 2166, 1, 0, 0, 0, 402, 2168, 1, 0, 0, 0, 404, 2170, 1, 0,
		0, 0, 406, 2172, 1, 0, 0, 0, 408, 2174, 1, 0, 0, 0, 410, 2176, 1, 0, 0,
		0, 412, 2178, 1, 0, 0, 0, 414, 2180, 1, 0, 0, 0, 416, 2182, 1, 0, 0, 0,
		418, 2184, 1, 0, 0, 0, 420, 2186, 1, 0, 0, 0, 422, 2188, 1, 0, 0, 0, 424,
		2190, 1, 0, 0, 0, 426, 2192, 1, 0, 0, 0, 428, 2194, 1, 0, 0, 0, 430, 2196,
		1, 0, 0, 0, 432, 2198, 1, 0, 0, 0, 434, 2200, 1, 0, 0, 0, 436, 2202, 1,
		0, 0, 0, 438, 2204, 1, 0, 0, 0, 440, 2206, 1, 0, 0, 0, 442, 2208, 1, 0,
		0, 0, 444, 2210, 1, 0, 0, 0, 446, 2212, 1, 0, 0, 0, 448, 2214, 1, 0, 0,
		0, 450, 2216, 1, 0, 0, 0, 452, 2218, 1, 0, 0, 0, 454, 2220, 1, 0, 0, 0,
		456, 2222, 1, 0, 0, 0, 458, 2224, 1, 0, 0, 0, 460, 2226, 1, 0, 0, 0, 462,
		2228, 1, 0, 0, 0, 464, 2230, 1, 0, 0, 0, 466, 2232, 1, 0, 0, 0, 468, 2234,
		1, 0, 0, 0, 470, 2236, 1, 0, 0, 0, 472, 2238, 1, 0, 0, 0, 474, 2240, 1,
		0, 0, 0, 476, 2242, 1, 0, 0, 0, 478, 2244, 1, 0, 0, 0, 480, 2246, 1, 0,
		0, 0, 482, 2248, 1, 0, 0, 0, 484, 2250, 1, 0, 0, 0, 486, 2252, 1, 0, 0,
		0, 488, 2254, 1, 0, 0, 0, 490, 2256, 1, 0, 0, 0, 492, 2258, 1, 0, 0, 0,
		494, 2260, 1, 0, 0, 0, 496, 2262, 1, 0, 0, 0, 498, 2264, 1, 0, 0, 0, 500,
		2266, 1, 0, 0, 0, 502, 2268, 1, 0, 0, 0, 504, 2270, 1, 0, 0, 0, 506, 2272,
		1, 0, 0, 0, 508, 2274, 1, 0, 0, 0, 510, 2276, 1, 0, 0, 0, 512, 2278, 1,
		0, 0, 0, 514, 2280, 1, 0, 0, 0, 516, 2282, 1, 0, 0, 0, 518, 2284, 1, 0,
		0, 0, 520, 2286, 1, 0, 0, 0, 522, 2288, 1, 0, 0, 0, 524, 2290, 1, 0, 0,
		0, 526, 2292, 1, 0, 0, 0, 528, 2294, 1, 0, 0, 0, 530, 2296, 1, 0, 0, 0,
		532, 2298, 1, 0, 0, 0, 534, 2300, 1, 0, 0, 0, 536, 2302, 1, 0, 0, 0, 538,
		2304, 1, 0, 0, 0, 540, 2306, 1, 0, 0, 0, 542, 2308, 1, 0, 0, 0, 544, 2310,
		1, 0, 0, 0, 546, 2312, 1, 0, 0, 0, 548, 2314, 1, 0, 0, 0, 550, 2316, 1,
		0, 0, 0, 552, 2318, 1, 0, 0, 0, 554, 556, 3, 2, 1, 0, 555, 554, 1, 0, 0,
		0, 555, 556, 1, 0, 0, 0, 556, 558, 1, 0, 0, 0, 557, 559, 5, 15, 0, 0, 558,
		557, 1, 0, 0, 0, 558, 559, 1, 0, 0, 0, 559, 560, 1, 0, 0, 0, 560, 561,
		5, 0, 0, 1, 561, 1, 1, 0, 0, 0, 562, 564, 3, 8, 4, 0, 563, 565, 5, 15,
		0, 0, 564, 563, 1, 0, 0, 0, 564, 565, 1, 0, 0, 0, 565, 566, 1, 0, 0, 0,
		566, 567, 3, 4, 2, 0, 567, 570, 1, 0, 0, 0, 568, 570, 3, 6, 3, 0, 569,
		562, 1, 0, 0, 0, 569, 568, 1, 0, 0, 0, 570, 573, 1, 0, 0, 0, 571, 569,
		1, 0, 0, 0, 571, 572, 1, 0, 0, 0, 572, 582, 1, 0, 0, 0, 573, 571, 1, 0,
		0, 0, 574, 579, 3, 8, 4, 0, 575, 577, 5, 15, 0, 0, 576, 575, 1, 0, 0, 0,
		576, 577, 1, 0, 0, 0, 577, 578, 1, 0, 0, 0, 578, 580, 3, 4, 2, 0, 579,
		576, 1, 0, 0, 0, 579, 580, 1, 0, 0, 0, 580, 583, 1, 0, 0, 0, 581, 583,
		3, 6, 3, 0, 582, 574, 1, 0, 0, 0, 582, 581, 1, 0, 0, 0, 583, 3, 1, 0, 0,
		0, 584, 585, 5, 8, 0, 0, 585, 5, 1, 0, 0, 0, 586, 587, 3, 4, 2, 0, 587,
		7, 1, 0, 0, 0, 588, 626, 3, 184, 92, 0, 589, 626, 3, 110, 55, 0, 590, 626,
		3, 104, 52, 0, 591, 626, 3, 86, 43, 0, 592, 626, 3, 72, 36, 0, 593, 626,
		3, 66, 33, 0, 594, 626, 3, 178, 89, 0, 595, 626, 3, 52, 26, 0, 596, 626,
		3, 44, 22, 0, 597, 626, 3, 196, 98, 0, 598, 626, 3, 42, 21, 0, 599, 626,
		3, 32, 16, 0, 600, 626, 3, 24, 12, 0, 601, 626, 3, 132, 66, 0, 602, 626,
		3, 30, 15, 0, 603, 626, 3, 26, 13, 0, 604, 626, 3, 22, 11, 0, 605, 626,
		3, 208, 104, 0, 606, 626, 3, 118, 59, 0, 607, 626, 3, 120, 60, 0, 608,
		626, 3, 130, 65, 0, 609, 626, 3, 128, 64, 0, 610, 626, 3, 116, 58, 0, 611,
		626, 3, 124, 62, 0, 612, 626, 3, 126, 63, 0, 613, 626, 3, 122, 61, 0, 614,
		626, 3, 114, 57, 0, 615, 626, 3, 112, 56, 0, 616, 626, 3, 16, 8, 0, 617,
		626, 3, 234, 117, 0, 618, 626, 3, 14, 7, 0, 619, 626, 3, 12, 6, 0, 620,
		626, 3, 10, 5, 0, 621, 626, 3, 258, 129, 0, 622, 626, 3, 194, 97, 0, 623,
		626, 3, 214, 107, 0, 624, 626, 3, 192, 96, 0, 625, 588, 1, 0, 0, 0, 625,
		589, 1, 0, 0, 0, 625, 590, 1, 0, 0, 0, 625, 591, 1, 0, 0, 0, 625, 592,
		1, 0, 0, 0, 625, 593, 1, 0, 0, 0, 625, 594, 1, 0, 0, 0, 625, 595, 1, 0,
		0, 0, 625, 596, 1, 0, 0, 0, 625, 597, 1, 0, 0, 0, 625, 598, 1, 0, 0, 0,
		625, 599, 1, 0, 0, 0, 625, 600, 1, 0, 0, 0, 625, 601, 1, 0, 0, 0, 625,
		602, 1, 0, 0, 0, 625, 603, 1, 0, 0, 0, 625, 604, 1, 0, 0, 0, 625, 605,
		1, 0, 0, 0, 625, 606, 1, 0, 0, 0, 625, 607, 1, 0, 0, 0, 625, 608, 1, 0,
		0, 0, 625, 609, 1, 0, 0, 0, 625, 610, 1, 0, 0, 0, 625, 611, 1, 0, 0, 0,
		625, 612, 1, 0, 0, 0, 625, 613, 1, 0, 0, 0, 625, 614, 1, 0, 0, 0, 625,
		615, 1, 0, 0, 0, 625, 616, 1, 0, 0, 0, 625, 617, 1, 0, 0, 0, 625, 618,
		1, 0, 0, 0, 625, 619, 1, 0, 0, 0, 625, 620, 1, 0, 0, 0, 625, 621, 1, 0,
		0, 0, 625, 622, 1, 0, 0, 0, 625, 623, 1, 0, 0, 0, 625, 624, 1, 0, 0, 0,
		626, 9, 1, 0, 0, 0, 627, 628, 3, 532, 266, 0, 628, 629, 3, 18, 9, 0, 629,
		630, 3, 464, 232, 0, 630, 631, 3, 20, 10, 0, 631, 632, 3, 404, 202, 0,
		632, 633, 3, 318, 159, 0, 633, 11, 1, 0, 0, 0, 634, 635, 3, 444, 222, 0,
		635, 639, 3, 486, 243, 0, 636, 637, 3, 462, 231, 0, 637, 638, 3, 318, 159,
		0, 638, 640, 1, 0, 0, 0, 639, 636, 1, 0, 0, 0, 639, 640, 1, 0, 0, 0, 640,
		642, 1, 0, 0, 0, 641, 643, 3, 456, 228, 0, 642, 641, 1, 0, 0, 0, 642, 643,
		1, 0, 0, 0, 643, 13, 1, 0, 0, 0, 644, 645, 3, 444, 222, 0, 645, 649, 3,
		18, 9, 0, 646, 647, 3, 464, 232, 0, 647, 648, 3, 20, 10, 0, 648, 650, 1,
		0, 0, 0, 649, 646, 1, 0, 0, 0, 649, 650, 1, 0, 0, 0, 650, 654, 1, 0, 0,
		0, 651, 652, 3, 462, 231, 0, 652, 653, 3, 318, 159, 0, 653, 655, 1, 0,
		0, 0, 654, 651, 1, 0, 0, 0, 654, 655, 1, 0, 0, 0, 655, 15, 1, 0, 0, 0,
		656, 657, 3, 412, 206, 0, 657, 658, 3, 18, 9, 0, 658, 659, 3, 464, 232,
		0, 659, 660, 3, 20, 10, 0, 660, 661, 3, 504, 252, 0, 661, 662, 3, 318,
		159, 0, 662, 17, 1, 0, 0, 0, 663, 666, 3, 348, 174, 0, 664, 666, 3, 350,
		175, 0, 665, 663, 1, 0, 0, 0, 665, 664, 1, 0, 0, 0, 666, 676, 1, 0, 0,
		0, 667, 676, 3, 354, 177, 0, 668, 676, 3, 364, 182, 0, 669, 676, 3, 386,
		193, 0, 670, 676, 3, 396, 198, 0, 671, 676, 3, 380, 190, 0, 672, 676, 3,
		390, 195, 0, 673, 676, 3, 452, 226, 0, 674, 676, 3, 488, 244, 0, 675, 665,
		1, 0, 0, 0, 675, 667, 1, 0, 0, 0, 675, 668, 1, 0, 0, 0, 675, 669, 1, 0,
		0, 0, 675, 670, 1, 0, 0, 0, 675, 671, 1, 0, 0, 0, 675, 672, 1, 0, 0, 0,
		675, 673, 1, 0, 0, 0, 675, 674, 1, 0, 0, 0, 676, 19, 1, 0, 0, 0, 677, 678,
		3, 348, 174, 0, 678, 679, 3, 410, 205, 0, 679, 716, 1, 0, 0, 0, 680, 681,
		3, 348, 174, 0, 681, 682, 3, 410, 205, 0, 682, 683, 3, 416, 208, 0, 683,
		684, 3, 436, 218, 0, 684, 685, 3, 304, 152, 0, 685, 716, 1, 0, 0, 0, 686,
		690, 3, 408, 204, 0, 687, 688, 3, 304, 152, 0, 688, 689, 5, 10, 0, 0, 689,
		691, 1, 0, 0, 0, 690, 687, 1, 0, 0, 0, 690, 691, 1, 0, 0, 0, 691, 692,
		1, 0, 0, 0, 692, 693, 3, 330, 165, 0, 693, 716, 1, 0, 0, 0, 694, 695, 3,
		348, 174, 0, 695, 696, 3, 438, 219, 0, 696, 716, 1, 0, 0, 0, 697, 698,
		3, 436, 218, 0, 698, 699, 3, 304, 152, 0, 699, 716, 1, 0, 0, 0, 700, 702,
		3, 500, 250, 0, 701, 700, 1, 0, 0, 0, 701, 702, 1, 0, 0, 0, 702, 706, 1,
		0, 0, 0, 703, 704, 3, 304, 152, 0, 704, 705, 5, 10, 0, 0, 705, 707, 1,
		0, 0, 0, 706, 703, 1, 0, 0, 0, 706, 707, 1, 0, 0, 0, 707, 708, 1, 0, 0,
		0, 708, 716, 3, 306, 153, 0, 709, 710, 3, 348, 174, 0, 710, 711, 3, 486,
		243, 0, 711, 716, 1, 0, 0, 0, 712, 713, 3, 484, 242, 0, 713, 714, 3, 318,
		159, 0, 714, 716, 1, 0, 0, 0, 715, 677, 1, 0, 0, 0, 715, 680, 1, 0, 0,
		0, 715, 686, 1, 0, 0, 0, 715, 694, 1, 0, 0, 0, 715, 697, 1, 0, 0, 0, 715,
		701, 1, 0, 0, 0, 715, 709, 1, 0, 0, 0, 715, 712, 1, 0, 0, 0, 716, 21, 1,
		0, 0, 0, 717, 718, 3, 380, 190, 0, 718, 720, 3, 520, 260, 0, 719, 721,
		3, 244, 122, 0, 720, 719, 1, 0, 0, 0, 720, 721, 1, 0, 0, 0, 721, 722, 1,
		0, 0, 0, 722, 723, 3, 334, 167, 0, 723, 724, 3, 530, 265, 0, 724, 725,
		3, 472, 236, 0, 725, 728, 3, 298, 149, 0, 726, 729, 3, 498, 249, 0, 727,
		729, 3, 454, 227, 0, 728, 726, 1, 0, 0, 0, 728, 727, 1, 0, 0, 0, 728, 729,
		1, 0, 0, 0, 729, 23, 1, 0, 0, 0, 730, 731, 3, 380, 190, 0, 731, 733, 3,
		484, 242, 0, 732, 734, 3, 244, 122, 0, 733, 732, 1, 0, 0, 0, 733, 734,
		1, 0, 0, 0, 734, 735, 1, 0, 0, 0, 735, 737, 3, 318, 159, 0, 736, 738, 3,
		106, 53, 0, 737, 736, 1, 0, 0, 0, 737, 738, 1, 0, 0, 0, 738, 25, 1, 0,
		0, 0, 739, 740, 3, 380, 190, 0, 740, 742, 3, 512, 256, 0, 741, 743, 3,
		244, 122, 0, 742, 741, 1, 0, 0, 0, 742, 743, 1, 0, 0, 0, 743, 747, 1, 0,
		0, 0, 744, 745, 3, 304, 152, 0, 745, 746, 5, 10, 0, 0, 746, 748, 1, 0,
		0, 0, 747, 744, 1, 0, 0, 0, 747, 748, 1, 0, 0, 0, 748, 749, 1, 0, 0, 0,
		749, 750, 3, 326, 163, 0, 750, 751, 3, 534, 267, 0, 751, 752, 3, 28, 14,
		0, 752, 753, 3, 536, 268, 0, 753, 27, 1, 0, 0, 0, 754, 755, 3, 308, 154,
		0, 755, 762, 3, 310, 155, 0, 756, 757, 3, 550, 275, 0, 757, 758, 3, 308,
		154, 0, 758, 759, 3, 310, 155, 0, 759, 761, 1, 0, 0, 0, 760, 756, 1, 0,
		0, 0, 761, 764, 1, 0, 0, 0, 762, 760, 1, 0, 0, 0, 762, 763, 1, 0, 0, 0,
		763, 29, 1, 0, 0, 0, 764, 762, 1, 0, 0, 0, 765, 766, 3, 380, 190, 0, 766,
		768, 3, 506, 253, 0, 767, 769, 3, 244, 122, 0, 768, 767, 1, 0, 0, 0, 768,
		769, 1, 0, 0, 0, 769, 773, 1, 0, 0, 0, 770, 771, 3, 304, 152, 0, 771, 772,
		5, 10, 0, 0, 772, 774, 1, 0, 0, 0, 773, 770, 1, 0, 0, 0, 773, 774, 1, 0,
		0, 0, 774, 775, 1, 0, 0, 0, 775, 776, 3, 320, 160, 0, 776, 777, 3, 522,
		261, 0, 777, 778, 3, 322, 161, 0, 778, 31, 1, 0, 0, 0, 779, 780, 3, 380,
		190, 0, 780, 781, 3, 450, 225, 0, 781, 783, 3, 526, 263, 0, 782, 784, 3,
		244, 122, 0, 783, 782, 1, 0, 0, 0, 783, 784, 1, 0, 0, 0, 784, 788, 1, 0,
		0, 0, 785, 786, 3, 304, 152, 0, 786, 787, 5, 10, 0, 0, 787, 789, 1, 0,
		0, 0, 788, 785, 1, 0, 0, 0, 788, 789, 1, 0, 0, 0, 789, 790, 1, 0, 0, 0,
		790, 791, 3, 324, 162, 0, 791, 792, 3, 360, 180, 0, 792, 793, 3, 488, 244,
		0, 793, 794, 3, 252, 126, 0, 794, 798, 3, 404, 202, 0, 795, 796, 3, 304,
		152, 0, 796, 797, 5, 10, 0, 0, 797, 799, 1, 0, 0, 0, 798, 795, 1, 0, 0,
		0, 798, 799, 1, 0, 0, 0, 799, 800, 1, 0, 0, 0, 800, 801, 3, 306, 153, 0,
		801, 802, 3, 34, 17, 0, 802, 803, 3, 474, 237, 0, 803, 804, 3, 432, 216,
		0, 804, 805, 3, 534, 267, 0, 805, 806, 3, 252, 126, 0, 806, 810, 3, 536,
		268, 0, 807, 808, 3, 530, 265, 0, 808, 809, 3, 40, 20, 0, 809, 811, 1,
		0, 0, 0, 810, 807, 1, 0, 0, 0, 810, 811, 1, 0, 0, 0, 811, 33, 1, 0, 0,
		0, 812, 813, 3, 528, 264, 0, 813, 817, 3, 36, 18, 0, 814, 815, 3, 356,
		178, 0, 815, 816, 3, 280, 140, 0, 816, 818, 1, 0, 0, 0, 817, 814, 1, 0,
		0, 0, 817, 818, 1, 0, 0, 0, 818, 35, 1, 0, 0, 0, 819, 825, 3, 38, 19, 0,
		820, 821, 3, 356, 178, 0, 821, 822, 3, 38, 19, 0, 822, 824, 1, 0, 0, 0,
		823, 820, 1, 0, 0, 0, 824, 827, 1, 0, 0, 0, 825, 823, 1, 0, 0, 0, 825,
		826, 1, 0, 0, 0, 826, 37, 1, 0, 0, 0, 827, 825, 1, 0, 0, 0, 828, 829, 3,
		308, 154, 0, 829, 830, 3, 428, 214, 0, 830, 831, 3, 458, 229, 0, 831, 832,
		3, 460, 230, 0, 832, 39, 1, 0, 0, 0, 833, 840, 3, 136, 68, 0, 834, 835,
		3, 136, 68, 0, 835, 836, 3, 356, 178, 0, 836, 837, 3, 138, 69, 0, 837,
		840, 1, 0, 0, 0, 838, 840, 3, 138, 69, 0, 839, 833, 1, 0, 0, 0, 839, 834,
		1, 0, 0, 0, 839, 838, 1, 0, 0, 0, 840, 41, 1, 0, 0, 0, 841, 842, 3, 380,
		190, 0, 842, 844, 3, 436, 218, 0, 843, 845, 3, 244, 122, 0, 844, 843, 1,
		0, 0, 0, 844, 845, 1, 0, 0, 0, 845, 846, 1, 0, 0, 0, 846, 847, 3, 304,
		152, 0, 847, 848, 3, 530, 265, 0, 848, 849, 3, 480, 240, 0, 849, 850, 5,
		19, 0, 0, 850, 851, 3, 538, 269, 0, 851, 852, 3, 186, 93, 0, 852, 856,
		3, 540, 270, 0, 853, 854, 3, 356, 178, 0, 854, 855, 3, 190, 95, 0, 855,
		857, 1, 0, 0, 0, 856, 853, 1, 0, 0, 0, 856, 857, 1, 0, 0, 0, 857, 43, 1,
		0, 0, 0, 858, 860, 3, 380, 190, 0, 859, 861, 3, 64, 32, 0, 860, 859, 1,
		0, 0, 0, 860, 861, 1, 0, 0, 0, 861, 862, 1, 0, 0, 0, 862, 864, 3, 408,
		204, 0, 863, 865, 3, 244, 122, 0, 864, 863, 1, 0, 0, 0, 864, 865, 1, 0,
		0, 0, 865, 869, 1, 0, 0, 0, 866, 867, 3, 304, 152, 0, 867, 868, 5, 10,
		0, 0, 868, 870, 1, 0, 0, 0, 869, 866, 1, 0, 0, 0, 869, 870, 1, 0, 0, 0,
		870, 871, 1, 0, 0, 0, 871, 872, 3, 330, 165, 0, 872, 874, 3, 534, 267,
		0, 873, 875, 3, 48, 24, 0, 874, 873, 1, 0, 0, 0, 874, 875, 1, 0, 0, 0,
		875, 876, 1, 0, 0, 0, 876, 877, 3, 536, 268, 0, 877, 878, 3, 50, 25, 0,
		878, 879, 3, 482, 241, 0, 879, 880, 3, 310, 155, 0, 880, 881, 3, 440, 220,
		0, 881, 882, 3, 332, 166, 0, 882, 883, 3, 360, 180, 0, 883, 884, 3, 46,
		23, 0, 884, 45, 1, 0, 0, 0, 885, 886, 7, 0, 0, 0, 886, 47, 1, 0, 0, 0,
		887, 893, 3, 340, 170, 0, 888, 889, 3, 550, 275, 0, 889, 890, 3, 340, 170,
		0, 890, 892, 1, 0, 0, 0, 891, 888, 1, 0, 0, 0, 892, 895, 1, 0, 0, 0, 893,
		891, 1, 0, 0, 0, 893, 894, 1, 0, 0, 0, 894, 49, 1, 0, 0, 0, 895, 893, 1,
		0, 0, 0, 896, 901, 3, 372, 186, 0, 897, 898, 3, 482, 241, 0, 898, 899,
		3, 460, 230, 0, 899, 901, 1, 0, 0, 0, 900, 896, 1, 0, 0, 0, 900, 897, 1,
		0, 0, 0, 901, 902, 1, 0, 0, 0, 902, 903, 3, 464, 232, 0, 903, 904, 3, 460,
		230, 0, 904, 905, 3, 422, 211, 0, 905, 51, 1, 0, 0, 0, 906, 908, 3, 380,
		190, 0, 907, 909, 3, 64, 32, 0, 908, 907, 1, 0, 0, 0, 908, 909, 1, 0, 0,
		0, 909, 910, 1, 0, 0, 0, 910, 912, 3, 346, 173, 0, 911, 913, 3, 244, 122,
		0, 912, 911, 1, 0, 0, 0, 912, 913, 1, 0, 0, 0, 913, 917, 1, 0, 0, 0, 914,
		915, 3, 304, 152, 0, 915, 916, 5, 10, 0, 0, 916, 918, 1, 0, 0, 0, 917,
		914, 1, 0, 0, 0, 917, 918, 1, 0, 0, 0, 918, 919, 1, 0, 0, 0, 919, 920,
		3, 328, 164, 0, 920, 921, 3, 534, 267, 0, 921, 922, 3, 310, 155, 0, 922,
		923, 3, 536, 268, 0, 923, 924, 3, 492, 246, 0, 924, 925, 3, 330, 165, 0,
		925, 926, 3, 496, 248, 0, 926, 927, 3, 310, 155, 0, 927, 928, 3, 402, 201,
		0, 928, 929, 3, 330, 165, 0, 929, 930, 3, 420, 210, 0, 930, 931, 3, 54,
		27, 0, 931, 53, 1, 0, 0, 0, 932, 937, 3, 292, 146, 0, 933, 937, 3, 62,
		31, 0, 934, 937, 3, 60, 30, 0, 935, 937, 3, 56, 28, 0, 936, 932, 1, 0,
		0, 0, 936, 933, 1, 0, 0, 0, 936, 934, 1, 0, 0, 0, 936, 935, 1, 0, 0, 0,
		937, 55, 1, 0, 0, 0, 938, 939, 3, 538, 269, 0, 939, 945, 3, 58, 29, 0,
		940, 941, 3, 550, 275, 0, 941, 942, 3, 58, 29, 0, 942, 944, 1, 0, 0, 0,
		943, 940, 1, 0, 0, 0, 944, 947, 1, 0, 0, 0, 945, 943, 1, 0, 0, 0, 945,
		946, 1, 0, 0, 0, 946, 948, 1, 0, 0, 0, 947, 945, 1, 0, 0, 0, 948, 949,
		3, 540, 270, 0, 949, 57, 1, 0, 0, 0, 950, 951, 3, 338, 169, 0, 951, 952,
		5, 9, 0, 0, 952, 953, 3, 54, 27, 0, 953, 59, 1, 0, 0, 0, 954, 955, 3, 534,
		267, 0, 955, 962, 3, 62, 31, 0, 956, 957, 3, 550, 275, 0, 957, 958, 3,
		292, 146, 0, 958, 961, 1, 0, 0, 0, 959, 961, 3, 62, 31, 0, 960, 956, 1,
		0, 0, 0, 960, 959, 1, 0, 0, 0, 961, 964, 1, 0, 0, 0, 962, 960, 1, 0, 0,
		0, 962, 963, 1, 0, 0, 0, 963, 965, 1, 0, 0, 0, 964, 962, 1, 0, 0, 0, 965,
		966, 3, 536, 268, 0, 966, 61, 1, 0, 0, 0, 967, 968, 3, 534, 267, 0, 968,
		974, 3, 292, 146, 0, 969, 970, 3, 550, 275, 0, 970, 971, 3, 292, 146, 0,
		971, 973, 1, 0, 0, 0, 972, 969, 1, 0, 0, 0, 973, 976, 1, 0, 0, 0, 974,
		972, 1, 0, 0, 0, 974, 975, 1, 0, 0, 0, 975, 977, 1, 0, 0, 0, 976, 974,
		1, 0, 0, 0, 977, 978, 3, 536, 268, 0, 978, 63, 1, 0, 0, 0, 979, 980, 3,
		468, 234, 0, 980, 981, 3, 478, 239, 0, 981, 65, 1, 0, 0, 0, 982, 983, 3,
		354, 177, 0, 983, 984, 3, 520, 260, 0, 984, 985, 3, 334, 167, 0, 985, 986,
		3, 530, 265, 0, 986, 988, 3, 68, 34, 0, 987, 989, 3, 70, 35, 0, 988, 987,
		1, 0, 0, 0, 988, 989, 1, 0, 0, 0, 989, 67, 1, 0, 0, 0, 990, 991, 3, 472,
		236, 0, 991, 992, 3, 298, 149, 0, 992, 69, 1, 0, 0, 0, 993, 996, 3, 498,
		249, 0, 994, 996, 3, 454, 227, 0, 995, 993, 1, 0, 0, 0, 995, 994, 1, 0,
		0, 0, 996, 71, 1, 0, 0, 0, 997, 998, 3, 354, 177, 0, 998, 1002, 3, 512,
		256, 0, 999, 1000, 3, 304, 152, 0, 1000, 1001, 5, 10, 0, 0, 1001, 1003,
		1, 0, 0, 0, 1002, 999, 1, 0, 0, 0, 1002, 1003, 1, 0, 0, 0, 1003, 1004,
		1, 0, 0, 0, 1004, 1005, 3, 326, 163, 0, 1005, 1006, 3, 74, 37, 0, 1006,
		73, 1, 0, 0, 0, 1007, 1011, 3, 84, 42, 0, 1008, 1011, 3, 82, 41, 0, 1009,
		1011, 3, 76, 38, 0, 1010, 1007, 1, 0, 0, 0, 1010, 1008, 1, 0, 0, 0, 1010,
		1009, 1, 0, 0, 0, 1011, 75, 1, 0, 0, 0, 1012, 1013, 3, 476, 238, 0, 1013,
		1014, 3, 78, 39, 0, 1014, 77, 1, 0, 0, 0, 1015, 1021, 3, 80, 40, 0, 1016,
		1017, 3, 356, 178, 0, 1017, 1018, 3, 80, 40, 0, 1018, 1020, 1, 0, 0, 0,
		1019, 1016, 1, 0, 0, 0, 1020, 1023, 1, 0, 0, 0, 1021, 1019, 1, 0, 0, 0,
		1021, 1022, 1, 0, 0, 0, 1022, 79, 1, 0, 0, 0, 1023, 1021, 1, 0, 0, 0, 1024,
		1025, 3, 308, 154, 0, 1025, 1026, 3, 504, 252, 0, 1026, 1027, 3, 308, 154,
		0, 1027, 81, 1, 0, 0, 0, 1028, 1029, 3, 344, 172, 0, 1029, 1030, 3, 308,
		154, 0, 1030, 1037, 3, 310, 155, 0, 1031, 1032, 3, 550, 275, 0, 1032, 1033,
		3, 308, 154, 0, 1033, 1034, 3, 310, 155, 0, 1034, 1036, 1, 0, 0, 0, 1035,
		1031, 1, 0, 0, 0, 1036, 1039, 1, 0, 0, 0, 1037, 1035, 1, 0, 0, 0, 1037,
		1038, 1, 0, 0, 0, 1038, 83, 1, 0, 0, 0, 1039, 1037, 1, 0, 0, 0, 1040, 1041,
		3, 354, 177, 0, 1041, 1042, 3, 308, 154, 0, 1042, 1043, 3, 512, 256, 0,
		1043, 1044, 3, 310, 155, 0, 1044, 85, 1, 0, 0, 0, 1045, 1046, 3, 354, 177,
		0, 1046, 1050, 3, 500, 250, 0, 1047, 1048, 3, 304, 152, 0, 1048, 1049,
		5, 10, 0, 0, 1049, 1051, 1, 0, 0, 0, 1050, 1047, 1, 0, 0, 0, 1050, 1051,
		1, 0, 0, 0, 1051, 1052, 1, 0, 0, 0, 1052, 1053, 3, 306, 153, 0, 1053, 1054,
		3, 88, 44, 0, 1054, 87, 1, 0, 0, 0, 1055, 1061, 3, 100, 50, 0, 1056, 1061,
		3, 96, 48, 0, 1057, 1061, 3, 94, 47, 0, 1058, 1061, 3, 92, 46, 0, 1059,
		1061, 3, 90, 45, 0, 1060, 1055, 1, 0, 0, 0, 1060, 1056, 1, 0, 0, 0, 1060,
		1057, 1, 0, 0, 0, 1060, 1058, 1, 0, 0, 0, 1060, 1059, 1, 0, 0, 0, 1061,
		89, 1, 0, 0, 0, 1062, 1063, 3, 530, 265, 0, 1063, 1064, 3, 136, 68, 0,
		1064, 91, 1, 0, 0, 0, 1065, 1066, 3, 476, 238, 0, 1066, 1067, 3, 308, 154,
		0, 1067, 1068, 3, 504, 252, 0, 1068, 1069, 3, 308, 154, 0, 1069, 93, 1,
		0, 0, 0, 1070, 1071, 3, 390, 195, 0, 1071, 1072, 3, 376, 188, 0, 1072,
		1073, 3, 494, 247, 0, 1073, 95, 1, 0, 0, 0, 1074, 1075, 3, 390, 195, 0,
		1075, 1076, 3, 98, 49, 0, 1076, 97, 1, 0, 0, 0, 1077, 1083, 3, 308, 154,
		0, 1078, 1079, 3, 550, 275, 0, 1079, 1080, 3, 308, 154, 0, 1080, 1082,
		1, 0, 0, 0, 1081, 1078, 1, 0, 0, 0, 1082, 1085, 1, 0, 0, 0, 1083, 1081,
		1, 0, 0, 0, 1083, 1084, 1, 0, 0, 0, 1084, 99, 1, 0, 0, 0, 1085, 1083, 1,
		0, 0, 0, 1086, 1087, 3, 344, 172, 0, 1087, 1088, 3, 102, 51, 0, 1088, 101,
		1, 0, 0, 0, 1089, 1090, 3, 308, 154, 0, 1090, 1097, 3, 310, 155, 0, 1091,
		1092, 3, 550, 275, 0, 1092, 1093, 3, 308, 154, 0, 1093, 1094, 3, 310, 155,
		0, 1094, 1096, 1, 0, 0, 0, 1095, 1091, 1, 0, 0, 0, 1096, 1099, 1, 0, 0,
		0, 1097, 1095, 1, 0, 0, 0, 1097, 1098, 1, 0, 0, 0, 1098, 103, 1, 0, 0,
		0, 1099, 1097, 1, 0, 0, 0, 1100, 1101, 3, 354, 177, 0, 1101, 1102, 3, 484,
		242, 0, 1102, 1104, 3, 318, 159, 0, 1103, 1105, 3, 106, 53, 0, 1104, 1103,
		1, 0, 0, 0, 1104, 1105, 1, 0, 0, 0, 1105, 105, 1, 0, 0, 0, 1106, 1107,
		3, 530, 265, 0, 1107, 1113, 3, 108, 54, 0, 1108, 1109, 3, 356, 178, 0,
		1109, 1110, 3, 108, 54, 0, 1110, 1112, 1, 0, 0, 0, 1111, 1108, 1, 0, 0,
		0, 1112, 1115, 1, 0, 0, 0, 1113, 1111, 1, 0, 0, 0, 1113, 1114, 1, 0, 0,
		0, 1114, 107, 1, 0, 0, 0, 1115, 1113, 1, 0, 0, 0, 1116, 1117, 3, 472, 236,
		0, 1117, 1118, 5, 19, 0, 0, 1118, 1119, 3, 298, 149, 0, 1119, 1133, 1,
		0, 0, 0, 1120, 1121, 3, 448, 224, 0, 1121, 1122, 5, 19, 0, 0, 1122, 1123,
		3, 300, 150, 0, 1123, 1133, 1, 0, 0, 0, 1124, 1125, 3, 498, 249, 0, 1125,
		1126, 5, 19, 0, 0, 1126, 1127, 3, 300, 150, 0, 1127, 1133, 1, 0, 0, 0,
		1128, 1129, 3, 466, 233, 0, 1129, 1130, 5, 19, 0, 0, 1130, 1131, 3, 146,
		73, 0, 1131, 1133, 1, 0, 0, 0, 1132, 1116, 1, 0, 0, 0, 1132, 1120, 1, 0,
		0, 0, 1132, 1124, 1, 0, 0, 0, 1132, 1128, 1, 0, 0, 0, 1133, 109, 1, 0,
		0, 0, 1134, 1135, 3, 354, 177, 0, 1135, 1136, 3, 450, 225, 0, 1136, 1140,
		3, 526, 263, 0, 1137, 1138, 3, 304, 152, 0, 1138, 1139, 5, 10, 0, 0, 1139,
		1141, 1, 0, 0, 0, 1140, 1137, 1, 0, 0, 0, 1140, 1141, 1, 0, 0, 0, 1141,
		1142, 1, 0, 0, 0, 1142, 1146, 3, 324, 162, 0, 1143, 1144, 3, 530, 265,
		0, 1144, 1145, 3, 136, 68, 0, 1145, 1147, 1, 0, 0, 0, 1146, 1143, 1, 0,
		0, 0, 1146, 1147, 1, 0, 0, 0, 1147, 111, 1, 0, 0, 0, 1148, 1149, 3, 390,
		195, 0, 1149, 1151, 3, 520, 260, 0, 1150, 1152, 3, 246, 123, 0, 1151, 1150,
		1, 0, 0, 0, 1151, 1152, 1, 0, 0, 0, 1152, 1153, 1, 0, 0, 0, 1153, 1154,
		3, 334, 167, 0, 1154, 113, 1, 0, 0, 0, 1155, 1156, 3, 390, 195, 0, 1156,
		1158, 3, 512, 256, 0, 1157, 1159, 3, 246, 123, 0, 1158, 1157, 1, 0, 0,
		0, 1158, 1159, 1, 0, 0, 0, 1159, 1163, 1, 0, 0, 0, 1160, 1161, 3, 304,
		152, 0, 1161, 1162, 5, 10, 0, 0, 1162, 1164, 1, 0, 0, 0, 1163, 1160, 1,
		0, 0, 0, 1163, 1164, 1, 0, 0, 0, 1164, 1165, 1, 0, 0, 0, 1165, 1166, 3,
		326, 163, 0, 1166, 115, 1, 0, 0, 0, 1167, 1168, 3, 390, 195, 0, 1168, 1169,
		3, 450, 225, 0, 1169, 1171, 3, 526, 263, 0, 1170, 1172, 3, 246, 123, 0,
		1171, 1170, 1, 0, 0, 0, 1171, 1172, 1, 0, 0, 0, 1172, 1176, 1, 0, 0, 0,
		1173, 1174, 3, 304, 152, 0, 1174, 1175, 5, 10, 0, 0, 1175, 1177, 1, 0,
		0, 0, 1176, 1173, 1, 0, 0, 0, 1176, 1177, 1, 0, 0, 0, 1177, 1178, 1, 0,
		0, 0, 1178, 1179, 3, 324, 162, 0, 1179, 117, 1, 0, 0, 0, 1180, 1181, 3,
		390, 195, 0, 1181, 1183, 3, 346, 173, 0, 1182, 1184, 3, 246, 123, 0, 1183,
		1182, 1, 0, 0, 0, 1183, 1184, 1, 0, 0, 0, 1184, 1188, 1, 0, 0, 0, 1185,
		1186, 3, 304, 152, 0, 1186, 1187, 5, 10, 0, 0, 1187, 1189, 1, 0, 0, 0,
		1188, 1185, 1, 0, 0, 0, 1188, 1189, 1, 0, 0, 0, 1189, 1190, 1, 0, 0, 0,
		1190, 1191, 3, 328, 164, 0, 1191, 119, 1, 0, 0, 0, 1192, 1193, 3, 390,
		195, 0, 1193, 1195, 3, 408, 204, 0, 1194, 1196, 3, 246, 123, 0, 1195, 1194,
		1, 0, 0, 0, 1195, 1196, 1, 0, 0, 0, 1196, 1200, 1, 0, 0, 0, 1197, 1198,
		3, 304, 152, 0, 1198, 1199, 5, 10, 0, 0, 1199, 1201, 1, 0, 0, 0, 1200,
		1197, 1, 0, 0, 0, 1200, 1201, 1, 0, 0, 0, 1201, 1202, 1, 0, 0, 0, 1202,
		1203, 3, 330, 165, 0, 1203, 121, 1, 0, 0, 0, 1204, 1205, 3, 390, 195, 0,
		1205, 1207, 3, 506, 253, 0, 1206, 1208, 3, 246, 123, 0, 1207, 1206, 1,
		0, 0, 0, 1207, 1208, 1, 0, 0, 0, 1208, 1209, 1, 0, 0, 0, 1209, 1210, 3,
		320, 160, 0, 1210, 1214, 3, 464, 232, 0, 1211, 1212, 3, 304, 152, 0, 1212,
		1213, 5, 10, 0, 0, 1213, 1215, 1, 0, 0, 0, 1214, 1211, 1, 0, 0, 0, 1214,
		1215, 1, 0, 0, 0, 1215, 1216, 1, 0, 0, 0, 1216, 1217, 3, 306, 153, 0, 1217,
		123, 1, 0, 0, 0, 1218, 1219, 3, 390, 195, 0, 1219, 1221, 3, 484, 242, 0,
		1220, 1222, 3, 246, 123, 0, 1221, 1220, 1, 0, 0, 0, 1221, 1222, 1, 0, 0,
		0, 1222, 1223, 1, 0, 0, 0, 1223, 1224, 3, 318, 159, 0, 1224, 125, 1, 0,
		0, 0, 1225, 1226, 3, 390, 195, 0, 1226, 1228, 3, 500, 250, 0, 1227, 1229,
		3, 246, 123, 0, 1228, 1227, 1, 0, 0, 0, 1228, 1229, 1, 0, 0, 0, 1229, 1233,
		1, 0, 0, 0, 1230, 1231, 3, 304, 152, 0, 1231, 1232, 5, 10, 0, 0, 1232,
		1234, 1, 0, 0, 0, 1233, 1230, 1, 0, 0, 0, 1233, 1234, 1, 0, 0, 0, 1234,
		1235, 1, 0, 0, 0, 1235, 1236, 3, 306, 153, 0, 1236, 127, 1, 0, 0, 0, 1237,
		1238, 3, 390, 195, 0, 1238, 1240, 3, 436, 218, 0, 1239, 1241, 3, 246, 123,
		0, 1240, 1239, 1, 0, 0, 0, 1240, 1241, 1, 0, 0, 0, 1241, 1242, 1, 0, 0,
		0, 1242, 1243, 3, 304, 152, 0, 1243, 129, 1, 0, 0, 0, 1244, 1245, 3, 390,
		195, 0, 1245, 1247, 3, 418, 209, 0, 1246, 1248, 3, 246, 123, 0, 1247, 1246,
		1, 0, 0, 0, 1247, 1248, 1, 0, 0, 0, 1248, 1252, 1, 0, 0, 0, 1249, 1250,
		3, 304, 152, 0, 1250, 1251, 5, 10, 0, 0, 1251, 1253, 1, 0, 0, 0, 1252,
		1249, 1, 0, 0, 0, 1252, 1253, 1, 0, 0, 0, 1253, 1254, 1, 0, 0, 0, 1254,
		1255, 3, 198, 99, 0, 1255, 131, 1, 0, 0, 0, 1256, 1257, 3, 380, 190, 0,
		1257, 1259, 3, 500, 250, 0, 1258, 1260, 3, 244, 122, 0, 1259, 1258, 1,
		0, 0, 0, 1259, 1260, 1, 0, 0, 0, 1260, 1264, 1, 0, 0, 0, 1261, 1262, 3,
		304, 152, 0, 1262, 1263, 5, 10, 0, 0, 1263, 1265, 1, 0, 0, 0, 1264, 1261,
		1, 0, 0, 0, 1264, 1265, 1, 0, 0, 0, 1265, 1266, 1, 0, 0, 0, 1266, 1267,
		3, 306, 153, 0, 1267, 1268, 3, 534, 267, 0, 1268, 1269, 3, 154, 77, 0,
		1269, 1271, 3, 536, 268, 0, 1270, 1272, 3, 134, 67, 0, 1271, 1270, 1, 0,
		0, 0, 1271, 1272, 1, 0, 0, 0, 1272, 133, 1, 0, 0, 0, 1273, 1274, 3, 530,
		265, 0, 1274, 1275, 3, 136, 68, 0, 1275, 135, 1, 0, 0, 0, 1276, 1277, 3,
		376, 188, 0, 1277, 1281, 3, 494, 247, 0, 1278, 1279, 3, 356, 178, 0, 1279,
		1280, 3, 136, 68, 0, 1280, 1282, 1, 0, 0, 0, 1281, 1278, 1, 0, 0, 0, 1281,
		1282, 1, 0, 0, 0, 1282, 1300, 1, 0, 0, 0, 1283, 1287, 3, 138, 69, 0, 1284,
		1285, 3, 356, 178, 0, 1285, 1286, 3, 136, 68, 0, 1286, 1288, 1, 0, 0, 0,
		1287, 1284, 1, 0, 0, 0, 1287, 1288, 1, 0, 0, 0, 1288, 1300, 1, 0, 0, 0,
		1289, 1295, 3, 140, 70, 0, 1290, 1291, 3, 356, 178, 0, 1291, 1292, 3, 140,
		70, 0, 1292, 1294, 1, 0, 0, 0, 1293, 1290, 1, 0, 0, 0, 1294, 1297, 1, 0,
		0, 0, 1295, 1293, 1, 0, 0, 0, 1295, 1296, 1, 0, 0, 0, 1296, 1300, 1, 0,
		0, 0, 1297, 1295, 1, 0, 0, 0, 1298, 1300, 3, 510, 255, 0, 1299, 1276, 1,
		0, 0, 0, 1299, 1283, 1, 0, 0, 0, 1299, 1289, 1, 0, 0, 0, 1299, 1298, 1,
		0, 0, 0, 1300, 137, 1, 0, 0, 0, 1301, 1302, 3, 374, 187, 0, 1302, 1303,
		3, 470, 235, 0, 1303, 1304, 3, 370, 185, 0, 1304, 1305, 3, 534, 267, 0,
		1305, 1307, 3, 308, 154, 0, 1306, 1308, 3, 316, 158, 0, 1307, 1306, 1,
		0, 0, 0, 1307, 1308, 1, 0, 0, 0, 1308, 1316, 1, 0, 0, 0, 1309, 1310, 3,
		550, 275, 0, 1310, 1312, 3, 308, 154, 0, 1311, 1313, 3, 316, 158, 0, 1312,
		1311, 1, 0, 0, 0, 1312, 1313, 1, 0, 0, 0, 1313, 1315, 1, 0, 0, 0, 1314,
		1309, 1, 0, 0, 0, 1315, 1318, 1, 0, 0, 0, 1316, 1314, 1, 0, 0, 0, 1316,
		1317, 1, 0, 0, 0, 1317, 1319, 1, 0, 0, 0, 1318, 1316, 1, 0, 0, 0, 1319,
		1320, 3, 536, 268, 0, 1320, 139, 1, 0, 0, 0, 1321, 1322, 3, 142, 71, 0,
		1322, 1323, 5, 19, 0, 0, 1323, 1324, 3, 144, 72, 0, 1324, 1330, 1, 0, 0,
		0, 1325, 1326, 3, 142, 71, 0, 1326, 1327, 5, 19, 0, 0, 1327, 1328, 3, 146,
		73, 0, 1328, 1330, 1, 0, 0, 0, 1329, 1321, 1, 0, 0, 0, 1329, 1325, 1, 0,
		0, 0, 1330, 141, 1, 0, 0, 0, 1331, 1332, 5, 170, 0, 0, 1332, 143, 1, 0,
		0, 0, 1333, 1336, 3, 298, 149, 0, 1334, 1336, 3, 296, 148, 0, 1335, 1333,
		1, 0, 0, 0, 1335, 1334, 1, 0, 0, 0, 1336, 145, 1, 0, 0, 0, 1337, 1338,
		3, 538, 269, 0, 1338, 1344, 3, 148, 74, 0, 1339, 1340, 3, 550, 275, 0,
		1340, 1341, 3, 148, 74, 0, 1341, 1343, 1, 0, 0, 0, 1342, 1339, 1, 0, 0,
		0, 1343, 1346, 1, 0, 0, 0, 1344, 1342, 1, 0, 0, 0, 1344, 1345, 1, 0, 0,
		0, 1345, 1347, 1, 0, 0, 0, 1346, 1344, 1, 0, 0, 0, 1347, 1348, 3, 540,
		270, 0, 1348, 147, 1, 0, 0, 0, 1349, 1350, 3, 150, 75, 0, 1350, 1351, 5,
		9, 0, 0, 1351, 1352, 3, 152, 76, 0, 1352, 149, 1, 0, 0, 0, 1353, 1354,
		3, 298, 149, 0, 1354, 151, 1, 0, 0, 0, 1355, 1358, 3, 298, 149, 0, 1356,
		1358, 3, 296, 148, 0, 1357, 1355, 1, 0, 0, 0, 1357, 1356, 1, 0, 0, 0, 1358,
		153, 1, 0, 0, 0, 1359, 1365, 3, 156, 78, 0, 1360, 1361, 3, 550, 275, 0,
		1361, 1362, 3, 156, 78, 0, 1362, 1364, 1, 0, 0, 0, 1363, 1360, 1, 0, 0,
		0, 1364, 1367, 1, 0, 0, 0, 1365, 1363, 1, 0, 0, 0, 1365, 1366, 1, 0, 0,
		0, 1366, 1371, 1, 0, 0, 0, 1367, 1365, 1, 0, 0, 0, 1368, 1369, 3, 550,
		275, 0, 1369, 1370, 3, 160, 80, 0, 1370, 1372, 1, 0, 0, 0, 1371, 1368,
		1, 0, 0, 0, 1371, 1372, 1, 0, 0, 0, 1372, 155, 1, 0, 0, 0, 1373, 1374,
		3, 308, 154, 0, 1374, 1376, 3, 310, 155, 0, 1375, 1377, 3, 158, 79, 0,
		1376, 1375, 1, 0, 0, 0, 1376, 1377, 1, 0, 0, 0, 1377, 157, 1, 0, 0, 0,
		1378, 1379, 3, 474, 237, 0, 1379, 1380, 3, 432, 216, 0, 1380, 159, 1, 0,
		0, 0, 1381, 1382, 3, 474, 237, 0, 1382, 1383, 3, 432, 216, 0, 1383, 1384,
		3, 534, 267, 0, 1384, 1385, 3, 162, 81, 0, 1385, 1386, 3, 536, 268, 0,
		1386, 161, 1, 0, 0, 0, 1387, 1391, 3, 164, 82, 0, 1388, 1391, 3, 166, 83,
		0, 1389, 1391, 3, 168, 84, 0, 1390, 1387, 1, 0, 0, 0, 1390, 1388, 1, 0,
		0, 0, 1390, 1389, 1, 0, 0, 0, 1391, 163, 1, 0, 0, 0, 1392, 1393, 3, 308,
		154, 0, 1393, 165, 1, 0, 0, 0, 1394, 1395, 3, 174, 87, 0, 1395, 1396, 3,
		550, 275, 0, 1396, 1397, 3, 172, 86, 0, 1397, 167, 1, 0, 0, 0, 1398, 1399,
		3, 534, 267, 0, 1399, 1400, 3, 170, 85, 0, 1400, 1401, 3, 536, 268, 0,
		1401, 1402, 3, 550, 275, 0, 1402, 1403, 3, 172, 86, 0, 1403, 169, 1, 0,
		0, 0, 1404, 1410, 3, 174, 87, 0, 1405, 1406, 3, 550, 275, 0, 1406, 1407,
		3, 174, 87, 0, 1407, 1409, 1, 0, 0, 0, 1408, 1405, 1, 0, 0, 0, 1409, 1412,
		1, 0, 0, 0, 1410, 1408, 1, 0, 0, 0, 1410, 1411, 1, 0, 0, 0, 1411, 171,
		1, 0, 0, 0, 1412, 1410, 1, 0, 0, 0, 1413, 1419, 3, 176, 88, 0, 1414, 1415,
		3, 550, 275, 0, 1415, 1416, 3, 176, 88, 0, 1416, 1418, 1, 0, 0, 0, 1417,
		1414, 1, 0, 0, 0, 1418, 1421, 1, 0, 0, 0, 1419, 1417, 1, 0, 0, 0, 1419,
		1420, 1, 0, 0, 0, 1420, 173, 1, 0, 0, 0, 1421, 1419, 1, 0, 0, 0, 1422,
		1423, 3, 308, 154, 0, 1423, 175, 1, 0, 0, 0, 1424, 1425, 3, 308, 154, 0,
		1425, 177, 1, 0, 0, 0, 1426, 1427, 3, 358, 179, 0, 1427, 1428, 3, 366,
		183, 0, 1428, 179, 1, 0, 0, 0, 1429, 1431, 3, 368, 184, 0, 1430, 1432,
		3, 182, 91, 0, 1431, 1430, 1, 0, 0, 0, 1431, 1432, 1, 0, 0, 0, 1432, 1433,
		1, 0, 0, 0, 1433, 1435, 3, 366, 183, 0, 1434, 1436, 3, 242, 121, 0, 1435,
		1434, 1, 0, 0, 0, 1435, 1436, 1, 0, 0, 0, 1436, 181, 1, 0, 0, 0, 1437,
		1440, 3, 446, 223, 0, 1438, 1440, 3, 514, 257, 0, 1439, 1437, 1, 0, 0,
		0, 1439, 1438, 1, 0, 0, 0, 1440, 183, 1, 0, 0, 0, 1441, 1442, 3, 354, 177,
		0, 1442, 1443, 3, 436, 218, 0, 1443, 1444, 3, 304, 152, 0, 1444, 1445,
		3, 530, 265, 0, 1445, 1446, 3, 480, 240, 0, 1446, 1447, 5, 19, 0, 0, 1447,
		1448, 3, 538, 269, 0, 1448, 1449, 3, 186, 93, 0, 1449, 1453, 3, 540, 270,
		0, 1450, 1451, 3, 356, 178, 0, 1451, 1452, 3, 190, 95, 0, 1452, 1454, 1,
		0, 0, 0, 1453, 1450, 1, 0, 0, 0, 1453, 1454, 1, 0, 0, 0, 1454, 185, 1,
		0, 0, 0, 1455, 1461, 3, 188, 94, 0, 1456, 1457, 3, 550, 275, 0, 1457, 1458,
		3, 188, 94, 0, 1458, 1460, 1, 0, 0, 0, 1459, 1456, 1, 0, 0, 0, 1460, 1463,
		1, 0, 0, 0, 1461, 1459, 1, 0, 0, 0, 1461, 1462, 1, 0, 0, 0, 1462, 187,
		1, 0, 0, 0, 1463, 1461, 1, 0, 0, 0, 1464, 1465, 5, 165, 0, 0, 1465, 1466,
		5, 9, 0, 0, 1466, 1471, 5, 165, 0, 0, 1467, 1468, 5, 165, 0, 0, 1468, 1469,
		5, 9, 0, 0, 1469, 1471, 5, 166, 0, 0, 1470, 1464, 1, 0, 0, 0, 1470, 1467,
		1, 0, 0, 0, 1471, 189, 1, 0, 0, 0, 1472, 1473, 3, 392, 196, 0, 1473, 1474,
		5, 19, 0, 0, 1474, 1475, 3, 300, 150, 0, 1475, 191, 1, 0, 0, 0, 1476, 1477,
		3, 518, 259, 0, 1477, 1478, 3, 304, 152, 0, 1478, 193, 1, 0, 0, 0, 1479,
		1481, 3, 508, 254, 0, 1480, 1482, 3, 500, 250, 0, 1481, 1480, 1, 0, 0,
		0, 1481, 1482, 1, 0, 0, 0, 1482, 1486, 1, 0, 0, 0, 1483, 1484, 3, 304,
		152, 0, 1484, 1485, 5, 10, 0, 0, 1485, 1487, 1, 0, 0, 0, 1486, 1483, 1,
		0, 0, 0, 1486, 1487, 1, 0, 0, 0, 1487, 1488, 1, 0, 0, 0, 1488, 1489, 3,
		306, 153, 0, 1489, 195, 1, 0, 0, 0, 1490, 1491, 3, 380, 190, 0, 1491, 1493,
		3, 418, 209, 0, 1492, 1494, 3, 244, 122, 0, 1493, 1492, 1, 0, 0, 0, 1493,
		1494, 1, 0, 0, 0, 1494, 1496, 1, 0, 0, 0, 1495, 1497, 3, 198, 99, 0, 1496,
		1495, 1, 0, 0, 0, 1496, 1497, 1, 0, 0, 0, 1497, 1498, 1, 0, 0, 0, 1498,
		1502, 3, 464, 232, 0, 1499, 1500, 3, 304, 152, 0, 1500, 1501, 5, 10, 0,
		0, 1501, 1503, 1, 0, 0, 0, 1502, 1499, 1, 0, 0, 0, 1502, 1503, 1, 0, 0,
		0, 1503, 1504, 1, 0, 0, 0, 1504, 1505, 3, 306, 153, 0, 1505, 1506, 3, 534,
		267, 0, 1506, 1507, 3, 200, 100, 0, 1507, 1508, 3, 536, 268, 0, 1508, 197,
		1, 0, 0, 0, 1509, 1512, 5, 170, 0, 0, 1510, 1512, 3, 298, 149, 0, 1511,
		1509, 1, 0, 0, 0, 1511, 1510, 1, 0, 0, 0, 1512, 199, 1, 0, 0, 0, 1513,
		1518, 3, 308, 154, 0, 1514, 1518, 3, 202, 101, 0, 1515, 1518, 3, 204, 102,
		0, 1516, 1518, 3, 206, 103, 0, 1517, 1513, 1, 0, 0, 0, 1517, 1514, 1, 0,
		0, 0, 1517, 1515, 1, 0, 0, 0, 1517, 1516, 1, 0, 0, 0, 1518, 201, 1, 0,
		0, 0, 1519, 1520, 3, 434, 217, 0, 1520, 1521, 3, 534, 267, 0, 1521, 1522,
		5, 170, 0, 0, 1522, 1523, 3, 536, 268, 0, 1523, 203, 1, 0, 0, 0, 1524,
		1525, 3, 394, 197, 0, 1525, 1526, 3, 534, 267, 0, 1526, 1527, 5, 170, 0,
		0, 1527, 1528, 3, 536, 268, 0, 1528, 205, 1, 0, 0, 0, 1529, 1530, 3, 406,
		203, 0, 1530, 1531, 3, 534, 267, 0, 1531, 1532, 5, 170, 0, 0, 1532, 1533,
		3, 536, 268, 0, 1533, 207, 1, 0, 0, 0, 1534, 1536, 3, 180, 90, 0, 1535,
		1534, 1, 0, 0, 0, 1535, 1536, 1, 0, 0, 0, 1536, 1537, 1, 0, 0, 0, 1537,
		1539, 3, 382, 191, 0, 1538, 1540, 3, 210, 105, 0, 1539, 1538, 1, 0, 0,
		0, 1539, 1540, 1, 0, 0, 0, 1540, 1541, 1, 0, 0, 0, 1541, 1543, 3, 264,
		132, 0, 1542, 1544, 3, 242, 121, 0, 1543, 1542, 1, 0, 0, 0, 1543, 1544,
		1, 0, 0, 0, 1544, 1545, 1, 0, 0, 0, 1545, 1548, 3, 272, 136, 0, 1546, 1549,
		3, 246, 123, 0, 1547, 1549, 3, 216, 108, 0, 1548, 1546, 1, 0, 0, 0, 1548,
		1547, 1, 0, 0, 0, 1548, 1549, 1, 0, 0, 0, 1549, 209, 1, 0, 0, 0, 1550,
		1556, 3, 212, 106, 0, 1551, 1552, 3, 550, 275, 0, 1552, 1553, 3, 212, 106,
		0, 1553, 1555, 1, 0, 0, 0, 1554, 1551, 1, 0, 0, 0, 1555, 1558, 1, 0, 0,
		0, 1556, 1554, 1, 0, 0, 0, 1556, 1557, 1, 0, 0, 0, 1557, 211, 1, 0, 0,
		0, 1558, 1556, 1, 0, 0, 0, 1559, 1569, 5, 170, 0, 0, 1560, 1561, 5, 170,
		0, 0, 1561, 1564, 5, 5, 0, 0, 1562, 1565, 3, 298, 149, 0, 1563, 1565, 3,
		294, 147, 0, 1564, 1562, 1, 0, 0, 0, 1564, 1563, 1, 0, 0, 0, 1565, 1566,
		1, 0, 0, 0, 1566, 1567, 5, 6, 0, 0, 1567, 1569, 1, 0, 0, 0, 1568, 1559,
		1, 0, 0, 0, 1568, 1560, 1, 0, 0, 0, 1569, 213, 1, 0, 0, 0, 1570, 1572,
		3, 180, 90, 0, 1571, 1570, 1, 0, 0, 0, 1571, 1572, 1, 0, 0, 0, 1572, 1573,
		1, 0, 0, 0, 1573, 1577, 3, 516, 258, 0, 1574, 1575, 3, 304, 152, 0, 1575,
		1576, 5, 10, 0, 0, 1576, 1578, 1, 0, 0, 0, 1577, 1574, 1, 0, 0, 0, 1577,
		1578, 1, 0, 0, 0, 1578, 1579, 1, 0, 0, 0, 1579, 1581, 3, 306, 153, 0, 1580,
		1582, 3, 236, 118, 0, 1581, 1580, 1, 0, 0, 0, 1581, 1582, 1, 0, 0, 0, 1582,
		1583, 1, 0, 0, 0, 1583, 1584, 3, 490, 245, 0, 1584, 1585, 3, 222, 111,
		0, 1585, 1588, 3, 272, 136, 0, 1586, 1589, 3, 246, 123, 0, 1587, 1589,
		3, 216, 108, 0, 1588, 1586, 1, 0, 0, 0, 1588, 1587, 1, 0, 0, 0, 1588, 1589,
		1, 0, 0, 0, 1589, 215, 1, 0, 0, 0, 1590, 1591, 3, 414, 207, 0, 1591, 1592,
		3, 218, 109, 0, 1592, 217, 1, 0, 0, 0, 1593, 1599, 3, 220, 110, 0, 1594,
		1595, 3, 356, 178, 0, 1595, 1596, 3, 220, 110, 0, 1596, 1598, 1, 0, 0,
		0, 1597, 1594, 1, 0, 0, 0, 1598, 1601, 1, 0, 0, 0, 1599, 1597, 1, 0, 0,
		0, 1599, 1600, 1, 0, 0, 0, 1600, 219, 1, 0, 0, 0, 1601, 1599, 1, 0, 0,
		0, 1602, 1603, 5, 170, 0, 0, 1603, 1604, 5, 19, 0, 0, 1604, 1605, 3, 292,
		146, 0, 1605, 221, 1, 0, 0, 0, 1606, 1612, 3, 224, 112, 0, 1607, 1608,
		3, 550, 275, 0, 1608, 1609, 3, 224, 112, 0, 1609, 1611, 1, 0, 0, 0, 1610,
		1607, 1, 0, 0, 0, 1611, 1614, 1, 0, 0, 0, 1612, 1610, 1, 0, 0, 0, 1612,
		1613, 1, 0, 0, 0, 1613, 223, 1, 0, 0, 0, 1614, 1612, 1, 0, 0, 0, 1615,
		1616, 5, 170, 0, 0, 1616, 1621, 5, 19, 0, 0, 1617, 1622, 3, 292, 146, 0,
		1618, 1622, 3, 228, 114, 0, 1619, 1622, 3, 226, 113, 0, 1620, 1622, 3,
		230, 115, 0, 1621, 1617, 1, 0, 0, 0, 1621, 1618, 1, 0, 0, 0, 1621, 1619,
		1, 0, 0, 0, 1621, 1620, 1, 0, 0, 0, 1622, 1669, 1, 0, 0, 0, 1623, 1624,
		5, 170, 0, 0, 1624, 1625, 5, 19, 0, 0, 1625, 1626, 5, 170, 0, 0, 1626,
		1627, 7, 1, 0, 0, 1627, 1669, 3, 294, 147, 0, 1628, 1629, 5, 170, 0, 0,
		1629, 1630, 5, 19, 0, 0, 1630, 1631, 5, 170, 0, 0, 1631, 1632, 7, 1, 0,
		0, 1632, 1669, 3, 226, 113, 0, 1633, 1634, 5, 170, 0, 0, 1634, 1635, 5,
		19, 0, 0, 1635, 1636, 3, 226, 113, 0, 1636, 1637, 7, 1, 0, 0, 1637, 1638,
		5, 170, 0, 0, 1638, 1669, 1, 0, 0, 0, 1639, 1640, 5, 170, 0, 0, 1640, 1641,
		5, 19, 0, 0, 1641, 1642, 5, 170, 0, 0, 1642, 1643, 7, 1, 0, 0, 1643, 1669,
		3, 228, 114, 0, 1644, 1645, 5, 170, 0, 0, 1645, 1646, 5, 19, 0, 0, 1646,
		1647, 3, 228, 114, 0, 1647, 1648, 7, 1, 0, 0, 1648, 1649, 5, 170, 0, 0,
		1649, 1669, 1, 0, 0, 0, 1650, 1651, 5, 170, 0, 0, 1651, 1652, 5, 19, 0,
		0, 1652, 1653, 5, 170, 0, 0, 1653, 1654, 7, 1, 0, 0, 1654, 1669, 3, 230,
		115, 0, 1655, 1656, 5, 170, 0, 0, 1656, 1657, 5, 19, 0, 0, 1657, 1658,
		3, 230, 115, 0, 1658, 1659, 7, 1, 0, 0, 1659, 1660, 5, 170, 0, 0, 1660,
		1669, 1, 0, 0, 0, 1661, 1662, 5, 170, 0, 0, 1662, 1663, 3, 546, 273, 0,
		1663, 1664, 3, 294, 147, 0, 1664, 1665, 3, 548, 274, 0, 1665, 1666, 5,
		19, 0, 0, 1666, 1667, 3, 292, 146, 0, 1667, 1669, 1, 0, 0, 0, 1668, 1615,
		1, 0, 0, 0, 1668, 1623, 1, 0, 0, 0, 1668, 1628, 1, 0, 0, 0, 1668, 1633,
		1, 0, 0, 0, 1668, 1639, 1, 0, 0, 0, 1668, 1644, 1, 0, 0, 0, 1668, 1650,
		1, 0, 0, 0, 1668, 1655, 1, 0, 0, 0, 1668, 1661, 1, 0, 0, 0, 1669, 225,
		1, 0, 0, 0, 1670, 1680, 3, 538, 269, 0, 1671, 1677, 3, 292, 146, 0, 1672,
		1673, 3, 550, 275, 0, 1673, 1674, 3, 292, 146, 0, 1674, 1676, 1, 0, 0,
		0, 1675, 1672, 1, 0, 0, 0, 1676, 1679, 1, 0, 0, 0, 1677, 1675, 1, 0, 0,
		0, 1677, 1678, 1, 0, 0, 0, 1678, 1681, 1, 0, 0, 0, 1679, 1677, 1, 0, 0,
		0, 1680, 1671, 1, 0, 0, 0, 1680, 1681, 1, 0, 0, 0, 1681, 1682, 1, 0, 0,
		0, 1682, 1683, 3, 540, 270, 0, 1683, 227, 1, 0, 0, 0, 1684, 1685, 3, 538,
		269, 0, 1685, 1686, 3, 292, 146, 0, 1686, 1687, 3, 552, 276, 0, 1687, 1688,
		3, 292, 146, 0, 1688, 1696, 1, 0, 0, 0, 1689, 1690, 3, 550, 275, 0, 1690,
		1691, 3, 292, 146, 0, 1691, 1692, 3, 552, 276, 0, 1692, 1693, 3, 292, 146,
		0, 1693, 1695, 1, 0, 0, 0, 1694, 1689, 1, 0, 0, 0, 1695, 1698, 1, 0, 0,
		0, 1696, 1694, 1, 0, 0, 0, 1696, 1697, 1, 0, 0, 0, 1697, 1699, 1, 0, 0,
		0, 1698, 1696, 1, 0, 0, 0, 1699, 1700, 3, 540, 270, 0, 1700, 229, 1, 0,
		0, 0, 1701, 1702, 3, 546, 273, 0, 1702, 1708, 3, 292, 146, 0, 1703, 1704,
		3, 550, 275, 0, 1704, 1705, 3, 292, 146, 0, 1705, 1707, 1, 0, 0, 0, 1706,
		1703, 1, 0, 0, 0, 1707, 1710, 1, 0, 0, 0, 1708, 1706, 1, 0, 0, 0, 1708,
		1709, 1, 0, 0, 0, 1709, 1711, 1, 0, 0, 0, 1710, 1708, 1, 0, 0, 0, 1711,
		1712, 3, 548, 274, 0, 1712, 231, 1, 0, 0, 0, 1713, 1714, 3, 534, 267, 0,
		1714, 1720, 3, 256, 128, 0, 1715, 1716, 3, 550, 275, 0, 1716, 1717, 3,
		256, 128, 0, 1717, 1719, 1, 0, 0, 0, 1718, 1715, 1, 0, 0, 0, 1719, 1722,
		1, 0, 0, 0, 1720, 1718, 1, 0, 0, 0, 1720, 1721, 1, 0, 0, 0, 1721, 1723,
		1, 0, 0, 0, 1722, 1720, 1, 0, 0, 0, 1723, 1724, 3, 536, 268, 0, 1724, 233,
		1, 0, 0, 0, 1725, 1727, 3, 180, 90, 0, 1726, 1725, 1, 0, 0, 0, 1726, 1727,
		1, 0, 0, 0, 1727, 1728, 1, 0, 0, 0, 1728, 1729, 3, 424, 212, 0, 1729, 1733,
		3, 426, 213, 0, 1730, 1731, 3, 304, 152, 0, 1731, 1732, 5, 10, 0, 0, 1732,
		1734, 1, 0, 0, 0, 1733, 1730, 1, 0, 0, 0, 1733, 1734, 1, 0, 0, 0, 1734,
		1735, 1, 0, 0, 0, 1735, 1737, 3, 306, 153, 0, 1736, 1738, 3, 250, 125,
		0, 1737, 1736, 1, 0, 0, 0, 1737, 1738, 1, 0, 0, 0, 1738, 1739, 1, 0, 0,
		0, 1739, 1741, 3, 248, 124, 0, 1740, 1742, 3, 244, 122, 0, 1741, 1740,
		1, 0, 0, 0, 1741, 1742, 1, 0, 0, 0, 1742, 1744, 1, 0, 0, 0, 1743, 1745,
		3, 236, 118, 0, 1744, 1743, 1, 0, 0, 0, 1744, 1745, 1, 0, 0, 0, 1745, 235,
		1, 0, 0, 0, 1746, 1747, 3, 522, 261, 0, 1747, 1748, 3, 240, 120, 0, 1748,
		1763, 1, 0, 0, 0, 1749, 1750, 3, 522, 261, 0, 1750, 1751, 3, 240, 120,
		0, 1751, 1752, 3, 356, 178, 0, 1752, 1753, 3, 238, 119, 0, 1753, 1763,
		1, 0, 0, 0, 1754, 1755, 3, 522, 261, 0, 1755, 1756, 3, 238, 119, 0, 1756,
		1763, 1, 0, 0, 0, 1757, 1758, 3, 522, 261, 0, 1758, 1759, 3, 238, 119,
		0, 1759, 1760, 3, 356, 178, 0, 1760, 1761, 3, 240, 120, 0, 1761, 1763,
		1, 0, 0, 0, 1762, 1746, 1, 0, 0, 0, 1762, 1749, 1, 0, 0, 0, 1762, 1754,
		1, 0, 0, 0, 1762, 1757, 1, 0, 0, 0, 1763, 237, 1, 0, 0, 0, 1764, 1765,
		3, 502, 251, 0, 1765, 1766, 3, 294, 147, 0, 1766, 239, 1, 0, 0, 0, 1767,
		1768, 3, 510, 255, 0, 1768, 1769, 3, 294, 147, 0, 1769, 241, 1, 0, 0, 0,
		1770, 1771, 3, 522, 261, 0, 1771, 1772, 3, 238, 119, 0, 1772, 243, 1, 0,
		0, 0, 1773, 1774, 3, 414, 207, 0, 1774, 1775, 3, 458, 229, 0, 1775, 1776,
		3, 398, 199, 0, 1776, 245, 1, 0, 0, 0, 1777, 1778, 3, 414, 207, 0, 1778,
		1779, 3, 398, 199, 0, 1779, 247, 1, 0, 0, 0, 1780, 1781, 3, 524, 262, 0,
		1781, 1782, 5, 1, 0, 0, 1782, 1783, 3, 254, 127, 0, 1783, 1784, 5, 2, 0,
		0, 1784, 1789, 1, 0, 0, 0, 1785, 1786, 3, 430, 215, 0, 1786, 1787, 3, 292,
		146, 0, 1787, 1789, 1, 0, 0, 0, 1788, 1780, 1, 0, 0, 0, 1788, 1785, 1,
		0, 0, 0, 1789, 249, 1, 0, 0, 0, 1790, 1791, 5, 1, 0, 0, 1791, 1792, 3,
		252, 126, 0, 1792, 1793, 5, 2, 0, 0, 1793, 251, 1, 0, 0, 0, 1794, 1800,
		3, 308, 154, 0, 1795, 1796, 3, 550, 275, 0, 1796, 1797, 3, 308, 154, 0,
		1797, 1799, 1, 0, 0, 0, 1798, 1795, 1, 0, 0, 0, 1799, 1802, 1, 0, 0, 0,
		1800, 1798, 1, 0, 0, 0, 1800, 1801, 1, 0, 0, 0, 1801, 253, 1, 0, 0, 0,
		1802, 1800, 1, 0, 0, 0, 1803, 1809, 3, 256, 128, 0, 1804, 1805, 3, 550,
		275, 0, 1805, 1806, 3, 256, 128, 0, 1806, 1808, 1, 0, 0, 0, 1807, 1804,
		1, 0, 0, 0, 1808, 1811, 1, 0, 0, 0, 1809, 1807, 1, 0, 0, 0, 1809, 1810,
		1, 0, 0, 0, 1810, 255, 1, 0, 0, 0, 1811, 1809, 1, 0, 0, 0, 1812, 1819,
		3, 292, 146, 0, 1813, 1819, 3, 288, 144, 0, 1814, 1819, 3, 228, 114, 0,
		1815, 1819, 3, 226, 113, 0, 1816, 1819, 3, 230, 115, 0, 1817, 1819, 3,
		232, 116, 0, 1818, 1812, 1, 0, 0, 0, 1818, 1813, 1, 0, 0, 0, 1818, 1814,
		1, 0, 0, 0, 1818, 1815, 1, 0, 0, 0, 1818, 1816, 1, 0, 0, 0, 1818, 1817,
		1, 0, 0, 0, 1819, 257, 1, 0, 0, 0, 1820, 1822, 3, 488, 244, 0, 1821, 1823,
		3, 274, 137, 0, 1822, 1821, 1, 0, 0, 0, 1822, 1823, 1, 0, 0, 0, 1823, 1825,
		1, 0, 0, 0, 1824, 1826, 3, 430, 215, 0, 1825, 1824, 1, 0, 0, 0, 1825, 1826,
		1, 0, 0, 0, 1826, 1827, 1, 0, 0, 0, 1827, 1828, 3, 276, 138, 0, 1828, 1830,
		3, 264, 132, 0, 1829, 1831, 3, 272, 136, 0, 1830, 1829, 1, 0, 0, 0, 1830,
		1831, 1, 0, 0, 0, 1831, 1833, 1, 0, 0, 0, 1832, 1834, 3, 268, 134, 0, 1833,
		1832, 1, 0, 0, 0, 1833, 1834, 1, 0, 0, 0, 1834, 1836, 1, 0, 0, 0, 1835,
		1837, 3, 262, 131, 0, 1836, 1835, 1, 0, 0, 0, 1836, 1837, 1, 0, 0, 0, 1837,
		1839, 1, 0, 0, 0, 1838, 1840, 3, 260, 130, 0, 1839, 1838, 1, 0, 0, 0, 1839,
		1840, 1, 0, 0, 0, 1840, 259, 1, 0, 0, 0, 1841, 1842, 3, 352, 176, 0, 1842,
		1843, 3, 400, 200, 0, 1843, 261, 1, 0, 0, 0, 1844, 1845, 3, 442, 221, 0,
		1845, 1846, 3, 294, 147, 0, 1846, 263, 1, 0, 0, 0, 1847, 1848, 3, 404,
		202, 0, 1848, 1849, 3, 266, 133, 0, 1849, 265, 1, 0, 0, 0, 1850, 1855,
		5, 170, 0, 0, 1851, 1852, 5, 170, 0, 0, 1852, 1853, 5, 10, 0, 0, 1853,
		1855, 5, 170, 0, 0, 1854, 1850, 1, 0, 0, 0, 1854, 1851, 1, 0, 0, 0, 1855,
		267, 1, 0, 0, 0, 1856, 1857, 3, 470, 235, 0, 1857, 1858, 3, 370, 185, 0,
		1858, 1859, 3, 270, 135, 0, 1859, 269, 1, 0, 0, 0, 1860, 1863, 5, 170,
		0, 0, 1861, 1864, 3, 362, 181, 0, 1862, 1864, 3, 384, 192, 0, 1863, 1861,
		1, 0, 0, 0, 1863, 1862, 1, 0, 0, 0, 1863, 1864, 1, 0, 0, 0, 1864, 271,
		1, 0, 0, 0, 1865, 1866, 3, 528, 264, 0, 1866, 1867, 3, 280, 140, 0, 1867,
		273, 1, 0, 0, 0, 1868, 1869, 3, 388, 194, 0, 1869, 275, 1, 0, 0, 0, 1870,
		1873, 5, 11, 0, 0, 1871, 1873, 3, 278, 139, 0, 1872, 1870, 1, 0, 0, 0,
		1872, 1871, 1, 0, 0, 0, 1873, 1879, 1, 0, 0, 0, 1874, 1875, 3, 550, 275,
		0, 1875, 1876, 3, 278, 139, 0, 1876, 1878, 1, 0, 0, 0, 1877, 1874, 1, 0,
		0, 0, 1878, 1881, 1, 0, 0, 0, 1879, 1877, 1, 0, 0, 0, 1879, 1880, 1, 0,
		0, 0, 1880, 277, 1, 0, 0, 0, 1881, 1879, 1, 0, 0, 0, 1882, 1883, 5, 170,
		0, 0, 1883, 1884, 5, 10, 0, 0, 1884, 1898, 5, 11, 0, 0, 1885, 1889, 5,
		170, 0, 0, 1886, 1887, 3, 360, 180, 0, 1887, 1888, 5, 170, 0, 0, 1888,
		1890, 1, 0, 0, 0, 1889, 1886, 1, 0, 0, 0, 1889, 1890, 1, 0, 0, 0, 1890,
		1898, 1, 0, 0, 0, 1891, 1895, 3, 288, 144, 0, 1892, 1893, 3, 360, 180,
		0, 1893, 1894, 5, 170, 0, 0, 1894, 1896, 1, 0, 0, 0, 1895, 1892, 1, 0,
		0, 0, 1895, 1896, 1, 0, 0, 0, 1896, 1898, 1, 0, 0, 0, 1897, 1882, 1, 0,
		0, 0, 1897, 1885, 1, 0, 0, 0, 1897, 1891, 1, 0, 0, 0, 1898, 279, 1, 0,
		0, 0, 1899, 1905, 3, 282, 141, 0, 1900, 1901, 3, 356, 178, 0, 1901, 1902,
		3, 282, 141, 0, 1902, 1904, 1, 0, 0, 0, 1903, 1900, 1, 0, 0, 0, 1904, 1907,
		1, 0, 0, 0, 1905, 1903, 1, 0, 0, 0, 1905, 1906, 1, 0, 0, 0, 1906, 281,
		1, 0, 0, 0, 1907, 1905, 1, 0, 0, 0, 1908, 1909, 5, 170, 0, 0, 1909, 1910,
		7, 2, 0, 0, 1910, 1980, 3, 292, 146, 0, 1911, 1912, 5, 170, 0, 0, 1912,
		1913, 5, 10, 0, 0, 1913, 1914, 5, 170, 0, 0, 1914, 1915, 7, 2, 0, 0, 1915,
		1980, 3, 292, 146, 0, 1916, 1917, 3, 288, 144, 0, 1917, 1918, 7, 2, 0,
		0, 1918, 1919, 3, 292, 146, 0, 1919, 1980, 1, 0, 0, 0, 1920, 1921, 3, 288,
		144, 0, 1921, 1922, 7, 2, 0, 0, 1922, 1923, 3, 288, 144, 0, 1923, 1980,
		1, 0, 0, 0, 1924, 1925, 5, 170, 0, 0, 1925, 1926, 3, 416, 208, 0, 1926,
		1928, 5, 1, 0, 0, 1927, 1929, 3, 290, 145, 0, 1928, 1927, 1, 0, 0, 0, 1928,
		1929, 1, 0, 0, 0, 1929, 1930, 1, 0, 0, 0, 1930, 1931, 5, 2, 0, 0, 1931,
		1980, 1, 0, 0, 0, 1932, 1933, 5, 1, 0, 0, 1933, 1939, 5, 170, 0, 0, 1934,
		1935, 3, 550, 275, 0, 1935, 1936, 5, 170, 0, 0, 1936, 1938, 1, 0, 0, 0,
		1937, 1934, 1, 0, 0, 0, 1938, 1941, 1, 0, 0, 0, 1939, 1937, 1, 0, 0, 0,
		1939, 1940, 1, 0, 0, 0, 1940, 1942, 1, 0, 0, 0, 1941, 1939, 1, 0, 0, 0,
		1942, 1943, 5, 2, 0, 0, 1943, 1944, 3, 416, 208, 0, 1944, 1945, 5, 1, 0,
		0, 1945, 1951, 3, 232, 116, 0, 1946, 1947, 3, 550, 275, 0, 1947, 1948,
		3, 232, 116, 0, 1948, 1950, 1, 0, 0, 0, 1949, 1946, 1, 0, 0, 0, 1950, 1953,
		1, 0, 0, 0, 1951, 1949, 1, 0, 0, 0, 1951, 1952, 1, 0, 0, 0, 1952, 1954,
		1, 0, 0, 0, 1953, 1951, 1, 0, 0, 0, 1954, 1955, 5, 2, 0, 0, 1955, 1980,
		1, 0, 0, 0, 1956, 1957, 5, 1, 0, 0, 1957, 1963, 5, 170, 0, 0, 1958, 1959,
		3, 550, 275, 0, 1959, 1960, 5, 170, 0, 0, 1960, 1962, 1, 0, 0, 0, 1961,
		1958, 1, 0, 0, 0, 1962, 1965, 1, 0, 0, 0, 1963, 1961, 1, 0, 0, 0, 1963,
		1964, 1, 0, 0, 0, 1964, 1966, 1, 0, 0, 0, 1965, 1963, 1, 0, 0, 0, 1966,
		1967, 5, 2, 0, 0, 1967, 1968, 7, 2, 0, 0, 1968, 1974, 3, 232, 116, 0, 1969,
		1970, 3, 550, 275, 0, 1970, 1971, 3, 232, 116, 0, 1971, 1973, 1, 0, 0,
		0, 1972, 1969, 1, 0, 0, 0, 1973, 1976, 1, 0, 0, 0, 1974, 1972, 1, 0, 0,
		0, 1974, 1975, 1, 0, 0, 0, 1975, 1980, 1, 0, 0, 0, 1976, 1974, 1, 0, 0,
		0, 1977, 1980, 3, 286, 143, 0, 1978, 1980, 3, 284, 142, 0, 1979, 1908,
		1, 0, 0, 0, 1979, 1911, 1, 0, 0, 0, 1979, 1916, 1, 0, 0, 0, 1979, 1920,
		1, 0, 0, 0, 1979, 1924, 1, 0, 0, 0, 1979, 1932, 1, 0, 0, 0, 1979, 1956,
		1, 0, 0, 0, 1979, 1977, 1, 0, 0, 0, 1979, 1978, 1, 0, 0, 0, 1980, 283,
		1, 0, 0, 0, 1981, 1982, 5, 170, 0, 0, 1982, 1983, 3, 378, 189, 0, 1983,
		1984, 3, 292, 146, 0, 1984, 285, 1, 0, 0, 0, 1985, 1986, 5, 170, 0, 0,
		1986, 1987, 3, 378, 189, 0, 1987, 1988, 3, 432, 216, 0, 1988, 1989, 1,
		0, 0, 0, 1989, 1990, 3, 292, 146, 0, 1990, 287, 1, 0, 0, 0, 1991, 1992,
		5, 170, 0, 0, 1992, 1993, 5, 1, 0, 0, 1993, 1994, 5, 11, 0, 0, 1994, 2005,
		5, 2, 0, 0, 1995, 1996, 5, 170, 0, 0, 1996, 1998, 5, 1, 0, 0, 1997, 1999,
		3, 290, 145, 0, 1998, 1997, 1, 0, 0, 0, 1998, 1999, 1, 0, 0, 0, 1999, 2000,
		1, 0, 0, 0, 2000, 2005, 5, 2, 0, 0, 2001, 2002, 5, 136, 0, 0, 2002, 2003,
		5, 1, 0, 0, 2003, 2005, 5, 2, 0, 0, 2004, 1991, 1, 0, 0, 0, 2004, 1995,
		1, 0, 0, 0, 2004, 2001, 1, 0, 0, 0, 2005, 289, 1, 0, 0, 0, 2006, 2010,
		3, 292, 146, 0, 2007, 2010, 5, 170, 0, 0, 2008, 2010, 3, 288, 144, 0, 2009,
		2006, 1, 0, 0, 0, 2009, 2007, 1, 0, 0, 0, 2009, 2008, 1, 0, 0, 0, 2010,
		2019, 1, 0, 0, 0, 2011, 2015, 3, 550, 275, 0, 2012, 2016, 3, 292, 146,
		0, 2013, 2016, 5, 170, 0, 0, 2014, 2016, 3, 288, 144, 0, 2015, 2012, 1,
		0, 0, 0, 2015, 2013, 1, 0, 0, 0, 2015, 2014, 1, 0, 0, 0, 2016, 2018, 1,
		0, 0, 0, 2017, 2011, 1, 0, 0, 0, 2018, 2021, 1, 0, 0, 0, 2019, 2017, 1,
		0, 0, 0, 2019, 2020, 1, 0, 0, 0, 2020, 291, 1, 0, 0, 0, 2021, 2019, 1,
		0, 0, 0, 2022, 2031, 5, 171, 0, 0, 2023, 2031, 3, 298, 149, 0, 2024, 2031,
		3, 294, 147, 0, 2025, 2031, 3, 296, 148, 0, 2026, 2031, 3, 302, 151, 0,
		2027, 2031, 3, 300, 150, 0, 2028, 2031, 3, 46, 23, 0, 2029, 2031, 3, 460,
		230, 0, 2030, 2022, 1, 0, 0, 0, 2030, 2023, 1, 0, 0, 0, 2030, 2024, 1,
		0, 0, 0, 2030, 2025, 1, 0, 0, 0, 2030, 2026, 1, 0, 0, 0, 2030, 2027, 1,
		0, 0, 0, 2030, 2028, 1, 0, 0, 0, 2030, 2029, 1, 0, 0, 0, 2031, 293, 1,
		0, 0, 0, 2032, 2033, 5, 166, 0, 0, 2033, 295, 1, 0, 0, 0, 2034, 2035, 7,
		3, 0, 0, 2035, 297, 1, 0, 0, 0, 2036, 2037, 5, 165, 0, 0, 2037, 299, 1,
		0, 0, 0, 2038, 2039, 7, 4, 0, 0, 2039, 301, 1, 0, 0, 0, 2040, 2041, 5,
		168, 0, 0, 2041, 303, 1, 0, 0, 0, 2042, 2047, 5, 170, 0, 0, 2043, 2044,
		5, 17, 0, 0, 2044, 2045, 5, 170, 0, 0, 2045, 2047, 5, 17, 0, 0, 2046, 2042,
		1, 0, 0, 0, 2046, 2043, 1, 0, 0, 0, 2047, 305, 1, 0, 0, 0, 2048, 2053,
		5, 170, 0, 0, 2049, 2050, 5, 17, 0, 0, 2050, 2051, 5, 170, 0, 0, 2051,
		2053, 5, 17, 0, 0, 2052, 2048, 1, 0, 0, 0, 2052, 2049, 1, 0, 0, 0, 2053,
		307, 1, 0, 0, 0, 2054, 2059, 5, 170, 0, 0, 2055, 2056, 5, 17, 0, 0, 2056,
		2057, 5, 170, 0, 0, 2057, 2059, 5, 17, 0, 0, 2058, 2054, 1, 0, 0, 0, 2058,
		2055, 1, 0, 0, 0, 2059, 309, 1, 0, 0, 0, 2060, 2062, 3, 312, 156, 0, 2061,
		2063, 3, 314, 157, 0, 2062, 2061, 1, 0, 0, 0, 2062, 2063, 1, 0, 0, 0, 2063,
		311, 1, 0, 0, 0, 2064, 2065, 7, 5, 0, 0, 2065, 313, 1, 0, 0, 0, 2066, 2067,
		3, 542, 271, 0, 2067, 2073, 3, 312, 156, 0, 2068, 2069, 3, 550, 275, 0,
		2069, 2070, 3, 312, 156, 0, 2070, 2072, 1, 0, 0, 0, 2071, 2068, 1, 0, 0,
		0, 2072, 2075, 1, 0, 0, 0, 2073, 2071, 1, 0, 0, 0, 2073, 2074, 1, 0, 0,
		0, 2074, 2076, 1, 0, 0, 0, 2075, 2073, 1, 0, 0, 0, 2076, 2077, 3, 544,
		272, 0, 2077, 315, 1, 0, 0, 0, 2078, 2081, 3, 362, 181, 0, 2079, 2081,
		3, 384, 192, 0, 2080, 2078, 1, 0, 0, 0, 2080, 2079, 1, 0, 0, 0, 2081, 317,
		1, 0, 0, 0, 2082, 2083, 5, 170, 0, 0, 2083, 319, 1, 0, 0, 0, 2084, 2085,
		5, 170, 0, 0, 2085, 321, 1, 0, 0, 0, 2086, 2087, 3, 298, 149, 0, 2087,
		323, 1, 0, 0, 0, 2088, 2089, 5, 170, 0, 0, 2089, 325, 1, 0, 0, 0, 2090,
		2091, 5, 170, 0, 0, 2091, 327, 1, 0, 0, 0, 2092, 2093, 5, 170, 0, 0, 2093,
		329, 1, 0, 0, 0, 2094, 2095, 5, 170, 0, 0, 2095, 331, 1, 0, 0, 0, 2096,
		2097, 5, 170, 0, 0, 2097, 333, 1, 0, 0, 0, 2098, 2099, 5, 170, 0, 0, 2099,
		335, 1, 0, 0, 0, 2100, 2101, 3, 298, 149, 0, 2101, 337, 1, 0, 0, 0, 2102,
		2103, 5, 170, 0, 0, 2103, 339, 1, 0, 0, 0, 2104, 2105, 3, 342, 171, 0,
		2105, 2106, 3, 310, 155, 0, 2106, 341, 1, 0, 0, 0, 2107, 2108, 7, 6, 0,
		0, 2108, 343, 1, 0, 0, 0, 2109, 2110, 5, 24, 0, 0, 2110, 345, 1, 0, 0,
		0, 2111, 2112, 5, 25, 0, 0, 2112, 347, 1, 0, 0, 0, 2113, 2114, 5, 26, 0,
		0, 2114, 349, 1, 0, 0, 0, 2115, 2116, 5, 26, 0, 0, 2116, 2117, 5, 102,
		0, 0, 2117, 351, 1, 0, 0, 0, 2118, 2119, 5, 27, 0, 0, 2119, 353, 1, 0,
		0, 0, 2120, 2121, 5, 28, 0, 0, 2121, 355, 1, 0, 0, 0, 2122, 2123, 5, 29,
		0, 0, 2123, 357, 1, 0, 0, 0, 2124, 2125, 5, 31, 0, 0, 2125, 359, 1, 0,
		0, 0, 2126, 2127, 5, 32, 0, 0, 2127, 361, 1, 0, 0, 0, 2128, 2129, 5, 33,
		0, 0, 2129, 363, 1, 0, 0, 0, 2130, 2131, 5, 34, 0, 0, 2131, 365, 1, 0,
		0, 0, 2132, 2133, 5, 35, 0, 0, 2133, 367, 1, 0, 0, 0, 2134, 2135, 5, 36,
		0, 0, 2135, 369, 1, 0, 0, 0, 2136, 2137, 5, 37, 0, 0, 2137, 371, 1, 0,
		0, 0, 2138, 2139, 5, 38, 0, 0, 2139, 373, 1, 0, 0, 0, 2140, 2141, 5, 39,
		0, 0, 2141, 375, 1, 0, 0, 0, 2142, 2143, 5, 41, 0, 0, 2143, 377, 1, 0,
		0, 0, 2144, 2145, 5, 43, 0, 0, 2145, 379, 1, 0, 0, 0, 2146, 2147, 5, 44,
		0, 0, 2147, 381, 1, 0, 0, 0, 2148, 2149, 5, 46, 0, 0, 2149, 383, 1, 0,
		0, 0, 2150, 2151, 5, 47, 0, 0, 2151, 385, 1, 0, 0, 0, 2152, 2153, 5, 48,
		0, 0, 2153, 387, 1, 0, 0, 0, 2154, 2155, 5, 49, 0, 0, 2155, 389, 1, 0,
		0, 0, 2156, 2157, 5, 50, 0, 0, 2157, 391, 1, 0, 0, 0, 2158, 2159, 5, 51,
		0, 0, 2159, 393, 1, 0, 0, 0, 2160, 2161, 5, 53, 0, 0, 2161, 395, 1, 0,
		0, 0, 2162, 2163, 5, 54, 0, 0, 2163, 397, 1, 0, 0, 0, 2164, 2165, 5, 55,
		0, 0, 2165, 399, 1, 0, 0, 0, 2166, 2167, 5, 57, 0, 0, 2167, 401, 1, 0,
		0, 0, 2168, 2169, 5, 58, 0, 0, 2169, 403, 1, 0, 0, 0, 2170, 2171, 5, 59,
		0, 0, 2171, 405, 1, 0, 0, 0, 2172, 2173, 5, 60, 0, 0, 2173, 407, 1, 0,
		0, 0, 2174, 2175, 5, 61, 0, 0, 2175, 409, 1, 0, 0, 0, 2176, 2177, 5, 62,
		0, 0, 2177, 411, 1, 0, 0, 0, 2178, 2179, 5, 63, 0, 0, 2179, 413, 1, 0,
		0, 0, 2180, 2181, 5, 64, 0, 0, 2181, 415, 1, 0, 0, 0, 2182, 2183, 5, 65,
		0, 0, 2183, 417, 1, 0, 0, 0, 2184, 2185, 5, 66, 0, 0, 2185, 419, 1, 0,
		0, 0, 2186, 2187, 5, 68, 0, 0, 2187, 421, 1, 0, 0, 0, 2188, 2189, 5, 69,
		0, 0, 2189, 423, 1, 0, 0, 0, 2190, 2191, 5, 70, 0, 0, 2191, 425, 1, 0,
		0, 0, 2192, 2193, 5, 71, 0, 0, 2193, 427, 1, 0, 0, 0, 2194, 2195, 5, 72,
		0, 0, 2195, 429, 1, 0, 0, 0, 2196, 2197, 5, 73, 0, 0, 2197, 431, 1, 0,
		0, 0, 2198, 2199, 5, 74, 0, 0, 2199, 433, 1, 0, 0, 0, 2200, 2201, 5, 75,
		0, 0, 2201, 435, 1, 0, 0, 0, 2202, 2203, 5, 76, 0, 0, 2203, 437, 1, 0,
		0, 0, 2204, 2205, 5, 77, 0, 0, 2205, 439, 1, 0, 0, 0, 2206, 2207, 5, 78,
		0, 0, 2207, 441, 1, 0, 0, 0, 2208, 2209, 5, 80, 0, 0, 2209, 443, 1, 0,
		0, 0, 2210, 2211, 5, 154, 0, 0, 2211, 445, 1, 0, 0, 0, 2212, 2213, 5, 83,
		0, 0, 2213, 447, 1, 0, 0, 0, 2214, 2215, 5, 84, 0, 0, 2215, 449, 1, 0,
		0, 0, 2216, 2217, 5, 85, 0, 0, 2217, 451, 1, 0, 0, 0, 2218, 2219, 5, 86,
		0, 0, 2219, 453, 1, 0, 0, 0, 2220, 2221, 5, 89, 0, 0, 2221, 455, 1, 0,
		0, 0, 2222, 2223, 5, 88, 0, 0, 2223, 457, 1, 0, 0, 0, 2224, 2225, 5, 90,
		0, 0, 2225, 459, 1, 0, 0, 0, 2226, 2227, 5, 91, 0, 0, 2227, 461, 1, 0,
		0, 0, 2228, 2229, 5, 92, 0, 0, 2229, 463, 1, 0, 0, 0, 2230, 2231, 5, 93,
		0, 0, 2231, 465, 1, 0, 0, 0, 2232, 2233, 5, 95, 0, 0, 2233, 467, 1, 0,
		0, 0, 2234, 2235, 5, 96, 0, 0, 2235, 469, 1, 0, 0, 0, 2236, 2237, 5, 97,
		0, 0, 2237, 471, 1, 0, 0, 0, 2238, 2239, 5, 99, 0, 0, 2239, 473, 1, 0,
		0, 0, 2240, 2241, 5, 103, 0, 0, 2241, 475, 1, 0, 0, 0, 2242, 2243, 5, 105,
		0, 0, 2243, 477, 1, 0, 0, 0, 2244, 2245, 5, 106, 0, 0, 2245, 479, 1, 0,
		0, 0, 2246, 2247, 5, 107, 0, 0, 2247, 481, 1, 0, 0, 0, 2248, 2249, 5, 108,
		0, 0, 2249, 483, 1, 0, 0, 0, 2250, 2251, 5, 110, 0, 0, 2251, 485, 1, 0,
		0, 0, 2252, 2253, 5, 111, 0, 0, 2253, 487, 1, 0, 0, 0, 2254, 2255, 5, 113,
		0, 0, 2255, 489, 1, 0, 0, 0, 2256, 2257, 5, 114, 0, 0, 2257, 491, 1, 0,
		0, 0, 2258, 2259, 5, 115, 0, 0, 2259, 493, 1, 0, 0, 0, 2260, 2261, 5, 117,
		0, 0, 2261, 495, 1, 0, 0, 0, 2262, 2263, 5, 118, 0, 0, 2263, 497, 1, 0,
		0, 0, 2264, 2265, 5, 119, 0, 0, 2265, 499, 1, 0, 0, 0, 2266, 2267, 5, 120,
		0, 0, 2267, 501, 1, 0, 0, 0, 2268, 2269, 5, 122, 0, 0, 2269, 503, 1, 0,
		0, 0, 2270, 2271, 5, 123, 0, 0, 2271, 505, 1, 0, 0, 0, 2272, 2273, 5, 125,
		0, 0, 2273, 507, 1, 0, 0, 0, 2274, 2275, 5, 127, 0, 0, 2275, 509, 1, 0,
		0, 0, 2276, 2277, 5, 128, 0, 0, 2277, 511, 1, 0, 0, 0, 2278, 2279, 5, 130,
		0, 0, 2279, 513, 1, 0, 0, 0, 2280, 2281, 5, 131, 0, 0, 2281, 515, 1, 0,
		0, 0, 2282, 2283, 5, 132, 0, 0, 2283, 517, 1, 0, 0, 0, 2284, 2285, 5, 133,
		0, 0, 2285, 519, 1, 0, 0, 0, 2286, 2287, 5, 134, 0, 0, 2287, 521, 1, 0,
		0, 0, 2288, 2289, 5, 135, 0, 0, 2289, 523, 1, 0, 0, 0, 2290, 2291, 5, 137,
		0, 0, 2291, 525, 1, 0, 0, 0, 2292, 2293, 5, 138, 0, 0, 2293, 527, 1, 0,
		0, 0, 2294, 2295, 5, 139, 0, 0, 2295, 529, 1, 0, 0, 0, 2296, 2297, 5, 140,
		0, 0, 2297, 531, 1, 0, 0, 0, 2298, 2299, 5, 109, 0, 0, 2299, 533, 1, 0,
		0, 0, 2300, 2301, 5, 1, 0, 0, 2301, 535, 1, 0, 0, 0, 2302, 2303, 5, 2,
		0, 0, 2303, 537, 1, 0, 0, 0, 2304, 2305, 5, 3, 0, 0, 2305, 539, 1, 0, 0,
		0, 2306, 2307, 5, 4, 0, 0, 2307, 541, 1, 0, 0, 0, 2308, 2309, 5, 20, 0,
		0, 2309, 543, 1, 0, 0, 0, 2310, 2311, 5, 21, 0, 0, 2311, 545, 1, 0, 0,
		0, 2312, 2313, 5, 5, 0, 0, 2313, 547, 1, 0, 0, 0, 2314, 2315, 5, 6, 0,
		0, 2315, 549, 1, 0, 0, 0, 2316, 2317, 5, 7, 0, 0, 2317, 551, 1, 0, 0, 0,
		2318, 2319, 5, 9, 0, 0, 2319, 553, 1, 0, 0, 0, 178, 555, 558, 564, 569,
		571, 576, 579, 582, 625, 639, 642, 649, 654, 665, 675, 690, 701, 706, 715,
		720, 728, 733, 737, 742, 747, 762, 768, 773, 783, 788, 798, 810, 817, 825,
		839, 844, 856, 860, 864, 869, 874, 893, 900, 908, 912, 917, 936, 945, 960,
		962, 974, 988, 995, 1002, 1010, 1021, 1037, 1050, 1060, 1083, 1097, 1104,
		1113, 1132, 1140, 1146, 1151, 1158, 1163, 1171, 1176, 1183, 1188, 1195,
		1200, 1207, 1214, 1221, 1228, 1233, 1240, 1247, 1252, 1259, 1264, 1271,
		1281, 1287, 1295, 1299, 1307, 1312, 1316, 1329, 1335, 1344, 1357, 1365,
		1371, 1376, 1390, 1410, 1419, 1431, 1435, 1439, 1453, 1461, 1470, 1481,
		1486, 1493, 1496, 1502, 1511, 1517, 1535, 1539, 1543, 1548, 1556, 1564,
		1568, 1571, 1577, 1581, 1588, 1599, 1612, 1621, 1668, 1677, 1680, 1696,
		1708, 1720, 1726, 1733, 1737, 1741, 1744, 1762, 1788, 1800, 1809, 1818,
		1822, 1825, 1830, 1833, 1836, 1839, 1854, 1863, 1872, 1879, 1889, 1895,
		1897, 1905, 1928, 1939, 1951, 1963, 1974, 1979, 1998, 2004, 2009, 2015,
		2019, 2030, 2046, 2052, 2058, 2062, 2073, 2080,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// CQLParserInit initializes any static state used to implement CQLParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewCQLParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func CQLParserInit() {
	staticData := &CQLParserParserStaticData
	staticData.once.Do(cqlparserParserInit)
}

// NewCQLParser produces a new parser instance for the optional input antlr.TokenStream.
func NewCQLParser(input antlr.TokenStream) *CQLParser {
	CQLParserInit()
	this := new(CQLParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &CQLParserParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "CQLParser.g4"

	return this
}

// CQLParser tokens.
const (
	CQLParserEOF                 = antlr.TokenEOF
	CQLParserLR_BRACKET          = 1
	CQLParserRR_BRACKET          = 2
	CQLParserLC_BRACKET          = 3
	CQLParserRC_BRACKET          = 4
	CQLParserLS_BRACKET          = 5
	CQLParserRS_BRACKET          = 6
	CQLParserCOMMA               = 7
	CQLParserSEMI                = 8
	CQLParserCOLON               = 9
	CQLParserDOT                 = 10
	CQLParserSTAR                = 11
	CQLParserDIVIDE              = 12
	CQLParserMODULE              = 13
	CQLParserPLUS                = 14
	CQLParserMINUSMINUS          = 15
	CQLParserMINUS               = 16
	CQLParserDQUOTE              = 17
	CQLParserSQUOTE              = 18
	CQLParserOPERATOR_EQ         = 19
	CQLParserOPERATOR_LT         = 20
	CQLParserOPERATOR_GT         = 21
	CQLParserOPERATOR_LTE        = 22
	CQLParserOPERATOR_GTE        = 23
	CQLParserK_ADD               = 24
	CQLParserK_AGGREGATE         = 25
	CQLParserK_ALL               = 26
	CQLParserK_ALLOW             = 27
	CQLParserK_ALTER             = 28
	CQLParserK_AND               = 29
	CQLParserK_ANY               = 30
	CQLParserK_APPLY             = 31
	CQLParserK_AS                = 32
	CQLParserK_ASC               = 33
	CQLParserK_AUTHORIZE         = 34
	CQLParserK_BATCH             = 35
	CQLParserK_BEGIN             = 36
	CQLParserK_BY                = 37
	CQLParserK_CALLED            = 38
	CQLParserK_CLUSTERING        = 39
	CQLParserK_COLUMNFAMILY      = 40
	CQLParserK_COMPACT           = 41
	CQLParserK_CONSISTENCY       = 42
	CQLParserK_CONTAINS          = 43
	CQLParserK_CREATE            = 44
	CQLParserK_CUSTOM            = 45
	CQLParserK_DELETE            = 46
	CQLParserK_DESC              = 47
	CQLParserK_DESCRIBE          = 48
	CQLParserK_DISTINCT          = 49
	CQLParserK_DROP              = 50
	CQLParserK_DURABLE_WRITES    = 51
	CQLParserK_EACH_QUORUM       = 52
	CQLParserK_ENTRIES           = 53
	CQLParserK_EXECUTE           = 54
	CQLParserK_EXISTS            = 55
	CQLParserK_FALSE             = 56
	CQLParserK_FILTERING         = 57
	CQLParserK_FINALFUNC         = 58
	CQLParserK_FROM              = 59
	CQLParserK_FULL              = 60
	CQLParserK_FUNCTION          = 61
	CQLParserK_FUNCTIONS         = 62
	CQLParserK_GRANT             = 63
	CQLParserK_IF                = 64
	CQLParserK_IN                = 65
	CQLParserK_INDEX             = 66
	CQLParserK_INFINITY          = 67
	CQLParserK_INITCOND          = 68
	CQLParserK_INPUT             = 69
	CQLParserK_INSERT            = 70
	CQLParserK_INTO              = 71
	CQLParserK_IS                = 72
	CQLParserK_JSON              = 73
	CQLParserK_KEY               = 74
	CQLParserK_KEYS              = 75
	CQLParserK_KEYSPACE          = 76
	CQLParserK_KEYSPACES         = 77
	CQLParserK_LANGUAGE          = 78
	CQLParserK_LEVEL             = 79
	CQLParserK_LIMIT             = 80
	CQLParserK_LOCAL_ONE         = 81
	CQLParserK_LOCAL_QUORUM      = 82
	CQLParserK_LOGGED            = 83
	CQLParserK_LOGIN             = 84
	CQLParserK_MATERIALIZED      = 85
	CQLParserK_MODIFY            = 86
	CQLParserK_NAN               = 87
	CQLParserK_NORECURSIVE       = 88
	CQLParserK_NOSUPERUSER       = 89
	CQLParserK_NOT               = 90
	CQLParserK_NULL              = 91
	CQLParserK_OF                = 92
	CQLParserK_ON                = 93
	CQLParserK_ONE               = 94
	CQLParserK_OPTIONS           = 95
	CQLParserK_OR                = 96
	CQLParserK_ORDER             = 97
	CQLParserK_PARTITION         = 98
	CQLParserK_PASSWORD          = 99
	CQLParserK_PER               = 100
	CQLParserK_PERMISSION        = 101
	CQLParserK_PERMISSIONS       = 102
	CQLParserK_PRIMARY           = 103
	CQLParserK_QUORUM            = 104
	CQLParserK_RENAME            = 105
	CQLParserK_REPLACE           = 106
	CQLParserK_REPLICATION       = 107
	CQLParserK_RETURNS           = 108
	CQLParserK_REVOKE            = 109
	CQLParserK_ROLE              = 110
	CQLParserK_ROLES             = 111
	CQLParserK_SCHEMA            = 112
	CQLParserK_SELECT            = 113
	CQLParserK_SET               = 114
	CQLParserK_SFUNC             = 115
	CQLParserK_STATIC            = 116
	CQLParserK_STORAGE           = 117
	CQLParserK_STYPE             = 118
	CQLParserK_SUPERUSER         = 119
	CQLParserK_TABLE             = 120
	CQLParserK_THREE             = 121
	CQLParserK_TIMESTAMP         = 122
	CQLParserK_TO                = 123
	CQLParserK_TOKEN             = 124
	CQLParserK_TRIGGER           = 125
	CQLParserK_TRUE              = 126
	CQLParserK_TRUNCATE          = 127
	CQLParserK_TTL               = 128
	CQLParserK_TWO               = 129
	CQLParserK_TYPE              = 130
	CQLParserK_UNLOGGED          = 131
	CQLParserK_UPDATE            = 132
	CQLParserK_USE               = 133
	CQLParserK_USER              = 134
	CQLParserK_USING             = 135
	CQLParserK_UUID              = 136
	CQLParserK_VALUES            = 137
	CQLParserK_VIEW              = 138
	CQLParserK_WHERE             = 139
	CQLParserK_WITH              = 140
	CQLParserK_WRITETIME         = 141
	CQLParserK_ASCII             = 142
	CQLParserK_BIGINT            = 143
	CQLParserK_BLOB              = 144
	CQLParserK_BOOLEAN           = 145
	CQLParserK_COUNTER           = 146
	CQLParserK_DATE              = 147
	CQLParserK_DECIMAL           = 148
	CQLParserK_DOUBLE            = 149
	CQLParserK_FLOAT             = 150
	CQLParserK_FROZEN            = 151
	CQLParserK_INET              = 152
	CQLParserK_INT               = 153
	CQLParserK_LIST              = 154
	CQLParserK_MAP               = 155
	CQLParserK_SMALLINT          = 156
	CQLParserK_TEXT              = 157
	CQLParserK_TIMEUUID          = 158
	CQLParserK_TIME              = 159
	CQLParserK_TINYINT           = 160
	CQLParserK_TUPLE             = 161
	CQLParserK_VARCHAR           = 162
	CQLParserK_VARINT            = 163
	CQLParserCODE_BLOCK          = 164
	CQLParserSTRING_LITERAL      = 165
	CQLParserDECIMAL_LITERAL     = 166
	CQLParserFLOAT_LITERAL       = 167
	CQLParserHEXADECIMAL_LITERAL = 168
	CQLParserREAL_LITERAL        = 169
	CQLParserOBJECT_NAME         = 170
	CQLParserUUID                = 171
	CQLParserSPACE               = 172
	CQLParserSPEC_MYSQL_COMMENT  = 173
	CQLParserCOMMENT_INPUT       = 174
	CQLParserLINE_COMMENT        = 175
)

// CQLParser rules.
const (
	CQLParserRULE_root                         = 0
	CQLParserRULE_cqls                         = 1
	CQLParserRULE_statementSeparator           = 2
	CQLParserRULE_empty_                       = 3
	CQLParserRULE_cql                          = 4
	CQLParserRULE_revoke                       = 5
	CQLParserRULE_listRoles                    = 6
	CQLParserRULE_listPermissions              = 7
	CQLParserRULE_grant                        = 8
	CQLParserRULE_priviledge                   = 9
	CQLParserRULE_resource                     = 10
	CQLParserRULE_createUser                   = 11
	CQLParserRULE_createRole                   = 12
	CQLParserRULE_createType                   = 13
	CQLParserRULE_typeMemberColumnList         = 14
	CQLParserRULE_createTrigger                = 15
	CQLParserRULE_createMaterializedView       = 16
	CQLParserRULE_materializedViewWhere        = 17
	CQLParserRULE_columnNotNullList            = 18
	CQLParserRULE_columnNotNull                = 19
	CQLParserRULE_materializedViewOptions      = 20
	CQLParserRULE_createKeyspace               = 21
	CQLParserRULE_createFunction               = 22
	CQLParserRULE_codeBlock                    = 23
	CQLParserRULE_paramList                    = 24
	CQLParserRULE_returnMode                   = 25
	CQLParserRULE_createAggregate              = 26
	CQLParserRULE_initCondDefinition           = 27
	CQLParserRULE_initCondHash                 = 28
	CQLParserRULE_initCondHashItem             = 29
	CQLParserRULE_initCondListNested           = 30
	CQLParserRULE_initCondList                 = 31
	CQLParserRULE_orReplace                    = 32
	CQLParserRULE_alterUser                    = 33
	CQLParserRULE_userPassword                 = 34
	CQLParserRULE_userSuperUser                = 35
	CQLParserRULE_alterType                    = 36
	CQLParserRULE_alterTypeOperation           = 37
	CQLParserRULE_alterTypeRename              = 38
	CQLParserRULE_alterTypeRenameList          = 39
	CQLParserRULE_alterTypeRenameItem          = 40
	CQLParserRULE_alterTypeAdd                 = 41
	CQLParserRULE_alterTypeAlterType           = 42
	CQLParserRULE_alterTable                   = 43
	CQLParserRULE_alterTableOperation          = 44
	CQLParserRULE_alterTableWith               = 45
	CQLParserRULE_alterTableRename             = 46
	CQLParserRULE_alterTableDropCompactStorage = 47
	CQLParserRULE_alterTableDropColumns        = 48
	CQLParserRULE_alterTableDropColumnList     = 49
	CQLParserRULE_alterTableAdd                = 50
	CQLParserRULE_alterTableColumnDefinition   = 51
	CQLParserRULE_alterRole                    = 52
	CQLParserRULE_roleWith                     = 53
	CQLParserRULE_roleWithOptions              = 54
	CQLParserRULE_alterMaterializedView        = 55
	CQLParserRULE_dropUser                     = 56
	CQLParserRULE_dropType                     = 57
	CQLParserRULE_dropMaterializedView         = 58
	CQLParserRULE_dropAggregate                = 59
	CQLParserRULE_dropFunction                 = 60
	CQLParserRULE_dropTrigger                  = 61
	CQLParserRULE_dropRole                     = 62
	CQLParserRULE_dropTable                    = 63
	CQLParserRULE_dropKeyspace                 = 64
	CQLParserRULE_dropIndex                    = 65
	CQLParserRULE_createTable                  = 66
	CQLParserRULE_withElement                  = 67
	CQLParserRULE_tableOptions                 = 68
	CQLParserRULE_clusteringOrder              = 69
	CQLParserRULE_tableOptionItem              = 70
	CQLParserRULE_tableOptionName              = 71
	CQLParserRULE_tableOptionValue             = 72
	CQLParserRULE_optionHash                   = 73
	CQLParserRULE_optionHashItem               = 74
	CQLParserRULE_optionHashKey                = 75
	CQLParserRULE_optionHashValue              = 76
	CQLParserRULE_columnDefinitionList         = 77
	CQLParserRULE_columnDefinition             = 78
	CQLParserRULE_primaryKeyColumn             = 79
	CQLParserRULE_primaryKeyElement            = 80
	CQLParserRULE_primaryKeyDefinition         = 81
	CQLParserRULE_singlePrimaryKey             = 82
	CQLParserRULE_compoundKey                  = 83
	CQLParserRULE_compositeKey                 = 84
	CQLParserRULE_partitionKeyList             = 85
	CQLParserRULE_clusteringKeyList            = 86
	CQLParserRULE_partitionKey                 = 87
	CQLParserRULE_clusteringKey                = 88
	CQLParserRULE_applyBatch                   = 89
	CQLParserRULE_beginBatch                   = 90
	CQLParserRULE_batchType                    = 91
	CQLParserRULE_alterKeyspace                = 92
	CQLParserRULE_replicationList              = 93
	CQLParserRULE_replicationListItem          = 94
	CQLParserRULE_durableWrites                = 95
	CQLParserRULE_use_                         = 96
	CQLParserRULE_truncate                     = 97
	CQLParserRULE_createIndex                  = 98
	CQLParserRULE_indexName                    = 99
	CQLParserRULE_indexColumnSpec              = 100
	CQLParserRULE_indexKeysSpec                = 101
	CQLParserRULE_indexEntriesSSpec            = 102
	CQLParserRULE_indexFullSpec                = 103
	CQLParserRULE_delete_                      = 104
	CQLParserRULE_deleteColumnList             = 105
	CQLParserRULE_deleteColumnItem             = 106
	CQLParserRULE_update                       = 107
	CQLParserRULE_ifSpec                       = 108
	CQLParserRULE_ifConditionList              = 109
	CQLParserRULE_ifCondition                  = 110
	CQLParserRULE_assignments                  = 111
	CQLParserRULE_assignmentElement            = 112
	CQLParserRULE_assignmentSet                = 113
	CQLParserRULE_assignmentMap                = 114
	CQLParserRULE_assignmentList               = 115
	CQLParserRULE_assignmentTuple              = 116
	CQLParserRULE_insert                       = 117
	CQLParserRULE_usingTtlTimestamp            = 118
	CQLParserRULE_timestamp                    = 119
	CQLParserRULE_ttl                          = 120
	CQLParserRULE_usingTimestampSpec           = 121
	CQLParserRULE_ifNotExist                   = 122
	CQLParserRULE_ifExist                      = 123
	CQLParserRULE_insertValuesSpec             = 124
	CQLParserRULE_insertColumnSpec             = 125
	CQLParserRULE_columnList                   = 126
	CQLParserRULE_expressionList               = 127
	CQLParserRULE_expression                   = 128
	CQLParserRULE_select_                      = 129
	CQLParserRULE_allowFilteringSpec           = 130
	CQLParserRULE_limitSpec                    = 131
	CQLParserRULE_fromSpec                     = 132
	CQLParserRULE_fromSpecElement              = 133
	CQLParserRULE_orderSpec                    = 134
	CQLParserRULE_orderSpecElement             = 135
	CQLParserRULE_whereSpec                    = 136
	CQLParserRULE_distinctSpec                 = 137
	CQLParserRULE_selectElements               = 138
	CQLParserRULE_selectElement                = 139
	CQLParserRULE_relationElements             = 140
	CQLParserRULE_relationElement              = 141
	CQLParserRULE_relalationContains           = 142
	CQLParserRULE_relalationContainsKey        = 143
	CQLParserRULE_functionCall                 = 144
	CQLParserRULE_functionArgs                 = 145
	CQLParserRULE_constant                     = 146
	CQLParserRULE_decimalLiteral               = 147
	CQLParserRULE_floatLiteral                 = 148
	CQLParserRULE_stringLiteral                = 149
	CQLParserRULE_booleanLiteral               = 150
	CQLParserRULE_hexadecimalLiteral           = 151
	CQLParserRULE_keyspace                     = 152
	CQLParserRULE_table                        = 153
	CQLParserRULE_column                       = 154
	CQLParserRULE_dataType                     = 155
	CQLParserRULE_dataTypeName                 = 156
	CQLParserRULE_dataTypeDefinition           = 157
	CQLParserRULE_orderDirection               = 158
	CQLParserRULE_role                         = 159
	CQLParserRULE_trigger                      = 160
	CQLParserRULE_triggerClass                 = 161
	CQLParserRULE_materializedView             = 162
	CQLParserRULE_type_                        = 163
	CQLParserRULE_aggregate                    = 164
	CQLParserRULE_function_                    = 165
	CQLParserRULE_language                     = 166
	CQLParserRULE_user                         = 167
	CQLParserRULE_password                     = 168
	CQLParserRULE_hashKey                      = 169
	CQLParserRULE_param                        = 170
	CQLParserRULE_paramName                    = 171
	CQLParserRULE_kwAdd                        = 172
	CQLParserRULE_kwAggregate                  = 173
	CQLParserRULE_kwAll                        = 174
	CQLParserRULE_kwAllPermissions             = 175
	CQLParserRULE_kwAllow                      = 176
	CQLParserRULE_kwAlter                      = 177
	CQLParserRULE_kwAnd                        = 178
	CQLParserRULE_kwApply                      = 179
	CQLParserRULE_kwAs                         = 180
	CQLParserRULE_kwAsc                        = 181
	CQLParserRULE_kwAuthorize                  = 182
	CQLParserRULE_kwBatch                      = 183
	CQLParserRULE_kwBegin                      = 184
	CQLParserRULE_kwBy                         = 185
	CQLParserRULE_kwCalled                     = 186
	CQLParserRULE_kwClustering                 = 187
	CQLParserRULE_kwCompact                    = 188
	CQLParserRULE_kwContains                   = 189
	CQLParserRULE_kwCreate                     = 190
	CQLParserRULE_kwDelete                     = 191
	CQLParserRULE_kwDesc                       = 192
	CQLParserRULE_kwDescibe                    = 193
	CQLParserRULE_kwDistinct                   = 194
	CQLParserRULE_kwDrop                       = 195
	CQLParserRULE_kwDurableWrites              = 196
	CQLParserRULE_kwEntries                    = 197
	CQLParserRULE_kwExecute                    = 198
	CQLParserRULE_kwExists                     = 199
	CQLParserRULE_kwFiltering                  = 200
	CQLParserRULE_kwFinalfunc                  = 201
	CQLParserRULE_kwFrom                       = 202
	CQLParserRULE_kwFull                       = 203
	CQLParserRULE_kwFunction                   = 204
	CQLParserRULE_kwFunctions                  = 205
	CQLParserRULE_kwGrant                      = 206
	CQLParserRULE_kwIf                         = 207
	CQLParserRULE_kwIn                         = 208
	CQLParserRULE_kwIndex                      = 209
	CQLParserRULE_kwInitcond                   = 210
	CQLParserRULE_kwInput                      = 211
	CQLParserRULE_kwInsert                     = 212
	CQLParserRULE_kwInto                       = 213
	CQLParserRULE_kwIs                         = 214
	CQLParserRULE_kwJson                       = 215
	CQLParserRULE_kwKey                        = 216
	CQLParserRULE_kwKeys                       = 217
	CQLParserRULE_kwKeyspace                   = 218
	CQLParserRULE_kwKeyspaces                  = 219
	CQLParserRULE_kwLanguage                   = 220
	CQLParserRULE_kwLimit                      = 221
	CQLParserRULE_kwList                       = 222
	CQLParserRULE_kwLogged                     = 223
	CQLParserRULE_kwLogin                      = 224
	CQLParserRULE_kwMaterialized               = 225
	CQLParserRULE_kwModify                     = 226
	CQLParserRULE_kwNosuperuser                = 227
	CQLParserRULE_kwNorecursive                = 228
	CQLParserRULE_kwNot                        = 229
	CQLParserRULE_kwNull                       = 230
	CQLParserRULE_kwOf                         = 231
	CQLParserRULE_kwOn                         = 232
	CQLParserRULE_kwOptions                    = 233
	CQLParserRULE_kwOr                         = 234
	CQLParserRULE_kwOrder                      = 235
	CQLParserRULE_kwPassword                   = 236
	CQLParserRULE_kwPrimary                    = 237
	CQLParserRULE_kwRename                     = 238
	CQLParserRULE_kwReplace                    = 239
	CQLParserRULE_kwReplication                = 240
	CQLParserRULE_kwReturns                    = 241
	CQLParserRULE_kwRole                       = 242
	CQLParserRULE_kwRoles                      = 243
	CQLParserRULE_kwSelect                     = 244
	CQLParserRULE_kwSet                        = 245
	CQLParserRULE_kwSfunc                      = 246
	CQLParserRULE_kwStorage                    = 247
	CQLParserRULE_kwStype                      = 248
	CQLParserRULE_kwSuperuser                  = 249
	CQLParserRULE_kwTable                      = 250
	CQLParserRULE_kwTimestamp                  = 251
	CQLParserRULE_kwTo                         = 252
	CQLParserRULE_kwTrigger                    = 253
	CQLParserRULE_kwTruncate                   = 254
	CQLParserRULE_kwTtl                        = 255
	CQLParserRULE_kwType                       = 256
	CQLParserRULE_kwUnlogged                   = 257
	CQLParserRULE_kwUpdate                     = 258
	CQLParserRULE_kwUse                        = 259
	CQLParserRULE_kwUser                       = 260
	CQLParserRULE_kwUsing                      = 261
	CQLParserRULE_kwValues                     = 262
	CQLParserRULE_kwView                       = 263
	CQLParserRULE_kwWhere                      = 264
	CQLParserRULE_kwWith                       = 265
	CQLParserRULE_kwRevoke                     = 266
	CQLParserRULE_syntaxBracketLr              = 267
	CQLParserRULE_syntaxBracketRr              = 268
	CQLParserRULE_syntaxBracketLc              = 269
	CQLParserRULE_syntaxBracketRc              = 270
	CQLParserRULE_syntaxBracketLa              = 271
	CQLParserRULE_syntaxBracketRa              = 272
	CQLParserRULE_syntaxBracketLs              = 273
	CQLParserRULE_syntaxBracketRs              = 274
	CQLParserRULE_syntaxComma                  = 275
	CQLParserRULE_syntaxColon                  = 276
)

// IRootContext is an interface to support dynamic dispatch.
type IRootContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EOF() antlr.TerminalNode
	Cqls() ICqlsContext
	MINUSMINUS() antlr.TerminalNode

	// IsRootContext differentiates from other interfaces.
	IsRootContext()
}

type RootContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRootContext() *RootContext {
	var p = new(RootContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_root
	return p
}

func InitEmptyRootContext(p *RootContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_root
}

func (*RootContext) IsRootContext() {}

func NewRootContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RootContext {
	var p = new(RootContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_root

	return p
}

func (s *RootContext) GetParser() antlr.Parser { return s.parser }

func (s *RootContext) EOF() antlr.TerminalNode {
	return s.GetToken(CQLParserEOF, 0)
}

func (s *RootContext) Cqls() ICqlsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICqlsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICqlsContext)
}

func (s *RootContext) MINUSMINUS() antlr.TerminalNode {
	return s.GetToken(CQLParserMINUSMINUS, 0)
}

func (s *RootContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RootContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RootContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterRoot(s)
	}
}

func (s *RootContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitRoot(s)
	}
}

func (p *CQLParser) Root() (localctx IRootContext) {
	localctx = NewRootContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, CQLParserRULE_root)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(555)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64((_la-8)) & ^0x3f) == 0 && ((int64(1)<<(_la-8))&4647719557368119297) != 0) || ((int64((_la-109)) & ^0x3f) == 0 && ((int64(1)<<(_la-109))&35184397516817) != 0) {
		{
			p.SetState(554)
			p.Cqls()
		}

	}
	p.SetState(558)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CQLParserMINUSMINUS {
		{
			p.SetState(557)
			p.Match(CQLParserMINUSMINUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(560)
		p.Match(CQLParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICqlsContext is an interface to support dynamic dispatch.
type ICqlsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllCql() []ICqlContext
	Cql(i int) ICqlContext
	AllEmpty_() []IEmpty_Context
	Empty_(i int) IEmpty_Context
	AllStatementSeparator() []IStatementSeparatorContext
	StatementSeparator(i int) IStatementSeparatorContext
	AllMINUSMINUS() []antlr.TerminalNode
	MINUSMINUS(i int) antlr.TerminalNode

	// IsCqlsContext differentiates from other interfaces.
	IsCqlsContext()
}

type CqlsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCqlsContext() *CqlsContext {
	var p = new(CqlsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_cqls
	return p
}

func InitEmptyCqlsContext(p *CqlsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_cqls
}

func (*CqlsContext) IsCqlsContext() {}

func NewCqlsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CqlsContext {
	var p = new(CqlsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_cqls

	return p
}

func (s *CqlsContext) GetParser() antlr.Parser { return s.parser }

func (s *CqlsContext) AllCql() []ICqlContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICqlContext); ok {
			len++
		}
	}

	tst := make([]ICqlContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICqlContext); ok {
			tst[i] = t.(ICqlContext)
			i++
		}
	}

	return tst
}

func (s *CqlsContext) Cql(i int) ICqlContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICqlContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICqlContext)
}

func (s *CqlsContext) AllEmpty_() []IEmpty_Context {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEmpty_Context); ok {
			len++
		}
	}

	tst := make([]IEmpty_Context, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEmpty_Context); ok {
			tst[i] = t.(IEmpty_Context)
			i++
		}
	}

	return tst
}

func (s *CqlsContext) Empty_(i int) IEmpty_Context {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEmpty_Context); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEmpty_Context)
}

func (s *CqlsContext) AllStatementSeparator() []IStatementSeparatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementSeparatorContext); ok {
			len++
		}
	}

	tst := make([]IStatementSeparatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementSeparatorContext); ok {
			tst[i] = t.(IStatementSeparatorContext)
			i++
		}
	}

	return tst
}

func (s *CqlsContext) StatementSeparator(i int) IStatementSeparatorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementSeparatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementSeparatorContext)
}

func (s *CqlsContext) AllMINUSMINUS() []antlr.TerminalNode {
	return s.GetTokens(CQLParserMINUSMINUS)
}

func (s *CqlsContext) MINUSMINUS(i int) antlr.TerminalNode {
	return s.GetToken(CQLParserMINUSMINUS, i)
}

func (s *CqlsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CqlsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CqlsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterCqls(s)
	}
}

func (s *CqlsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitCqls(s)
	}
}

func (p *CQLParser) Cqls() (localctx ICqlsContext) {
	localctx = NewCqlsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, CQLParserRULE_cqls)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(571)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 4, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(569)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case CQLParserK_ALTER, CQLParserK_APPLY, CQLParserK_BEGIN, CQLParserK_CREATE, CQLParserK_DELETE, CQLParserK_DROP, CQLParserK_GRANT, CQLParserK_INSERT, CQLParserK_REVOKE, CQLParserK_SELECT, CQLParserK_TRUNCATE, CQLParserK_UPDATE, CQLParserK_USE, CQLParserK_LIST:
				{
					p.SetState(562)
					p.Cql()
				}
				p.SetState(564)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == CQLParserMINUSMINUS {
					{
						p.SetState(563)
						p.Match(CQLParserMINUSMINUS)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(566)
					p.StatementSeparator()
				}

			case CQLParserSEMI:
				{
					p.SetState(568)
					p.Empty_()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}
		p.SetState(573)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 4, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(582)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CQLParserK_ALTER, CQLParserK_APPLY, CQLParserK_BEGIN, CQLParserK_CREATE, CQLParserK_DELETE, CQLParserK_DROP, CQLParserK_GRANT, CQLParserK_INSERT, CQLParserK_REVOKE, CQLParserK_SELECT, CQLParserK_TRUNCATE, CQLParserK_UPDATE, CQLParserK_USE, CQLParserK_LIST:
		{
			p.SetState(574)
			p.Cql()
		}
		p.SetState(579)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 6, p.GetParserRuleContext()) == 1 {
			p.SetState(576)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == CQLParserMINUSMINUS {
				{
					p.SetState(575)
					p.Match(CQLParserMINUSMINUS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(578)
				p.StatementSeparator()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case CQLParserSEMI:
		{
			p.SetState(581)
			p.Empty_()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementSeparatorContext is an interface to support dynamic dispatch.
type IStatementSeparatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SEMI() antlr.TerminalNode

	// IsStatementSeparatorContext differentiates from other interfaces.
	IsStatementSeparatorContext()
}

type StatementSeparatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementSeparatorContext() *StatementSeparatorContext {
	var p = new(StatementSeparatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_statementSeparator
	return p
}

func InitEmptyStatementSeparatorContext(p *StatementSeparatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_statementSeparator
}

func (*StatementSeparatorContext) IsStatementSeparatorContext() {}

func NewStatementSeparatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementSeparatorContext {
	var p = new(StatementSeparatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_statementSeparator

	return p
}

func (s *StatementSeparatorContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementSeparatorContext) SEMI() antlr.TerminalNode {
	return s.GetToken(CQLParserSEMI, 0)
}

func (s *StatementSeparatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementSeparatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementSeparatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterStatementSeparator(s)
	}
}

func (s *StatementSeparatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitStatementSeparator(s)
	}
}

func (p *CQLParser) StatementSeparator() (localctx IStatementSeparatorContext) {
	localctx = NewStatementSeparatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, CQLParserRULE_statementSeparator)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(584)
		p.Match(CQLParserSEMI)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEmpty_Context is an interface to support dynamic dispatch.
type IEmpty_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StatementSeparator() IStatementSeparatorContext

	// IsEmpty_Context differentiates from other interfaces.
	IsEmpty_Context()
}

type Empty_Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEmpty_Context() *Empty_Context {
	var p = new(Empty_Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_empty_
	return p
}

func InitEmptyEmpty_Context(p *Empty_Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_empty_
}

func (*Empty_Context) IsEmpty_Context() {}

func NewEmpty_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Empty_Context {
	var p = new(Empty_Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_empty_

	return p
}

func (s *Empty_Context) GetParser() antlr.Parser { return s.parser }

func (s *Empty_Context) StatementSeparator() IStatementSeparatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementSeparatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementSeparatorContext)
}

func (s *Empty_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Empty_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Empty_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterEmpty_(s)
	}
}

func (s *Empty_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitEmpty_(s)
	}
}

func (p *CQLParser) Empty_() (localctx IEmpty_Context) {
	localctx = NewEmpty_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, CQLParserRULE_empty_)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(586)
		p.StatementSeparator()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICqlContext is an interface to support dynamic dispatch.
type ICqlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AlterKeyspace() IAlterKeyspaceContext
	AlterMaterializedView() IAlterMaterializedViewContext
	AlterRole() IAlterRoleContext
	AlterTable() IAlterTableContext
	AlterType() IAlterTypeContext
	AlterUser() IAlterUserContext
	ApplyBatch() IApplyBatchContext
	CreateAggregate() ICreateAggregateContext
	CreateFunction() ICreateFunctionContext
	CreateIndex() ICreateIndexContext
	CreateKeyspace() ICreateKeyspaceContext
	CreateMaterializedView() ICreateMaterializedViewContext
	CreateRole() ICreateRoleContext
	CreateTable() ICreateTableContext
	CreateTrigger() ICreateTriggerContext
	CreateType() ICreateTypeContext
	CreateUser() ICreateUserContext
	Delete_() IDelete_Context
	DropAggregate() IDropAggregateContext
	DropFunction() IDropFunctionContext
	DropIndex() IDropIndexContext
	DropKeyspace() IDropKeyspaceContext
	DropMaterializedView() IDropMaterializedViewContext
	DropRole() IDropRoleContext
	DropTable() IDropTableContext
	DropTrigger() IDropTriggerContext
	DropType() IDropTypeContext
	DropUser() IDropUserContext
	Grant() IGrantContext
	Insert() IInsertContext
	ListPermissions() IListPermissionsContext
	ListRoles() IListRolesContext
	Revoke() IRevokeContext
	Select_() ISelect_Context
	Truncate() ITruncateContext
	Update() IUpdateContext
	Use_() IUse_Context

	// IsCqlContext differentiates from other interfaces.
	IsCqlContext()
}

type CqlContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCqlContext() *CqlContext {
	var p = new(CqlContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_cql
	return p
}

func InitEmptyCqlContext(p *CqlContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_cql
}

func (*CqlContext) IsCqlContext() {}

func NewCqlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CqlContext {
	var p = new(CqlContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_cql

	return p
}

func (s *CqlContext) GetParser() antlr.Parser { return s.parser }

func (s *CqlContext) AlterKeyspace() IAlterKeyspaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterKeyspaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterKeyspaceContext)
}

func (s *CqlContext) AlterMaterializedView() IAlterMaterializedViewContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterMaterializedViewContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterMaterializedViewContext)
}

func (s *CqlContext) AlterRole() IAlterRoleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterRoleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterRoleContext)
}

func (s *CqlContext) AlterTable() IAlterTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterTableContext)
}

func (s *CqlContext) AlterType() IAlterTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterTypeContext)
}

func (s *CqlContext) AlterUser() IAlterUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterUserContext)
}

func (s *CqlContext) ApplyBatch() IApplyBatchContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IApplyBatchContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IApplyBatchContext)
}

func (s *CqlContext) CreateAggregate() ICreateAggregateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateAggregateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateAggregateContext)
}

func (s *CqlContext) CreateFunction() ICreateFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateFunctionContext)
}

func (s *CqlContext) CreateIndex() ICreateIndexContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateIndexContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateIndexContext)
}

func (s *CqlContext) CreateKeyspace() ICreateKeyspaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateKeyspaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateKeyspaceContext)
}

func (s *CqlContext) CreateMaterializedView() ICreateMaterializedViewContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateMaterializedViewContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateMaterializedViewContext)
}

func (s *CqlContext) CreateRole() ICreateRoleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateRoleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateRoleContext)
}

func (s *CqlContext) CreateTable() ICreateTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateTableContext)
}

func (s *CqlContext) CreateTrigger() ICreateTriggerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateTriggerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateTriggerContext)
}

func (s *CqlContext) CreateType() ICreateTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateTypeContext)
}

func (s *CqlContext) CreateUser() ICreateUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateUserContext)
}

func (s *CqlContext) Delete_() IDelete_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDelete_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDelete_Context)
}

func (s *CqlContext) DropAggregate() IDropAggregateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropAggregateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropAggregateContext)
}

func (s *CqlContext) DropFunction() IDropFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropFunctionContext)
}

func (s *CqlContext) DropIndex() IDropIndexContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropIndexContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropIndexContext)
}

func (s *CqlContext) DropKeyspace() IDropKeyspaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropKeyspaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropKeyspaceContext)
}

func (s *CqlContext) DropMaterializedView() IDropMaterializedViewContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropMaterializedViewContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropMaterializedViewContext)
}

func (s *CqlContext) DropRole() IDropRoleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropRoleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropRoleContext)
}

func (s *CqlContext) DropTable() IDropTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropTableContext)
}

func (s *CqlContext) DropTrigger() IDropTriggerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropTriggerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropTriggerContext)
}

func (s *CqlContext) DropType() IDropTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropTypeContext)
}

func (s *CqlContext) DropUser() IDropUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropUserContext)
}

func (s *CqlContext) Grant() IGrantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantContext)
}

func (s *CqlContext) Insert() IInsertContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertContext)
}

func (s *CqlContext) ListPermissions() IListPermissionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListPermissionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListPermissionsContext)
}

func (s *CqlContext) ListRoles() IListRolesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListRolesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListRolesContext)
}

func (s *CqlContext) Revoke() IRevokeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRevokeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRevokeContext)
}

func (s *CqlContext) Select_() ISelect_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelect_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelect_Context)
}

func (s *CqlContext) Truncate() ITruncateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITruncateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITruncateContext)
}

func (s *CqlContext) Update() IUpdateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdateContext)
}

func (s *CqlContext) Use_() IUse_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUse_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUse_Context)
}

func (s *CqlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CqlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CqlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterCql(s)
	}
}

func (s *CqlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitCql(s)
	}
}

func (p *CQLParser) Cql() (localctx ICqlContext) {
	localctx = NewCqlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, CQLParserRULE_cql)
	p.SetState(625)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 8, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(588)
			p.AlterKeyspace()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(589)
			p.AlterMaterializedView()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(590)
			p.AlterRole()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(591)
			p.AlterTable()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(592)
			p.AlterType()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(593)
			p.AlterUser()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(594)
			p.ApplyBatch()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(595)
			p.CreateAggregate()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(596)
			p.CreateFunction()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(597)
			p.CreateIndex()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(598)
			p.CreateKeyspace()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(599)
			p.CreateMaterializedView()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(600)
			p.CreateRole()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(601)
			p.CreateTable()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(602)
			p.CreateTrigger()
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(603)
			p.CreateType()
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(604)
			p.CreateUser()
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(605)
			p.Delete_()
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(606)
			p.DropAggregate()
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(607)
			p.DropFunction()
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(608)
			p.DropIndex()
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(609)
			p.DropKeyspace()
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(610)
			p.DropMaterializedView()
		}

	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(611)
			p.DropRole()
		}

	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(612)
			p.DropTable()
		}

	case 26:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(613)
			p.DropTrigger()
		}

	case 27:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(614)
			p.DropType()
		}

	case 28:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(615)
			p.DropUser()
		}

	case 29:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(616)
			p.Grant()
		}

	case 30:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(617)
			p.Insert()
		}

	case 31:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(618)
			p.ListPermissions()
		}

	case 32:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(619)
			p.ListRoles()
		}

	case 33:
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(620)
			p.Revoke()
		}

	case 34:
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(621)
			p.Select_()
		}

	case 35:
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(622)
			p.Truncate()
		}

	case 36:
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(623)
			p.Update()
		}

	case 37:
		p.EnterOuterAlt(localctx, 37)
		{
			p.SetState(624)
			p.Use_()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRevokeContext is an interface to support dynamic dispatch.
type IRevokeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwRevoke() IKwRevokeContext
	Priviledge() IPriviledgeContext
	KwOn() IKwOnContext
	Resource() IResourceContext
	KwFrom() IKwFromContext
	Role() IRoleContext

	// IsRevokeContext differentiates from other interfaces.
	IsRevokeContext()
}

type RevokeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRevokeContext() *RevokeContext {
	var p = new(RevokeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_revoke
	return p
}

func InitEmptyRevokeContext(p *RevokeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_revoke
}

func (*RevokeContext) IsRevokeContext() {}

func NewRevokeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RevokeContext {
	var p = new(RevokeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_revoke

	return p
}

func (s *RevokeContext) GetParser() antlr.Parser { return s.parser }

func (s *RevokeContext) KwRevoke() IKwRevokeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwRevokeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwRevokeContext)
}

func (s *RevokeContext) Priviledge() IPriviledgeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPriviledgeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPriviledgeContext)
}

func (s *RevokeContext) KwOn() IKwOnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwOnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwOnContext)
}

func (s *RevokeContext) Resource() IResourceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResourceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResourceContext)
}

func (s *RevokeContext) KwFrom() IKwFromContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwFromContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwFromContext)
}

func (s *RevokeContext) Role() IRoleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleContext)
}

func (s *RevokeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RevokeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterRevoke(s)
	}
}

func (s *RevokeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitRevoke(s)
	}
}

func (p *CQLParser) Revoke() (localctx IRevokeContext) {
	localctx = NewRevokeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, CQLParserRULE_revoke)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(627)
		p.KwRevoke()
	}
	{
		p.SetState(628)
		p.Priviledge()
	}
	{
		p.SetState(629)
		p.KwOn()
	}
	{
		p.SetState(630)
		p.Resource()
	}
	{
		p.SetState(631)
		p.KwFrom()
	}
	{
		p.SetState(632)
		p.Role()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IListRolesContext is an interface to support dynamic dispatch.
type IListRolesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwList() IKwListContext
	KwRoles() IKwRolesContext
	KwOf() IKwOfContext
	Role() IRoleContext
	KwNorecursive() IKwNorecursiveContext

	// IsListRolesContext differentiates from other interfaces.
	IsListRolesContext()
}

type ListRolesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyListRolesContext() *ListRolesContext {
	var p = new(ListRolesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_listRoles
	return p
}

func InitEmptyListRolesContext(p *ListRolesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_listRoles
}

func (*ListRolesContext) IsListRolesContext() {}

func NewListRolesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListRolesContext {
	var p = new(ListRolesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_listRoles

	return p
}

func (s *ListRolesContext) GetParser() antlr.Parser { return s.parser }

func (s *ListRolesContext) KwList() IKwListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwListContext)
}

func (s *ListRolesContext) KwRoles() IKwRolesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwRolesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwRolesContext)
}

func (s *ListRolesContext) KwOf() IKwOfContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwOfContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwOfContext)
}

func (s *ListRolesContext) Role() IRoleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleContext)
}

func (s *ListRolesContext) KwNorecursive() IKwNorecursiveContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwNorecursiveContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwNorecursiveContext)
}

func (s *ListRolesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListRolesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListRolesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterListRoles(s)
	}
}

func (s *ListRolesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitListRoles(s)
	}
}

func (p *CQLParser) ListRoles() (localctx IListRolesContext) {
	localctx = NewListRolesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, CQLParserRULE_listRoles)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(634)
		p.KwList()
	}
	{
		p.SetState(635)
		p.KwRoles()
	}
	p.SetState(639)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CQLParserK_OF {
		{
			p.SetState(636)
			p.KwOf()
		}
		{
			p.SetState(637)
			p.Role()
		}

	}
	p.SetState(642)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CQLParserK_NORECURSIVE {
		{
			p.SetState(641)
			p.KwNorecursive()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IListPermissionsContext is an interface to support dynamic dispatch.
type IListPermissionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwList() IKwListContext
	Priviledge() IPriviledgeContext
	KwOn() IKwOnContext
	Resource() IResourceContext
	KwOf() IKwOfContext
	Role() IRoleContext

	// IsListPermissionsContext differentiates from other interfaces.
	IsListPermissionsContext()
}

type ListPermissionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyListPermissionsContext() *ListPermissionsContext {
	var p = new(ListPermissionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_listPermissions
	return p
}

func InitEmptyListPermissionsContext(p *ListPermissionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_listPermissions
}

func (*ListPermissionsContext) IsListPermissionsContext() {}

func NewListPermissionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListPermissionsContext {
	var p = new(ListPermissionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_listPermissions

	return p
}

func (s *ListPermissionsContext) GetParser() antlr.Parser { return s.parser }

func (s *ListPermissionsContext) KwList() IKwListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwListContext)
}

func (s *ListPermissionsContext) Priviledge() IPriviledgeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPriviledgeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPriviledgeContext)
}

func (s *ListPermissionsContext) KwOn() IKwOnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwOnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwOnContext)
}

func (s *ListPermissionsContext) Resource() IResourceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResourceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResourceContext)
}

func (s *ListPermissionsContext) KwOf() IKwOfContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwOfContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwOfContext)
}

func (s *ListPermissionsContext) Role() IRoleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleContext)
}

func (s *ListPermissionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListPermissionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListPermissionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterListPermissions(s)
	}
}

func (s *ListPermissionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitListPermissions(s)
	}
}

func (p *CQLParser) ListPermissions() (localctx IListPermissionsContext) {
	localctx = NewListPermissionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, CQLParserRULE_listPermissions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(644)
		p.KwList()
	}
	{
		p.SetState(645)
		p.Priviledge()
	}
	p.SetState(649)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CQLParserK_ON {
		{
			p.SetState(646)
			p.KwOn()
		}
		{
			p.SetState(647)
			p.Resource()
		}

	}
	p.SetState(654)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CQLParserK_OF {
		{
			p.SetState(651)
			p.KwOf()
		}
		{
			p.SetState(652)
			p.Role()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGrantContext is an interface to support dynamic dispatch.
type IGrantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwGrant() IKwGrantContext
	Priviledge() IPriviledgeContext
	KwOn() IKwOnContext
	Resource() IResourceContext
	KwTo() IKwToContext
	Role() IRoleContext

	// IsGrantContext differentiates from other interfaces.
	IsGrantContext()
}

type GrantContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGrantContext() *GrantContext {
	var p = new(GrantContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_grant
	return p
}

func InitEmptyGrantContext(p *GrantContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_grant
}

func (*GrantContext) IsGrantContext() {}

func NewGrantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GrantContext {
	var p = new(GrantContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_grant

	return p
}

func (s *GrantContext) GetParser() antlr.Parser { return s.parser }

func (s *GrantContext) KwGrant() IKwGrantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwGrantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwGrantContext)
}

func (s *GrantContext) Priviledge() IPriviledgeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPriviledgeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPriviledgeContext)
}

func (s *GrantContext) KwOn() IKwOnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwOnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwOnContext)
}

func (s *GrantContext) Resource() IResourceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResourceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResourceContext)
}

func (s *GrantContext) KwTo() IKwToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwToContext)
}

func (s *GrantContext) Role() IRoleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleContext)
}

func (s *GrantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GrantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterGrant(s)
	}
}

func (s *GrantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitGrant(s)
	}
}

func (p *CQLParser) Grant() (localctx IGrantContext) {
	localctx = NewGrantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, CQLParserRULE_grant)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(656)
		p.KwGrant()
	}
	{
		p.SetState(657)
		p.Priviledge()
	}
	{
		p.SetState(658)
		p.KwOn()
	}
	{
		p.SetState(659)
		p.Resource()
	}
	{
		p.SetState(660)
		p.KwTo()
	}
	{
		p.SetState(661)
		p.Role()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPriviledgeContext is an interface to support dynamic dispatch.
type IPriviledgeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwAll() IKwAllContext
	KwAllPermissions() IKwAllPermissionsContext
	KwAlter() IKwAlterContext
	KwAuthorize() IKwAuthorizeContext
	KwDescibe() IKwDescibeContext
	KwExecute() IKwExecuteContext
	KwCreate() IKwCreateContext
	KwDrop() IKwDropContext
	KwModify() IKwModifyContext
	KwSelect() IKwSelectContext

	// IsPriviledgeContext differentiates from other interfaces.
	IsPriviledgeContext()
}

type PriviledgeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPriviledgeContext() *PriviledgeContext {
	var p = new(PriviledgeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_priviledge
	return p
}

func InitEmptyPriviledgeContext(p *PriviledgeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_priviledge
}

func (*PriviledgeContext) IsPriviledgeContext() {}

func NewPriviledgeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PriviledgeContext {
	var p = new(PriviledgeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_priviledge

	return p
}

func (s *PriviledgeContext) GetParser() antlr.Parser { return s.parser }

func (s *PriviledgeContext) KwAll() IKwAllContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAllContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAllContext)
}

func (s *PriviledgeContext) KwAllPermissions() IKwAllPermissionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAllPermissionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAllPermissionsContext)
}

func (s *PriviledgeContext) KwAlter() IKwAlterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAlterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAlterContext)
}

func (s *PriviledgeContext) KwAuthorize() IKwAuthorizeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAuthorizeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAuthorizeContext)
}

func (s *PriviledgeContext) KwDescibe() IKwDescibeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwDescibeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwDescibeContext)
}

func (s *PriviledgeContext) KwExecute() IKwExecuteContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwExecuteContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwExecuteContext)
}

func (s *PriviledgeContext) KwCreate() IKwCreateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwCreateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwCreateContext)
}

func (s *PriviledgeContext) KwDrop() IKwDropContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwDropContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwDropContext)
}

func (s *PriviledgeContext) KwModify() IKwModifyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwModifyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwModifyContext)
}

func (s *PriviledgeContext) KwSelect() IKwSelectContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwSelectContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwSelectContext)
}

func (s *PriviledgeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PriviledgeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PriviledgeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterPriviledge(s)
	}
}

func (s *PriviledgeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitPriviledge(s)
	}
}

func (p *CQLParser) Priviledge() (localctx IPriviledgeContext) {
	localctx = NewPriviledgeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, CQLParserRULE_priviledge)
	p.SetState(675)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CQLParserK_ALL:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(665)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 13, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(663)
				p.KwAll()
			}

		case 2:
			{
				p.SetState(664)
				p.KwAllPermissions()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case CQLParserK_ALTER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(667)
			p.KwAlter()
		}

	case CQLParserK_AUTHORIZE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(668)
			p.KwAuthorize()
		}

	case CQLParserK_DESCRIBE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(669)
			p.KwDescibe()
		}

	case CQLParserK_EXECUTE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(670)
			p.KwExecute()
		}

	case CQLParserK_CREATE:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(671)
			p.KwCreate()
		}

	case CQLParserK_DROP:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(672)
			p.KwDrop()
		}

	case CQLParserK_MODIFY:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(673)
			p.KwModify()
		}

	case CQLParserK_SELECT:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(674)
			p.KwSelect()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResourceContext is an interface to support dynamic dispatch.
type IResourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwAll() IKwAllContext
	KwFunctions() IKwFunctionsContext
	KwIn() IKwInContext
	KwKeyspace() IKwKeyspaceContext
	Keyspace() IKeyspaceContext
	KwFunction() IKwFunctionContext
	Function_() IFunction_Context
	DOT() antlr.TerminalNode
	KwKeyspaces() IKwKeyspacesContext
	Table() ITableContext
	KwTable() IKwTableContext
	KwRoles() IKwRolesContext
	KwRole() IKwRoleContext
	Role() IRoleContext

	// IsResourceContext differentiates from other interfaces.
	IsResourceContext()
}

type ResourceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResourceContext() *ResourceContext {
	var p = new(ResourceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_resource
	return p
}

func InitEmptyResourceContext(p *ResourceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_resource
}

func (*ResourceContext) IsResourceContext() {}

func NewResourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResourceContext {
	var p = new(ResourceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_resource

	return p
}

func (s *ResourceContext) GetParser() antlr.Parser { return s.parser }

func (s *ResourceContext) KwAll() IKwAllContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAllContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAllContext)
}

func (s *ResourceContext) KwFunctions() IKwFunctionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwFunctionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwFunctionsContext)
}

func (s *ResourceContext) KwIn() IKwInContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwInContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwInContext)
}

func (s *ResourceContext) KwKeyspace() IKwKeyspaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwKeyspaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwKeyspaceContext)
}

func (s *ResourceContext) Keyspace() IKeyspaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyspaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyspaceContext)
}

func (s *ResourceContext) KwFunction() IKwFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwFunctionContext)
}

func (s *ResourceContext) Function_() IFunction_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunction_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunction_Context)
}

func (s *ResourceContext) DOT() antlr.TerminalNode {
	return s.GetToken(CQLParserDOT, 0)
}

func (s *ResourceContext) KwKeyspaces() IKwKeyspacesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwKeyspacesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwKeyspacesContext)
}

func (s *ResourceContext) Table() ITableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableContext)
}

func (s *ResourceContext) KwTable() IKwTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwTableContext)
}

func (s *ResourceContext) KwRoles() IKwRolesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwRolesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwRolesContext)
}

func (s *ResourceContext) KwRole() IKwRoleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwRoleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwRoleContext)
}

func (s *ResourceContext) Role() IRoleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleContext)
}

func (s *ResourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterResource(s)
	}
}

func (s *ResourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitResource(s)
	}
}

func (p *CQLParser) Resource() (localctx IResourceContext) {
	localctx = NewResourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, CQLParserRULE_resource)
	var _la int

	p.SetState(715)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 18, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(677)
			p.KwAll()
		}
		{
			p.SetState(678)
			p.KwFunctions()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(680)
			p.KwAll()
		}
		{
			p.SetState(681)
			p.KwFunctions()
		}
		{
			p.SetState(682)
			p.KwIn()
		}
		{
			p.SetState(683)
			p.KwKeyspace()
		}
		{
			p.SetState(684)
			p.Keyspace()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(686)
			p.KwFunction()
		}
		p.SetState(690)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 15, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(687)
				p.Keyspace()
			}
			{
				p.SetState(688)
				p.Match(CQLParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(692)
			p.Function_()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(694)
			p.KwAll()
		}
		{
			p.SetState(695)
			p.KwKeyspaces()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(697)
			p.KwKeyspace()
		}
		{
			p.SetState(698)
			p.Keyspace()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		p.SetState(701)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CQLParserK_TABLE {
			{
				p.SetState(700)
				p.KwTable()
			}

		}
		p.SetState(706)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 17, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(703)
				p.Keyspace()
			}
			{
				p.SetState(704)
				p.Match(CQLParserDOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(708)
			p.Table()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(709)
			p.KwAll()
		}
		{
			p.SetState(710)
			p.KwRoles()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(712)
			p.KwRole()
		}
		{
			p.SetState(713)
			p.Role()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateUserContext is an interface to support dynamic dispatch.
type ICreateUserContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwCreate() IKwCreateContext
	KwUser() IKwUserContext
	User() IUserContext
	KwWith() IKwWithContext
	KwPassword() IKwPasswordContext
	StringLiteral() IStringLiteralContext
	IfNotExist() IIfNotExistContext
	KwSuperuser() IKwSuperuserContext
	KwNosuperuser() IKwNosuperuserContext

	// IsCreateUserContext differentiates from other interfaces.
	IsCreateUserContext()
}

type CreateUserContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateUserContext() *CreateUserContext {
	var p = new(CreateUserContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_createUser
	return p
}

func InitEmptyCreateUserContext(p *CreateUserContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_createUser
}

func (*CreateUserContext) IsCreateUserContext() {}

func NewCreateUserContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateUserContext {
	var p = new(CreateUserContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_createUser

	return p
}

func (s *CreateUserContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateUserContext) KwCreate() IKwCreateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwCreateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwCreateContext)
}

func (s *CreateUserContext) KwUser() IKwUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwUserContext)
}

func (s *CreateUserContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *CreateUserContext) KwWith() IKwWithContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwWithContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwWithContext)
}

func (s *CreateUserContext) KwPassword() IKwPasswordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwPasswordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwPasswordContext)
}

func (s *CreateUserContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *CreateUserContext) IfNotExist() IIfNotExistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistContext)
}

func (s *CreateUserContext) KwSuperuser() IKwSuperuserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwSuperuserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwSuperuserContext)
}

func (s *CreateUserContext) KwNosuperuser() IKwNosuperuserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwNosuperuserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwNosuperuserContext)
}

func (s *CreateUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateUserContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterCreateUser(s)
	}
}

func (s *CreateUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitCreateUser(s)
	}
}

func (p *CQLParser) CreateUser() (localctx ICreateUserContext) {
	localctx = NewCreateUserContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, CQLParserRULE_createUser)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(717)
		p.KwCreate()
	}
	{
		p.SetState(718)
		p.KwUser()
	}
	p.SetState(720)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CQLParserK_IF {
		{
			p.SetState(719)
			p.IfNotExist()
		}

	}
	{
		p.SetState(722)
		p.User()
	}
	{
		p.SetState(723)
		p.KwWith()
	}
	{
		p.SetState(724)
		p.KwPassword()
	}
	{
		p.SetState(725)
		p.StringLiteral()
	}
	p.SetState(728)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case CQLParserK_SUPERUSER:
		{
			p.SetState(726)
			p.KwSuperuser()
		}

	case CQLParserK_NOSUPERUSER:
		{
			p.SetState(727)
			p.KwNosuperuser()
		}

	case CQLParserEOF, CQLParserSEMI, CQLParserMINUSMINUS:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateRoleContext is an interface to support dynamic dispatch.
type ICreateRoleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwCreate() IKwCreateContext
	KwRole() IKwRoleContext
	Role() IRoleContext
	IfNotExist() IIfNotExistContext
	RoleWith() IRoleWithContext

	// IsCreateRoleContext differentiates from other interfaces.
	IsCreateRoleContext()
}

type CreateRoleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateRoleContext() *CreateRoleContext {
	var p = new(CreateRoleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_createRole
	return p
}

func InitEmptyCreateRoleContext(p *CreateRoleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_createRole
}

func (*CreateRoleContext) IsCreateRoleContext() {}

func NewCreateRoleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateRoleContext {
	var p = new(CreateRoleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_createRole

	return p
}

func (s *CreateRoleContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateRoleContext) KwCreate() IKwCreateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwCreateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwCreateContext)
}

func (s *CreateRoleContext) KwRole() IKwRoleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwRoleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwRoleContext)
}

func (s *CreateRoleContext) Role() IRoleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleContext)
}

func (s *CreateRoleContext) IfNotExist() IIfNotExistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistContext)
}

func (s *CreateRoleContext) RoleWith() IRoleWithContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleWithContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleWithContext)
}

func (s *CreateRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateRoleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateRoleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterCreateRole(s)
	}
}

func (s *CreateRoleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitCreateRole(s)
	}
}

func (p *CQLParser) CreateRole() (localctx ICreateRoleContext) {
	localctx = NewCreateRoleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, CQLParserRULE_createRole)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(730)
		p.KwCreate()
	}
	{
		p.SetState(731)
		p.KwRole()
	}
	p.SetState(733)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CQLParserK_IF {
		{
			p.SetState(732)
			p.IfNotExist()
		}

	}
	{
		p.SetState(735)
		p.Role()
	}
	p.SetState(737)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CQLParserK_WITH {
		{
			p.SetState(736)
			p.RoleWith()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateTypeContext is an interface to support dynamic dispatch.
type ICreateTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwCreate() IKwCreateContext
	KwType() IKwTypeContext
	Type_() IType_Context
	SyntaxBracketLr() ISyntaxBracketLrContext
	TypeMemberColumnList() ITypeMemberColumnListContext
	SyntaxBracketRr() ISyntaxBracketRrContext
	IfNotExist() IIfNotExistContext
	Keyspace() IKeyspaceContext
	DOT() antlr.TerminalNode

	// IsCreateTypeContext differentiates from other interfaces.
	IsCreateTypeContext()
}

type CreateTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateTypeContext() *CreateTypeContext {
	var p = new(CreateTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_createType
	return p
}

func InitEmptyCreateTypeContext(p *CreateTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_createType
}

func (*CreateTypeContext) IsCreateTypeContext() {}

func NewCreateTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateTypeContext {
	var p = new(CreateTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_createType

	return p
}

func (s *CreateTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateTypeContext) KwCreate() IKwCreateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwCreateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwCreateContext)
}

func (s *CreateTypeContext) KwType() IKwTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwTypeContext)
}

func (s *CreateTypeContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *CreateTypeContext) SyntaxBracketLr() ISyntaxBracketLrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketLrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketLrContext)
}

func (s *CreateTypeContext) TypeMemberColumnList() ITypeMemberColumnListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeMemberColumnListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeMemberColumnListContext)
}

func (s *CreateTypeContext) SyntaxBracketRr() ISyntaxBracketRrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketRrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketRrContext)
}

func (s *CreateTypeContext) IfNotExist() IIfNotExistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistContext)
}

func (s *CreateTypeContext) Keyspace() IKeyspaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyspaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyspaceContext)
}

func (s *CreateTypeContext) DOT() antlr.TerminalNode {
	return s.GetToken(CQLParserDOT, 0)
}

func (s *CreateTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterCreateType(s)
	}
}

func (s *CreateTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitCreateType(s)
	}
}

func (p *CQLParser) CreateType() (localctx ICreateTypeContext) {
	localctx = NewCreateTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, CQLParserRULE_createType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(739)
		p.KwCreate()
	}
	{
		p.SetState(740)
		p.KwType()
	}
	p.SetState(742)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CQLParserK_IF {
		{
			p.SetState(741)
			p.IfNotExist()
		}

	}
	p.SetState(747)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 24, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(744)
			p.Keyspace()
		}
		{
			p.SetState(745)
			p.Match(CQLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(749)
		p.Type_()
	}
	{
		p.SetState(750)
		p.SyntaxBracketLr()
	}
	{
		p.SetState(751)
		p.TypeMemberColumnList()
	}
	{
		p.SetState(752)
		p.SyntaxBracketRr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeMemberColumnListContext is an interface to support dynamic dispatch.
type ITypeMemberColumnListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllColumn() []IColumnContext
	Column(i int) IColumnContext
	AllDataType() []IDataTypeContext
	DataType(i int) IDataTypeContext
	AllSyntaxComma() []ISyntaxCommaContext
	SyntaxComma(i int) ISyntaxCommaContext

	// IsTypeMemberColumnListContext differentiates from other interfaces.
	IsTypeMemberColumnListContext()
}

type TypeMemberColumnListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeMemberColumnListContext() *TypeMemberColumnListContext {
	var p = new(TypeMemberColumnListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_typeMemberColumnList
	return p
}

func InitEmptyTypeMemberColumnListContext(p *TypeMemberColumnListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_typeMemberColumnList
}

func (*TypeMemberColumnListContext) IsTypeMemberColumnListContext() {}

func NewTypeMemberColumnListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeMemberColumnListContext {
	var p = new(TypeMemberColumnListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_typeMemberColumnList

	return p
}

func (s *TypeMemberColumnListContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeMemberColumnListContext) AllColumn() []IColumnContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnContext); ok {
			len++
		}
	}

	tst := make([]IColumnContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnContext); ok {
			tst[i] = t.(IColumnContext)
			i++
		}
	}

	return tst
}

func (s *TypeMemberColumnListContext) Column(i int) IColumnContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnContext)
}

func (s *TypeMemberColumnListContext) AllDataType() []IDataTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataTypeContext); ok {
			len++
		}
	}

	tst := make([]IDataTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataTypeContext); ok {
			tst[i] = t.(IDataTypeContext)
			i++
		}
	}

	return tst
}

func (s *TypeMemberColumnListContext) DataType(i int) IDataTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *TypeMemberColumnListContext) AllSyntaxComma() []ISyntaxCommaContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			len++
		}
	}

	tst := make([]ISyntaxCommaContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISyntaxCommaContext); ok {
			tst[i] = t.(ISyntaxCommaContext)
			i++
		}
	}

	return tst
}

func (s *TypeMemberColumnListContext) SyntaxComma(i int) ISyntaxCommaContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxCommaContext)
}

func (s *TypeMemberColumnListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeMemberColumnListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeMemberColumnListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterTypeMemberColumnList(s)
	}
}

func (s *TypeMemberColumnListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitTypeMemberColumnList(s)
	}
}

func (p *CQLParser) TypeMemberColumnList() (localctx ITypeMemberColumnListContext) {
	localctx = NewTypeMemberColumnListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, CQLParserRULE_typeMemberColumnList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(754)
		p.Column()
	}
	{
		p.SetState(755)
		p.DataType()
	}
	p.SetState(762)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CQLParserCOMMA {
		{
			p.SetState(756)
			p.SyntaxComma()
		}
		{
			p.SetState(757)
			p.Column()
		}
		{
			p.SetState(758)
			p.DataType()
		}

		p.SetState(764)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateTriggerContext is an interface to support dynamic dispatch.
type ICreateTriggerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwCreate() IKwCreateContext
	KwTrigger() IKwTriggerContext
	Trigger() ITriggerContext
	KwUsing() IKwUsingContext
	TriggerClass() ITriggerClassContext
	IfNotExist() IIfNotExistContext
	Keyspace() IKeyspaceContext
	DOT() antlr.TerminalNode

	// IsCreateTriggerContext differentiates from other interfaces.
	IsCreateTriggerContext()
}

type CreateTriggerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateTriggerContext() *CreateTriggerContext {
	var p = new(CreateTriggerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_createTrigger
	return p
}

func InitEmptyCreateTriggerContext(p *CreateTriggerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_createTrigger
}

func (*CreateTriggerContext) IsCreateTriggerContext() {}

func NewCreateTriggerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateTriggerContext {
	var p = new(CreateTriggerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_createTrigger

	return p
}

func (s *CreateTriggerContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateTriggerContext) KwCreate() IKwCreateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwCreateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwCreateContext)
}

func (s *CreateTriggerContext) KwTrigger() IKwTriggerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwTriggerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwTriggerContext)
}

func (s *CreateTriggerContext) Trigger() ITriggerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITriggerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITriggerContext)
}

func (s *CreateTriggerContext) KwUsing() IKwUsingContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwUsingContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwUsingContext)
}

func (s *CreateTriggerContext) TriggerClass() ITriggerClassContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITriggerClassContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITriggerClassContext)
}

func (s *CreateTriggerContext) IfNotExist() IIfNotExistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistContext)
}

func (s *CreateTriggerContext) Keyspace() IKeyspaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyspaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyspaceContext)
}

func (s *CreateTriggerContext) DOT() antlr.TerminalNode {
	return s.GetToken(CQLParserDOT, 0)
}

func (s *CreateTriggerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTriggerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateTriggerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterCreateTrigger(s)
	}
}

func (s *CreateTriggerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitCreateTrigger(s)
	}
}

func (p *CQLParser) CreateTrigger() (localctx ICreateTriggerContext) {
	localctx = NewCreateTriggerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, CQLParserRULE_createTrigger)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(765)
		p.KwCreate()
	}
	{
		p.SetState(766)
		p.KwTrigger()
	}
	p.SetState(768)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CQLParserK_IF {
		{
			p.SetState(767)
			p.IfNotExist()
		}

	}
	p.SetState(773)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 27, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(770)
			p.Keyspace()
		}
		{
			p.SetState(771)
			p.Match(CQLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(775)
		p.Trigger()
	}
	{
		p.SetState(776)
		p.KwUsing()
	}
	{
		p.SetState(777)
		p.TriggerClass()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateMaterializedViewContext is an interface to support dynamic dispatch.
type ICreateMaterializedViewContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwCreate() IKwCreateContext
	KwMaterialized() IKwMaterializedContext
	KwView() IKwViewContext
	MaterializedView() IMaterializedViewContext
	KwAs() IKwAsContext
	KwSelect() IKwSelectContext
	AllColumnList() []IColumnListContext
	ColumnList(i int) IColumnListContext
	KwFrom() IKwFromContext
	Table() ITableContext
	MaterializedViewWhere() IMaterializedViewWhereContext
	KwPrimary() IKwPrimaryContext
	KwKey() IKwKeyContext
	SyntaxBracketLr() ISyntaxBracketLrContext
	SyntaxBracketRr() ISyntaxBracketRrContext
	IfNotExist() IIfNotExistContext
	AllKeyspace() []IKeyspaceContext
	Keyspace(i int) IKeyspaceContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode
	KwWith() IKwWithContext
	MaterializedViewOptions() IMaterializedViewOptionsContext

	// IsCreateMaterializedViewContext differentiates from other interfaces.
	IsCreateMaterializedViewContext()
}

type CreateMaterializedViewContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateMaterializedViewContext() *CreateMaterializedViewContext {
	var p = new(CreateMaterializedViewContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_createMaterializedView
	return p
}

func InitEmptyCreateMaterializedViewContext(p *CreateMaterializedViewContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_createMaterializedView
}

func (*CreateMaterializedViewContext) IsCreateMaterializedViewContext() {}

func NewCreateMaterializedViewContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateMaterializedViewContext {
	var p = new(CreateMaterializedViewContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_createMaterializedView

	return p
}

func (s *CreateMaterializedViewContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateMaterializedViewContext) KwCreate() IKwCreateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwCreateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwCreateContext)
}

func (s *CreateMaterializedViewContext) KwMaterialized() IKwMaterializedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwMaterializedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwMaterializedContext)
}

func (s *CreateMaterializedViewContext) KwView() IKwViewContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwViewContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwViewContext)
}

func (s *CreateMaterializedViewContext) MaterializedView() IMaterializedViewContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMaterializedViewContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMaterializedViewContext)
}

func (s *CreateMaterializedViewContext) KwAs() IKwAsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAsContext)
}

func (s *CreateMaterializedViewContext) KwSelect() IKwSelectContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwSelectContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwSelectContext)
}

func (s *CreateMaterializedViewContext) AllColumnList() []IColumnListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnListContext); ok {
			len++
		}
	}

	tst := make([]IColumnListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnListContext); ok {
			tst[i] = t.(IColumnListContext)
			i++
		}
	}

	return tst
}

func (s *CreateMaterializedViewContext) ColumnList(i int) IColumnListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnListContext)
}

func (s *CreateMaterializedViewContext) KwFrom() IKwFromContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwFromContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwFromContext)
}

func (s *CreateMaterializedViewContext) Table() ITableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableContext)
}

func (s *CreateMaterializedViewContext) MaterializedViewWhere() IMaterializedViewWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMaterializedViewWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMaterializedViewWhereContext)
}

func (s *CreateMaterializedViewContext) KwPrimary() IKwPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwPrimaryContext)
}

func (s *CreateMaterializedViewContext) KwKey() IKwKeyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwKeyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwKeyContext)
}

func (s *CreateMaterializedViewContext) SyntaxBracketLr() ISyntaxBracketLrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketLrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketLrContext)
}

func (s *CreateMaterializedViewContext) SyntaxBracketRr() ISyntaxBracketRrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketRrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketRrContext)
}

func (s *CreateMaterializedViewContext) IfNotExist() IIfNotExistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistContext)
}

func (s *CreateMaterializedViewContext) AllKeyspace() []IKeyspaceContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IKeyspaceContext); ok {
			len++
		}
	}

	tst := make([]IKeyspaceContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IKeyspaceContext); ok {
			tst[i] = t.(IKeyspaceContext)
			i++
		}
	}

	return tst
}

func (s *CreateMaterializedViewContext) Keyspace(i int) IKeyspaceContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyspaceContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyspaceContext)
}

func (s *CreateMaterializedViewContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(CQLParserDOT)
}

func (s *CreateMaterializedViewContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(CQLParserDOT, i)
}

func (s *CreateMaterializedViewContext) KwWith() IKwWithContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwWithContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwWithContext)
}

func (s *CreateMaterializedViewContext) MaterializedViewOptions() IMaterializedViewOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMaterializedViewOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMaterializedViewOptionsContext)
}

func (s *CreateMaterializedViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateMaterializedViewContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateMaterializedViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterCreateMaterializedView(s)
	}
}

func (s *CreateMaterializedViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitCreateMaterializedView(s)
	}
}

func (p *CQLParser) CreateMaterializedView() (localctx ICreateMaterializedViewContext) {
	localctx = NewCreateMaterializedViewContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, CQLParserRULE_createMaterializedView)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(779)
		p.KwCreate()
	}
	{
		p.SetState(780)
		p.KwMaterialized()
	}
	{
		p.SetState(781)
		p.KwView()
	}
	p.SetState(783)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CQLParserK_IF {
		{
			p.SetState(782)
			p.IfNotExist()
		}

	}
	p.SetState(788)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 29, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(785)
			p.Keyspace()
		}
		{
			p.SetState(786)
			p.Match(CQLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(790)
		p.MaterializedView()
	}
	{
		p.SetState(791)
		p.KwAs()
	}
	{
		p.SetState(792)
		p.KwSelect()
	}
	{
		p.SetState(793)
		p.ColumnList()
	}
	{
		p.SetState(794)
		p.KwFrom()
	}
	p.SetState(798)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 30, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(795)
			p.Keyspace()
		}
		{
			p.SetState(796)
			p.Match(CQLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(800)
		p.Table()
	}
	{
		p.SetState(801)
		p.MaterializedViewWhere()
	}
	{
		p.SetState(802)
		p.KwPrimary()
	}
	{
		p.SetState(803)
		p.KwKey()
	}
	{
		p.SetState(804)
		p.SyntaxBracketLr()
	}
	{
		p.SetState(805)
		p.ColumnList()
	}
	{
		p.SetState(806)
		p.SyntaxBracketRr()
	}
	p.SetState(810)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CQLParserK_WITH {
		{
			p.SetState(807)
			p.KwWith()
		}
		{
			p.SetState(808)
			p.MaterializedViewOptions()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMaterializedViewWhereContext is an interface to support dynamic dispatch.
type IMaterializedViewWhereContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwWhere() IKwWhereContext
	ColumnNotNullList() IColumnNotNullListContext
	KwAnd() IKwAndContext
	RelationElements() IRelationElementsContext

	// IsMaterializedViewWhereContext differentiates from other interfaces.
	IsMaterializedViewWhereContext()
}

type MaterializedViewWhereContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMaterializedViewWhereContext() *MaterializedViewWhereContext {
	var p = new(MaterializedViewWhereContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_materializedViewWhere
	return p
}

func InitEmptyMaterializedViewWhereContext(p *MaterializedViewWhereContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_materializedViewWhere
}

func (*MaterializedViewWhereContext) IsMaterializedViewWhereContext() {}

func NewMaterializedViewWhereContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MaterializedViewWhereContext {
	var p = new(MaterializedViewWhereContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_materializedViewWhere

	return p
}

func (s *MaterializedViewWhereContext) GetParser() antlr.Parser { return s.parser }

func (s *MaterializedViewWhereContext) KwWhere() IKwWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwWhereContext)
}

func (s *MaterializedViewWhereContext) ColumnNotNullList() IColumnNotNullListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNotNullListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNotNullListContext)
}

func (s *MaterializedViewWhereContext) KwAnd() IKwAndContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAndContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAndContext)
}

func (s *MaterializedViewWhereContext) RelationElements() IRelationElementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationElementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationElementsContext)
}

func (s *MaterializedViewWhereContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MaterializedViewWhereContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MaterializedViewWhereContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterMaterializedViewWhere(s)
	}
}

func (s *MaterializedViewWhereContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitMaterializedViewWhere(s)
	}
}

func (p *CQLParser) MaterializedViewWhere() (localctx IMaterializedViewWhereContext) {
	localctx = NewMaterializedViewWhereContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, CQLParserRULE_materializedViewWhere)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(812)
		p.KwWhere()
	}
	{
		p.SetState(813)
		p.ColumnNotNullList()
	}
	p.SetState(817)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CQLParserK_AND {
		{
			p.SetState(814)
			p.KwAnd()
		}
		{
			p.SetState(815)
			p.RelationElements()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnNotNullListContext is an interface to support dynamic dispatch.
type IColumnNotNullListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllColumnNotNull() []IColumnNotNullContext
	ColumnNotNull(i int) IColumnNotNullContext
	AllKwAnd() []IKwAndContext
	KwAnd(i int) IKwAndContext

	// IsColumnNotNullListContext differentiates from other interfaces.
	IsColumnNotNullListContext()
}

type ColumnNotNullListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnNotNullListContext() *ColumnNotNullListContext {
	var p = new(ColumnNotNullListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_columnNotNullList
	return p
}

func InitEmptyColumnNotNullListContext(p *ColumnNotNullListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_columnNotNullList
}

func (*ColumnNotNullListContext) IsColumnNotNullListContext() {}

func NewColumnNotNullListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnNotNullListContext {
	var p = new(ColumnNotNullListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_columnNotNullList

	return p
}

func (s *ColumnNotNullListContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnNotNullListContext) AllColumnNotNull() []IColumnNotNullContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnNotNullContext); ok {
			len++
		}
	}

	tst := make([]IColumnNotNullContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnNotNullContext); ok {
			tst[i] = t.(IColumnNotNullContext)
			i++
		}
	}

	return tst
}

func (s *ColumnNotNullListContext) ColumnNotNull(i int) IColumnNotNullContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNotNullContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNotNullContext)
}

func (s *ColumnNotNullListContext) AllKwAnd() []IKwAndContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IKwAndContext); ok {
			len++
		}
	}

	tst := make([]IKwAndContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IKwAndContext); ok {
			tst[i] = t.(IKwAndContext)
			i++
		}
	}

	return tst
}

func (s *ColumnNotNullListContext) KwAnd(i int) IKwAndContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAndContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAndContext)
}

func (s *ColumnNotNullListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnNotNullListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnNotNullListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterColumnNotNullList(s)
	}
}

func (s *ColumnNotNullListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitColumnNotNullList(s)
	}
}

func (p *CQLParser) ColumnNotNullList() (localctx IColumnNotNullListContext) {
	localctx = NewColumnNotNullListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, CQLParserRULE_columnNotNullList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(819)
		p.ColumnNotNull()
	}
	p.SetState(825)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 33, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(820)
				p.KwAnd()
			}
			{
				p.SetState(821)
				p.ColumnNotNull()
			}

		}
		p.SetState(827)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 33, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnNotNullContext is an interface to support dynamic dispatch.
type IColumnNotNullContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Column() IColumnContext
	KwIs() IKwIsContext
	KwNot() IKwNotContext
	KwNull() IKwNullContext

	// IsColumnNotNullContext differentiates from other interfaces.
	IsColumnNotNullContext()
}

type ColumnNotNullContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnNotNullContext() *ColumnNotNullContext {
	var p = new(ColumnNotNullContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_columnNotNull
	return p
}

func InitEmptyColumnNotNullContext(p *ColumnNotNullContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_columnNotNull
}

func (*ColumnNotNullContext) IsColumnNotNullContext() {}

func NewColumnNotNullContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnNotNullContext {
	var p = new(ColumnNotNullContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_columnNotNull

	return p
}

func (s *ColumnNotNullContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnNotNullContext) Column() IColumnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnContext)
}

func (s *ColumnNotNullContext) KwIs() IKwIsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwIsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwIsContext)
}

func (s *ColumnNotNullContext) KwNot() IKwNotContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwNotContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwNotContext)
}

func (s *ColumnNotNullContext) KwNull() IKwNullContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwNullContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwNullContext)
}

func (s *ColumnNotNullContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnNotNullContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnNotNullContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterColumnNotNull(s)
	}
}

func (s *ColumnNotNullContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitColumnNotNull(s)
	}
}

func (p *CQLParser) ColumnNotNull() (localctx IColumnNotNullContext) {
	localctx = NewColumnNotNullContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, CQLParserRULE_columnNotNull)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(828)
		p.Column()
	}
	{
		p.SetState(829)
		p.KwIs()
	}
	{
		p.SetState(830)
		p.KwNot()
	}
	{
		p.SetState(831)
		p.KwNull()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMaterializedViewOptionsContext is an interface to support dynamic dispatch.
type IMaterializedViewOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TableOptions() ITableOptionsContext
	KwAnd() IKwAndContext
	ClusteringOrder() IClusteringOrderContext

	// IsMaterializedViewOptionsContext differentiates from other interfaces.
	IsMaterializedViewOptionsContext()
}

type MaterializedViewOptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMaterializedViewOptionsContext() *MaterializedViewOptionsContext {
	var p = new(MaterializedViewOptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_materializedViewOptions
	return p
}

func InitEmptyMaterializedViewOptionsContext(p *MaterializedViewOptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_materializedViewOptions
}

func (*MaterializedViewOptionsContext) IsMaterializedViewOptionsContext() {}

func NewMaterializedViewOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MaterializedViewOptionsContext {
	var p = new(MaterializedViewOptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_materializedViewOptions

	return p
}

func (s *MaterializedViewOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *MaterializedViewOptionsContext) TableOptions() ITableOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableOptionsContext)
}

func (s *MaterializedViewOptionsContext) KwAnd() IKwAndContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAndContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAndContext)
}

func (s *MaterializedViewOptionsContext) ClusteringOrder() IClusteringOrderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClusteringOrderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClusteringOrderContext)
}

func (s *MaterializedViewOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MaterializedViewOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MaterializedViewOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterMaterializedViewOptions(s)
	}
}

func (s *MaterializedViewOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitMaterializedViewOptions(s)
	}
}

func (p *CQLParser) MaterializedViewOptions() (localctx IMaterializedViewOptionsContext) {
	localctx = NewMaterializedViewOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, CQLParserRULE_materializedViewOptions)
	p.SetState(839)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 34, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(833)
			p.TableOptions()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(834)
			p.TableOptions()
		}
		{
			p.SetState(835)
			p.KwAnd()
		}
		{
			p.SetState(836)
			p.ClusteringOrder()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(838)
			p.ClusteringOrder()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateKeyspaceContext is an interface to support dynamic dispatch.
type ICreateKeyspaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwCreate() IKwCreateContext
	KwKeyspace() IKwKeyspaceContext
	Keyspace() IKeyspaceContext
	KwWith() IKwWithContext
	KwReplication() IKwReplicationContext
	OPERATOR_EQ() antlr.TerminalNode
	SyntaxBracketLc() ISyntaxBracketLcContext
	ReplicationList() IReplicationListContext
	SyntaxBracketRc() ISyntaxBracketRcContext
	IfNotExist() IIfNotExistContext
	KwAnd() IKwAndContext
	DurableWrites() IDurableWritesContext

	// IsCreateKeyspaceContext differentiates from other interfaces.
	IsCreateKeyspaceContext()
}

type CreateKeyspaceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateKeyspaceContext() *CreateKeyspaceContext {
	var p = new(CreateKeyspaceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_createKeyspace
	return p
}

func InitEmptyCreateKeyspaceContext(p *CreateKeyspaceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_createKeyspace
}

func (*CreateKeyspaceContext) IsCreateKeyspaceContext() {}

func NewCreateKeyspaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateKeyspaceContext {
	var p = new(CreateKeyspaceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_createKeyspace

	return p
}

func (s *CreateKeyspaceContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateKeyspaceContext) KwCreate() IKwCreateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwCreateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwCreateContext)
}

func (s *CreateKeyspaceContext) KwKeyspace() IKwKeyspaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwKeyspaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwKeyspaceContext)
}

func (s *CreateKeyspaceContext) Keyspace() IKeyspaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyspaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyspaceContext)
}

func (s *CreateKeyspaceContext) KwWith() IKwWithContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwWithContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwWithContext)
}

func (s *CreateKeyspaceContext) KwReplication() IKwReplicationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwReplicationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwReplicationContext)
}

func (s *CreateKeyspaceContext) OPERATOR_EQ() antlr.TerminalNode {
	return s.GetToken(CQLParserOPERATOR_EQ, 0)
}

func (s *CreateKeyspaceContext) SyntaxBracketLc() ISyntaxBracketLcContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketLcContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketLcContext)
}

func (s *CreateKeyspaceContext) ReplicationList() IReplicationListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplicationListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplicationListContext)
}

func (s *CreateKeyspaceContext) SyntaxBracketRc() ISyntaxBracketRcContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketRcContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketRcContext)
}

func (s *CreateKeyspaceContext) IfNotExist() IIfNotExistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistContext)
}

func (s *CreateKeyspaceContext) KwAnd() IKwAndContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAndContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAndContext)
}

func (s *CreateKeyspaceContext) DurableWrites() IDurableWritesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDurableWritesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDurableWritesContext)
}

func (s *CreateKeyspaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateKeyspaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateKeyspaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterCreateKeyspace(s)
	}
}

func (s *CreateKeyspaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitCreateKeyspace(s)
	}
}

func (p *CQLParser) CreateKeyspace() (localctx ICreateKeyspaceContext) {
	localctx = NewCreateKeyspaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, CQLParserRULE_createKeyspace)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(841)
		p.KwCreate()
	}
	{
		p.SetState(842)
		p.KwKeyspace()
	}
	p.SetState(844)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CQLParserK_IF {
		{
			p.SetState(843)
			p.IfNotExist()
		}

	}
	{
		p.SetState(846)
		p.Keyspace()
	}
	{
		p.SetState(847)
		p.KwWith()
	}
	{
		p.SetState(848)
		p.KwReplication()
	}
	{
		p.SetState(849)
		p.Match(CQLParserOPERATOR_EQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(850)
		p.SyntaxBracketLc()
	}
	{
		p.SetState(851)
		p.ReplicationList()
	}
	{
		p.SetState(852)
		p.SyntaxBracketRc()
	}
	p.SetState(856)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CQLParserK_AND {
		{
			p.SetState(853)
			p.KwAnd()
		}
		{
			p.SetState(854)
			p.DurableWrites()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateFunctionContext is an interface to support dynamic dispatch.
type ICreateFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwCreate() IKwCreateContext
	KwFunction() IKwFunctionContext
	Function_() IFunction_Context
	SyntaxBracketLr() ISyntaxBracketLrContext
	SyntaxBracketRr() ISyntaxBracketRrContext
	ReturnMode() IReturnModeContext
	KwReturns() IKwReturnsContext
	DataType() IDataTypeContext
	KwLanguage() IKwLanguageContext
	Language() ILanguageContext
	KwAs() IKwAsContext
	CodeBlock() ICodeBlockContext
	OrReplace() IOrReplaceContext
	IfNotExist() IIfNotExistContext
	Keyspace() IKeyspaceContext
	DOT() antlr.TerminalNode
	ParamList() IParamListContext

	// IsCreateFunctionContext differentiates from other interfaces.
	IsCreateFunctionContext()
}

type CreateFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateFunctionContext() *CreateFunctionContext {
	var p = new(CreateFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_createFunction
	return p
}

func InitEmptyCreateFunctionContext(p *CreateFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_createFunction
}

func (*CreateFunctionContext) IsCreateFunctionContext() {}

func NewCreateFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateFunctionContext {
	var p = new(CreateFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_createFunction

	return p
}

func (s *CreateFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateFunctionContext) KwCreate() IKwCreateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwCreateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwCreateContext)
}

func (s *CreateFunctionContext) KwFunction() IKwFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwFunctionContext)
}

func (s *CreateFunctionContext) Function_() IFunction_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunction_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunction_Context)
}

func (s *CreateFunctionContext) SyntaxBracketLr() ISyntaxBracketLrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketLrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketLrContext)
}

func (s *CreateFunctionContext) SyntaxBracketRr() ISyntaxBracketRrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketRrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketRrContext)
}

func (s *CreateFunctionContext) ReturnMode() IReturnModeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnModeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnModeContext)
}

func (s *CreateFunctionContext) KwReturns() IKwReturnsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwReturnsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwReturnsContext)
}

func (s *CreateFunctionContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *CreateFunctionContext) KwLanguage() IKwLanguageContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwLanguageContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwLanguageContext)
}

func (s *CreateFunctionContext) Language() ILanguageContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILanguageContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILanguageContext)
}

func (s *CreateFunctionContext) KwAs() IKwAsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAsContext)
}

func (s *CreateFunctionContext) CodeBlock() ICodeBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *CreateFunctionContext) OrReplace() IOrReplaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrReplaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrReplaceContext)
}

func (s *CreateFunctionContext) IfNotExist() IIfNotExistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistContext)
}

func (s *CreateFunctionContext) Keyspace() IKeyspaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyspaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyspaceContext)
}

func (s *CreateFunctionContext) DOT() antlr.TerminalNode {
	return s.GetToken(CQLParserDOT, 0)
}

func (s *CreateFunctionContext) ParamList() IParamListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParamListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParamListContext)
}

func (s *CreateFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterCreateFunction(s)
	}
}

func (s *CreateFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitCreateFunction(s)
	}
}

func (p *CQLParser) CreateFunction() (localctx ICreateFunctionContext) {
	localctx = NewCreateFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, CQLParserRULE_createFunction)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(858)
		p.KwCreate()
	}
	p.SetState(860)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CQLParserK_OR {
		{
			p.SetState(859)
			p.OrReplace()
		}

	}
	{
		p.SetState(862)
		p.KwFunction()
	}
	p.SetState(864)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CQLParserK_IF {
		{
			p.SetState(863)
			p.IfNotExist()
		}

	}
	p.SetState(869)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 39, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(866)
			p.Keyspace()
		}
		{
			p.SetState(867)
			p.Match(CQLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(871)
		p.Function_()
	}
	{
		p.SetState(872)
		p.SyntaxBracketLr()
	}
	p.SetState(874)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CQLParserK_INPUT || _la == CQLParserOBJECT_NAME {
		{
			p.SetState(873)
			p.ParamList()
		}

	}
	{
		p.SetState(876)
		p.SyntaxBracketRr()
	}
	{
		p.SetState(877)
		p.ReturnMode()
	}
	{
		p.SetState(878)
		p.KwReturns()
	}
	{
		p.SetState(879)
		p.DataType()
	}
	{
		p.SetState(880)
		p.KwLanguage()
	}
	{
		p.SetState(881)
		p.Language()
	}
	{
		p.SetState(882)
		p.KwAs()
	}
	{
		p.SetState(883)
		p.CodeBlock()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICodeBlockContext is an interface to support dynamic dispatch.
type ICodeBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CODE_BLOCK() antlr.TerminalNode
	STRING_LITERAL() antlr.TerminalNode

	// IsCodeBlockContext differentiates from other interfaces.
	IsCodeBlockContext()
}

type CodeBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCodeBlockContext() *CodeBlockContext {
	var p = new(CodeBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_codeBlock
	return p
}

func InitEmptyCodeBlockContext(p *CodeBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_codeBlock
}

func (*CodeBlockContext) IsCodeBlockContext() {}

func NewCodeBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CodeBlockContext {
	var p = new(CodeBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_codeBlock

	return p
}

func (s *CodeBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *CodeBlockContext) CODE_BLOCK() antlr.TerminalNode {
	return s.GetToken(CQLParserCODE_BLOCK, 0)
}

func (s *CodeBlockContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(CQLParserSTRING_LITERAL, 0)
}

func (s *CodeBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CodeBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CodeBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterCodeBlock(s)
	}
}

func (s *CodeBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitCodeBlock(s)
	}
}

func (p *CQLParser) CodeBlock() (localctx ICodeBlockContext) {
	localctx = NewCodeBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, CQLParserRULE_codeBlock)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(885)
		_la = p.GetTokenStream().LA(1)

		if !(_la == CQLParserCODE_BLOCK || _la == CQLParserSTRING_LITERAL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParamListContext is an interface to support dynamic dispatch.
type IParamListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllParam() []IParamContext
	Param(i int) IParamContext
	AllSyntaxComma() []ISyntaxCommaContext
	SyntaxComma(i int) ISyntaxCommaContext

	// IsParamListContext differentiates from other interfaces.
	IsParamListContext()
}

type ParamListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParamListContext() *ParamListContext {
	var p = new(ParamListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_paramList
	return p
}

func InitEmptyParamListContext(p *ParamListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_paramList
}

func (*ParamListContext) IsParamListContext() {}

func NewParamListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParamListContext {
	var p = new(ParamListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_paramList

	return p
}

func (s *ParamListContext) GetParser() antlr.Parser { return s.parser }

func (s *ParamListContext) AllParam() []IParamContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IParamContext); ok {
			len++
		}
	}

	tst := make([]IParamContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IParamContext); ok {
			tst[i] = t.(IParamContext)
			i++
		}
	}

	return tst
}

func (s *ParamListContext) Param(i int) IParamContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParamContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParamContext)
}

func (s *ParamListContext) AllSyntaxComma() []ISyntaxCommaContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			len++
		}
	}

	tst := make([]ISyntaxCommaContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISyntaxCommaContext); ok {
			tst[i] = t.(ISyntaxCommaContext)
			i++
		}
	}

	return tst
}

func (s *ParamListContext) SyntaxComma(i int) ISyntaxCommaContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxCommaContext)
}

func (s *ParamListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParamListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParamListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterParamList(s)
	}
}

func (s *ParamListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitParamList(s)
	}
}

func (p *CQLParser) ParamList() (localctx IParamListContext) {
	localctx = NewParamListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, CQLParserRULE_paramList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(887)
		p.Param()
	}
	p.SetState(893)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CQLParserCOMMA {
		{
			p.SetState(888)
			p.SyntaxComma()
		}
		{
			p.SetState(889)
			p.Param()
		}

		p.SetState(895)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReturnModeContext is an interface to support dynamic dispatch.
type IReturnModeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwOn() IKwOnContext
	AllKwNull() []IKwNullContext
	KwNull(i int) IKwNullContext
	KwInput() IKwInputContext
	KwCalled() IKwCalledContext
	KwReturns() IKwReturnsContext

	// IsReturnModeContext differentiates from other interfaces.
	IsReturnModeContext()
}

type ReturnModeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnModeContext() *ReturnModeContext {
	var p = new(ReturnModeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_returnMode
	return p
}

func InitEmptyReturnModeContext(p *ReturnModeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_returnMode
}

func (*ReturnModeContext) IsReturnModeContext() {}

func NewReturnModeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnModeContext {
	var p = new(ReturnModeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_returnMode

	return p
}

func (s *ReturnModeContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnModeContext) KwOn() IKwOnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwOnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwOnContext)
}

func (s *ReturnModeContext) AllKwNull() []IKwNullContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IKwNullContext); ok {
			len++
		}
	}

	tst := make([]IKwNullContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IKwNullContext); ok {
			tst[i] = t.(IKwNullContext)
			i++
		}
	}

	return tst
}

func (s *ReturnModeContext) KwNull(i int) IKwNullContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwNullContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwNullContext)
}

func (s *ReturnModeContext) KwInput() IKwInputContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwInputContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwInputContext)
}

func (s *ReturnModeContext) KwCalled() IKwCalledContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwCalledContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwCalledContext)
}

func (s *ReturnModeContext) KwReturns() IKwReturnsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwReturnsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwReturnsContext)
}

func (s *ReturnModeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnModeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnModeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterReturnMode(s)
	}
}

func (s *ReturnModeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitReturnMode(s)
	}
}

func (p *CQLParser) ReturnMode() (localctx IReturnModeContext) {
	localctx = NewReturnModeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, CQLParserRULE_returnMode)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(900)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CQLParserK_CALLED:
		{
			p.SetState(896)
			p.KwCalled()
		}

	case CQLParserK_RETURNS:
		{
			p.SetState(897)
			p.KwReturns()
		}
		{
			p.SetState(898)
			p.KwNull()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(902)
		p.KwOn()
	}
	{
		p.SetState(903)
		p.KwNull()
	}
	{
		p.SetState(904)
		p.KwInput()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateAggregateContext is an interface to support dynamic dispatch.
type ICreateAggregateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwCreate() IKwCreateContext
	KwAggregate() IKwAggregateContext
	Aggregate() IAggregateContext
	SyntaxBracketLr() ISyntaxBracketLrContext
	AllDataType() []IDataTypeContext
	DataType(i int) IDataTypeContext
	SyntaxBracketRr() ISyntaxBracketRrContext
	KwSfunc() IKwSfuncContext
	AllFunction_() []IFunction_Context
	Function_(i int) IFunction_Context
	KwStype() IKwStypeContext
	KwFinalfunc() IKwFinalfuncContext
	KwInitcond() IKwInitcondContext
	InitCondDefinition() IInitCondDefinitionContext
	OrReplace() IOrReplaceContext
	IfNotExist() IIfNotExistContext
	Keyspace() IKeyspaceContext
	DOT() antlr.TerminalNode

	// IsCreateAggregateContext differentiates from other interfaces.
	IsCreateAggregateContext()
}

type CreateAggregateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateAggregateContext() *CreateAggregateContext {
	var p = new(CreateAggregateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_createAggregate
	return p
}

func InitEmptyCreateAggregateContext(p *CreateAggregateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_createAggregate
}

func (*CreateAggregateContext) IsCreateAggregateContext() {}

func NewCreateAggregateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateAggregateContext {
	var p = new(CreateAggregateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_createAggregate

	return p
}

func (s *CreateAggregateContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateAggregateContext) KwCreate() IKwCreateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwCreateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwCreateContext)
}

func (s *CreateAggregateContext) KwAggregate() IKwAggregateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAggregateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAggregateContext)
}

func (s *CreateAggregateContext) Aggregate() IAggregateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAggregateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAggregateContext)
}

func (s *CreateAggregateContext) SyntaxBracketLr() ISyntaxBracketLrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketLrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketLrContext)
}

func (s *CreateAggregateContext) AllDataType() []IDataTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataTypeContext); ok {
			len++
		}
	}

	tst := make([]IDataTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataTypeContext); ok {
			tst[i] = t.(IDataTypeContext)
			i++
		}
	}

	return tst
}

func (s *CreateAggregateContext) DataType(i int) IDataTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *CreateAggregateContext) SyntaxBracketRr() ISyntaxBracketRrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketRrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketRrContext)
}

func (s *CreateAggregateContext) KwSfunc() IKwSfuncContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwSfuncContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwSfuncContext)
}

func (s *CreateAggregateContext) AllFunction_() []IFunction_Context {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFunction_Context); ok {
			len++
		}
	}

	tst := make([]IFunction_Context, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFunction_Context); ok {
			tst[i] = t.(IFunction_Context)
			i++
		}
	}

	return tst
}

func (s *CreateAggregateContext) Function_(i int) IFunction_Context {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunction_Context); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunction_Context)
}

func (s *CreateAggregateContext) KwStype() IKwStypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwStypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwStypeContext)
}

func (s *CreateAggregateContext) KwFinalfunc() IKwFinalfuncContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwFinalfuncContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwFinalfuncContext)
}

func (s *CreateAggregateContext) KwInitcond() IKwInitcondContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwInitcondContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwInitcondContext)
}

func (s *CreateAggregateContext) InitCondDefinition() IInitCondDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInitCondDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInitCondDefinitionContext)
}

func (s *CreateAggregateContext) OrReplace() IOrReplaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrReplaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrReplaceContext)
}

func (s *CreateAggregateContext) IfNotExist() IIfNotExistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistContext)
}

func (s *CreateAggregateContext) Keyspace() IKeyspaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyspaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyspaceContext)
}

func (s *CreateAggregateContext) DOT() antlr.TerminalNode {
	return s.GetToken(CQLParserDOT, 0)
}

func (s *CreateAggregateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateAggregateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateAggregateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterCreateAggregate(s)
	}
}

func (s *CreateAggregateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitCreateAggregate(s)
	}
}

func (p *CQLParser) CreateAggregate() (localctx ICreateAggregateContext) {
	localctx = NewCreateAggregateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, CQLParserRULE_createAggregate)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(906)
		p.KwCreate()
	}
	p.SetState(908)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CQLParserK_OR {
		{
			p.SetState(907)
			p.OrReplace()
		}

	}
	{
		p.SetState(910)
		p.KwAggregate()
	}
	p.SetState(912)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CQLParserK_IF {
		{
			p.SetState(911)
			p.IfNotExist()
		}

	}
	p.SetState(917)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 45, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(914)
			p.Keyspace()
		}
		{
			p.SetState(915)
			p.Match(CQLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(919)
		p.Aggregate()
	}
	{
		p.SetState(920)
		p.SyntaxBracketLr()
	}
	{
		p.SetState(921)
		p.DataType()
	}
	{
		p.SetState(922)
		p.SyntaxBracketRr()
	}
	{
		p.SetState(923)
		p.KwSfunc()
	}
	{
		p.SetState(924)
		p.Function_()
	}
	{
		p.SetState(925)
		p.KwStype()
	}
	{
		p.SetState(926)
		p.DataType()
	}
	{
		p.SetState(927)
		p.KwFinalfunc()
	}
	{
		p.SetState(928)
		p.Function_()
	}
	{
		p.SetState(929)
		p.KwInitcond()
	}
	{
		p.SetState(930)
		p.InitCondDefinition()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInitCondDefinitionContext is an interface to support dynamic dispatch.
type IInitCondDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Constant() IConstantContext
	InitCondList() IInitCondListContext
	InitCondListNested() IInitCondListNestedContext
	InitCondHash() IInitCondHashContext

	// IsInitCondDefinitionContext differentiates from other interfaces.
	IsInitCondDefinitionContext()
}

type InitCondDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitCondDefinitionContext() *InitCondDefinitionContext {
	var p = new(InitCondDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_initCondDefinition
	return p
}

func InitEmptyInitCondDefinitionContext(p *InitCondDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_initCondDefinition
}

func (*InitCondDefinitionContext) IsInitCondDefinitionContext() {}

func NewInitCondDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InitCondDefinitionContext {
	var p = new(InitCondDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_initCondDefinition

	return p
}

func (s *InitCondDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *InitCondDefinitionContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *InitCondDefinitionContext) InitCondList() IInitCondListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInitCondListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInitCondListContext)
}

func (s *InitCondDefinitionContext) InitCondListNested() IInitCondListNestedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInitCondListNestedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInitCondListNestedContext)
}

func (s *InitCondDefinitionContext) InitCondHash() IInitCondHashContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInitCondHashContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInitCondHashContext)
}

func (s *InitCondDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InitCondDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InitCondDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterInitCondDefinition(s)
	}
}

func (s *InitCondDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitInitCondDefinition(s)
	}
}

func (p *CQLParser) InitCondDefinition() (localctx IInitCondDefinitionContext) {
	localctx = NewInitCondDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, CQLParserRULE_initCondDefinition)
	p.SetState(936)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 46, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(932)
			p.Constant()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(933)
			p.InitCondList()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(934)
			p.InitCondListNested()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(935)
			p.InitCondHash()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInitCondHashContext is an interface to support dynamic dispatch.
type IInitCondHashContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SyntaxBracketLc() ISyntaxBracketLcContext
	AllInitCondHashItem() []IInitCondHashItemContext
	InitCondHashItem(i int) IInitCondHashItemContext
	SyntaxBracketRc() ISyntaxBracketRcContext
	AllSyntaxComma() []ISyntaxCommaContext
	SyntaxComma(i int) ISyntaxCommaContext

	// IsInitCondHashContext differentiates from other interfaces.
	IsInitCondHashContext()
}

type InitCondHashContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitCondHashContext() *InitCondHashContext {
	var p = new(InitCondHashContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_initCondHash
	return p
}

func InitEmptyInitCondHashContext(p *InitCondHashContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_initCondHash
}

func (*InitCondHashContext) IsInitCondHashContext() {}

func NewInitCondHashContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InitCondHashContext {
	var p = new(InitCondHashContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_initCondHash

	return p
}

func (s *InitCondHashContext) GetParser() antlr.Parser { return s.parser }

func (s *InitCondHashContext) SyntaxBracketLc() ISyntaxBracketLcContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketLcContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketLcContext)
}

func (s *InitCondHashContext) AllInitCondHashItem() []IInitCondHashItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInitCondHashItemContext); ok {
			len++
		}
	}

	tst := make([]IInitCondHashItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInitCondHashItemContext); ok {
			tst[i] = t.(IInitCondHashItemContext)
			i++
		}
	}

	return tst
}

func (s *InitCondHashContext) InitCondHashItem(i int) IInitCondHashItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInitCondHashItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInitCondHashItemContext)
}

func (s *InitCondHashContext) SyntaxBracketRc() ISyntaxBracketRcContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketRcContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketRcContext)
}

func (s *InitCondHashContext) AllSyntaxComma() []ISyntaxCommaContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			len++
		}
	}

	tst := make([]ISyntaxCommaContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISyntaxCommaContext); ok {
			tst[i] = t.(ISyntaxCommaContext)
			i++
		}
	}

	return tst
}

func (s *InitCondHashContext) SyntaxComma(i int) ISyntaxCommaContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxCommaContext)
}

func (s *InitCondHashContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InitCondHashContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InitCondHashContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterInitCondHash(s)
	}
}

func (s *InitCondHashContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitInitCondHash(s)
	}
}

func (p *CQLParser) InitCondHash() (localctx IInitCondHashContext) {
	localctx = NewInitCondHashContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, CQLParserRULE_initCondHash)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(938)
		p.SyntaxBracketLc()
	}
	{
		p.SetState(939)
		p.InitCondHashItem()
	}
	p.SetState(945)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CQLParserCOMMA {
		{
			p.SetState(940)
			p.SyntaxComma()
		}
		{
			p.SetState(941)
			p.InitCondHashItem()
		}

		p.SetState(947)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(948)
		p.SyntaxBracketRc()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInitCondHashItemContext is an interface to support dynamic dispatch.
type IInitCondHashItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HashKey() IHashKeyContext
	COLON() antlr.TerminalNode
	InitCondDefinition() IInitCondDefinitionContext

	// IsInitCondHashItemContext differentiates from other interfaces.
	IsInitCondHashItemContext()
}

type InitCondHashItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitCondHashItemContext() *InitCondHashItemContext {
	var p = new(InitCondHashItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_initCondHashItem
	return p
}

func InitEmptyInitCondHashItemContext(p *InitCondHashItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_initCondHashItem
}

func (*InitCondHashItemContext) IsInitCondHashItemContext() {}

func NewInitCondHashItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InitCondHashItemContext {
	var p = new(InitCondHashItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_initCondHashItem

	return p
}

func (s *InitCondHashItemContext) GetParser() antlr.Parser { return s.parser }

func (s *InitCondHashItemContext) HashKey() IHashKeyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHashKeyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHashKeyContext)
}

func (s *InitCondHashItemContext) COLON() antlr.TerminalNode {
	return s.GetToken(CQLParserCOLON, 0)
}

func (s *InitCondHashItemContext) InitCondDefinition() IInitCondDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInitCondDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInitCondDefinitionContext)
}

func (s *InitCondHashItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InitCondHashItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InitCondHashItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterInitCondHashItem(s)
	}
}

func (s *InitCondHashItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitInitCondHashItem(s)
	}
}

func (p *CQLParser) InitCondHashItem() (localctx IInitCondHashItemContext) {
	localctx = NewInitCondHashItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, CQLParserRULE_initCondHashItem)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(950)
		p.HashKey()
	}
	{
		p.SetState(951)
		p.Match(CQLParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(952)
		p.InitCondDefinition()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInitCondListNestedContext is an interface to support dynamic dispatch.
type IInitCondListNestedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SyntaxBracketLr() ISyntaxBracketLrContext
	AllInitCondList() []IInitCondListContext
	InitCondList(i int) IInitCondListContext
	SyntaxBracketRr() ISyntaxBracketRrContext
	AllSyntaxComma() []ISyntaxCommaContext
	SyntaxComma(i int) ISyntaxCommaContext
	AllConstant() []IConstantContext
	Constant(i int) IConstantContext

	// IsInitCondListNestedContext differentiates from other interfaces.
	IsInitCondListNestedContext()
}

type InitCondListNestedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitCondListNestedContext() *InitCondListNestedContext {
	var p = new(InitCondListNestedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_initCondListNested
	return p
}

func InitEmptyInitCondListNestedContext(p *InitCondListNestedContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_initCondListNested
}

func (*InitCondListNestedContext) IsInitCondListNestedContext() {}

func NewInitCondListNestedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InitCondListNestedContext {
	var p = new(InitCondListNestedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_initCondListNested

	return p
}

func (s *InitCondListNestedContext) GetParser() antlr.Parser { return s.parser }

func (s *InitCondListNestedContext) SyntaxBracketLr() ISyntaxBracketLrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketLrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketLrContext)
}

func (s *InitCondListNestedContext) AllInitCondList() []IInitCondListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInitCondListContext); ok {
			len++
		}
	}

	tst := make([]IInitCondListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInitCondListContext); ok {
			tst[i] = t.(IInitCondListContext)
			i++
		}
	}

	return tst
}

func (s *InitCondListNestedContext) InitCondList(i int) IInitCondListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInitCondListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInitCondListContext)
}

func (s *InitCondListNestedContext) SyntaxBracketRr() ISyntaxBracketRrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketRrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketRrContext)
}

func (s *InitCondListNestedContext) AllSyntaxComma() []ISyntaxCommaContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			len++
		}
	}

	tst := make([]ISyntaxCommaContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISyntaxCommaContext); ok {
			tst[i] = t.(ISyntaxCommaContext)
			i++
		}
	}

	return tst
}

func (s *InitCondListNestedContext) SyntaxComma(i int) ISyntaxCommaContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxCommaContext)
}

func (s *InitCondListNestedContext) AllConstant() []IConstantContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantContext); ok {
			len++
		}
	}

	tst := make([]IConstantContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantContext); ok {
			tst[i] = t.(IConstantContext)
			i++
		}
	}

	return tst
}

func (s *InitCondListNestedContext) Constant(i int) IConstantContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *InitCondListNestedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InitCondListNestedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InitCondListNestedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterInitCondListNested(s)
	}
}

func (s *InitCondListNestedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitInitCondListNested(s)
	}
}

func (p *CQLParser) InitCondListNested() (localctx IInitCondListNestedContext) {
	localctx = NewInitCondListNestedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, CQLParserRULE_initCondListNested)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(954)
		p.SyntaxBracketLr()
	}
	{
		p.SetState(955)
		p.InitCondList()
	}
	p.SetState(962)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CQLParserLR_BRACKET || _la == CQLParserCOMMA {
		p.SetState(960)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case CQLParserCOMMA:
			{
				p.SetState(956)
				p.SyntaxComma()
			}
			{
				p.SetState(957)
				p.Constant()
			}

		case CQLParserLR_BRACKET:
			{
				p.SetState(959)
				p.InitCondList()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(964)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(965)
		p.SyntaxBracketRr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInitCondListContext is an interface to support dynamic dispatch.
type IInitCondListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SyntaxBracketLr() ISyntaxBracketLrContext
	AllConstant() []IConstantContext
	Constant(i int) IConstantContext
	SyntaxBracketRr() ISyntaxBracketRrContext
	AllSyntaxComma() []ISyntaxCommaContext
	SyntaxComma(i int) ISyntaxCommaContext

	// IsInitCondListContext differentiates from other interfaces.
	IsInitCondListContext()
}

type InitCondListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitCondListContext() *InitCondListContext {
	var p = new(InitCondListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_initCondList
	return p
}

func InitEmptyInitCondListContext(p *InitCondListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_initCondList
}

func (*InitCondListContext) IsInitCondListContext() {}

func NewInitCondListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InitCondListContext {
	var p = new(InitCondListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_initCondList

	return p
}

func (s *InitCondListContext) GetParser() antlr.Parser { return s.parser }

func (s *InitCondListContext) SyntaxBracketLr() ISyntaxBracketLrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketLrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketLrContext)
}

func (s *InitCondListContext) AllConstant() []IConstantContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantContext); ok {
			len++
		}
	}

	tst := make([]IConstantContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantContext); ok {
			tst[i] = t.(IConstantContext)
			i++
		}
	}

	return tst
}

func (s *InitCondListContext) Constant(i int) IConstantContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *InitCondListContext) SyntaxBracketRr() ISyntaxBracketRrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketRrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketRrContext)
}

func (s *InitCondListContext) AllSyntaxComma() []ISyntaxCommaContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			len++
		}
	}

	tst := make([]ISyntaxCommaContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISyntaxCommaContext); ok {
			tst[i] = t.(ISyntaxCommaContext)
			i++
		}
	}

	return tst
}

func (s *InitCondListContext) SyntaxComma(i int) ISyntaxCommaContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxCommaContext)
}

func (s *InitCondListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InitCondListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InitCondListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterInitCondList(s)
	}
}

func (s *InitCondListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitInitCondList(s)
	}
}

func (p *CQLParser) InitCondList() (localctx IInitCondListContext) {
	localctx = NewInitCondListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, CQLParserRULE_initCondList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(967)
		p.SyntaxBracketLr()
	}
	{
		p.SetState(968)
		p.Constant()
	}
	p.SetState(974)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CQLParserCOMMA {
		{
			p.SetState(969)
			p.SyntaxComma()
		}
		{
			p.SetState(970)
			p.Constant()
		}

		p.SetState(976)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(977)
		p.SyntaxBracketRr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOrReplaceContext is an interface to support dynamic dispatch.
type IOrReplaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwOr() IKwOrContext
	KwReplace() IKwReplaceContext

	// IsOrReplaceContext differentiates from other interfaces.
	IsOrReplaceContext()
}

type OrReplaceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrReplaceContext() *OrReplaceContext {
	var p = new(OrReplaceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_orReplace
	return p
}

func InitEmptyOrReplaceContext(p *OrReplaceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_orReplace
}

func (*OrReplaceContext) IsOrReplaceContext() {}

func NewOrReplaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrReplaceContext {
	var p = new(OrReplaceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_orReplace

	return p
}

func (s *OrReplaceContext) GetParser() antlr.Parser { return s.parser }

func (s *OrReplaceContext) KwOr() IKwOrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwOrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwOrContext)
}

func (s *OrReplaceContext) KwReplace() IKwReplaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwReplaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwReplaceContext)
}

func (s *OrReplaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrReplaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrReplaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterOrReplace(s)
	}
}

func (s *OrReplaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitOrReplace(s)
	}
}

func (p *CQLParser) OrReplace() (localctx IOrReplaceContext) {
	localctx = NewOrReplaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, CQLParserRULE_orReplace)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(979)
		p.KwOr()
	}
	{
		p.SetState(980)
		p.KwReplace()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterUserContext is an interface to support dynamic dispatch.
type IAlterUserContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwAlter() IKwAlterContext
	KwUser() IKwUserContext
	User() IUserContext
	KwWith() IKwWithContext
	UserPassword() IUserPasswordContext
	UserSuperUser() IUserSuperUserContext

	// IsAlterUserContext differentiates from other interfaces.
	IsAlterUserContext()
}

type AlterUserContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterUserContext() *AlterUserContext {
	var p = new(AlterUserContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_alterUser
	return p
}

func InitEmptyAlterUserContext(p *AlterUserContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_alterUser
}

func (*AlterUserContext) IsAlterUserContext() {}

func NewAlterUserContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterUserContext {
	var p = new(AlterUserContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_alterUser

	return p
}

func (s *AlterUserContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterUserContext) KwAlter() IKwAlterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAlterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAlterContext)
}

func (s *AlterUserContext) KwUser() IKwUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwUserContext)
}

func (s *AlterUserContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *AlterUserContext) KwWith() IKwWithContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwWithContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwWithContext)
}

func (s *AlterUserContext) UserPassword() IUserPasswordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserPasswordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserPasswordContext)
}

func (s *AlterUserContext) UserSuperUser() IUserSuperUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserSuperUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserSuperUserContext)
}

func (s *AlterUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterUserContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterAlterUser(s)
	}
}

func (s *AlterUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitAlterUser(s)
	}
}

func (p *CQLParser) AlterUser() (localctx IAlterUserContext) {
	localctx = NewAlterUserContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, CQLParserRULE_alterUser)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(982)
		p.KwAlter()
	}
	{
		p.SetState(983)
		p.KwUser()
	}
	{
		p.SetState(984)
		p.User()
	}
	{
		p.SetState(985)
		p.KwWith()
	}
	{
		p.SetState(986)
		p.UserPassword()
	}
	p.SetState(988)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CQLParserK_NOSUPERUSER || _la == CQLParserK_SUPERUSER {
		{
			p.SetState(987)
			p.UserSuperUser()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUserPasswordContext is an interface to support dynamic dispatch.
type IUserPasswordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwPassword() IKwPasswordContext
	StringLiteral() IStringLiteralContext

	// IsUserPasswordContext differentiates from other interfaces.
	IsUserPasswordContext()
}

type UserPasswordContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUserPasswordContext() *UserPasswordContext {
	var p = new(UserPasswordContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_userPassword
	return p
}

func InitEmptyUserPasswordContext(p *UserPasswordContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_userPassword
}

func (*UserPasswordContext) IsUserPasswordContext() {}

func NewUserPasswordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserPasswordContext {
	var p = new(UserPasswordContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_userPassword

	return p
}

func (s *UserPasswordContext) GetParser() antlr.Parser { return s.parser }

func (s *UserPasswordContext) KwPassword() IKwPasswordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwPasswordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwPasswordContext)
}

func (s *UserPasswordContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *UserPasswordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserPasswordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UserPasswordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterUserPassword(s)
	}
}

func (s *UserPasswordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitUserPassword(s)
	}
}

func (p *CQLParser) UserPassword() (localctx IUserPasswordContext) {
	localctx = NewUserPasswordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, CQLParserRULE_userPassword)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(990)
		p.KwPassword()
	}
	{
		p.SetState(991)
		p.StringLiteral()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUserSuperUserContext is an interface to support dynamic dispatch.
type IUserSuperUserContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwSuperuser() IKwSuperuserContext
	KwNosuperuser() IKwNosuperuserContext

	// IsUserSuperUserContext differentiates from other interfaces.
	IsUserSuperUserContext()
}

type UserSuperUserContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUserSuperUserContext() *UserSuperUserContext {
	var p = new(UserSuperUserContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_userSuperUser
	return p
}

func InitEmptyUserSuperUserContext(p *UserSuperUserContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_userSuperUser
}

func (*UserSuperUserContext) IsUserSuperUserContext() {}

func NewUserSuperUserContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserSuperUserContext {
	var p = new(UserSuperUserContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_userSuperUser

	return p
}

func (s *UserSuperUserContext) GetParser() antlr.Parser { return s.parser }

func (s *UserSuperUserContext) KwSuperuser() IKwSuperuserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwSuperuserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwSuperuserContext)
}

func (s *UserSuperUserContext) KwNosuperuser() IKwNosuperuserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwNosuperuserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwNosuperuserContext)
}

func (s *UserSuperUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserSuperUserContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UserSuperUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterUserSuperUser(s)
	}
}

func (s *UserSuperUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitUserSuperUser(s)
	}
}

func (p *CQLParser) UserSuperUser() (localctx IUserSuperUserContext) {
	localctx = NewUserSuperUserContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, CQLParserRULE_userSuperUser)
	p.SetState(995)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CQLParserK_SUPERUSER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(993)
			p.KwSuperuser()
		}

	case CQLParserK_NOSUPERUSER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(994)
			p.KwNosuperuser()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterTypeContext is an interface to support dynamic dispatch.
type IAlterTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwAlter() IKwAlterContext
	KwType() IKwTypeContext
	Type_() IType_Context
	AlterTypeOperation() IAlterTypeOperationContext
	Keyspace() IKeyspaceContext
	DOT() antlr.TerminalNode

	// IsAlterTypeContext differentiates from other interfaces.
	IsAlterTypeContext()
}

type AlterTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterTypeContext() *AlterTypeContext {
	var p = new(AlterTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_alterType
	return p
}

func InitEmptyAlterTypeContext(p *AlterTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_alterType
}

func (*AlterTypeContext) IsAlterTypeContext() {}

func NewAlterTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterTypeContext {
	var p = new(AlterTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_alterType

	return p
}

func (s *AlterTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterTypeContext) KwAlter() IKwAlterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAlterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAlterContext)
}

func (s *AlterTypeContext) KwType() IKwTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwTypeContext)
}

func (s *AlterTypeContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *AlterTypeContext) AlterTypeOperation() IAlterTypeOperationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterTypeOperationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterTypeOperationContext)
}

func (s *AlterTypeContext) Keyspace() IKeyspaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyspaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyspaceContext)
}

func (s *AlterTypeContext) DOT() antlr.TerminalNode {
	return s.GetToken(CQLParserDOT, 0)
}

func (s *AlterTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterAlterType(s)
	}
}

func (s *AlterTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitAlterType(s)
	}
}

func (p *CQLParser) AlterType() (localctx IAlterTypeContext) {
	localctx = NewAlterTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, CQLParserRULE_alterType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(997)
		p.KwAlter()
	}
	{
		p.SetState(998)
		p.KwType()
	}
	p.SetState(1002)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 53, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(999)
			p.Keyspace()
		}
		{
			p.SetState(1000)
			p.Match(CQLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1004)
		p.Type_()
	}
	{
		p.SetState(1005)
		p.AlterTypeOperation()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterTypeOperationContext is an interface to support dynamic dispatch.
type IAlterTypeOperationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AlterTypeAlterType() IAlterTypeAlterTypeContext
	AlterTypeAdd() IAlterTypeAddContext
	AlterTypeRename() IAlterTypeRenameContext

	// IsAlterTypeOperationContext differentiates from other interfaces.
	IsAlterTypeOperationContext()
}

type AlterTypeOperationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterTypeOperationContext() *AlterTypeOperationContext {
	var p = new(AlterTypeOperationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_alterTypeOperation
	return p
}

func InitEmptyAlterTypeOperationContext(p *AlterTypeOperationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_alterTypeOperation
}

func (*AlterTypeOperationContext) IsAlterTypeOperationContext() {}

func NewAlterTypeOperationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterTypeOperationContext {
	var p = new(AlterTypeOperationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_alterTypeOperation

	return p
}

func (s *AlterTypeOperationContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterTypeOperationContext) AlterTypeAlterType() IAlterTypeAlterTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterTypeAlterTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterTypeAlterTypeContext)
}

func (s *AlterTypeOperationContext) AlterTypeAdd() IAlterTypeAddContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterTypeAddContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterTypeAddContext)
}

func (s *AlterTypeOperationContext) AlterTypeRename() IAlterTypeRenameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterTypeRenameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterTypeRenameContext)
}

func (s *AlterTypeOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTypeOperationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterTypeOperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterAlterTypeOperation(s)
	}
}

func (s *AlterTypeOperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitAlterTypeOperation(s)
	}
}

func (p *CQLParser) AlterTypeOperation() (localctx IAlterTypeOperationContext) {
	localctx = NewAlterTypeOperationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, CQLParserRULE_alterTypeOperation)
	p.SetState(1010)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CQLParserK_ALTER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1007)
			p.AlterTypeAlterType()
		}

	case CQLParserK_ADD:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1008)
			p.AlterTypeAdd()
		}

	case CQLParserK_RENAME:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1009)
			p.AlterTypeRename()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterTypeRenameContext is an interface to support dynamic dispatch.
type IAlterTypeRenameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwRename() IKwRenameContext
	AlterTypeRenameList() IAlterTypeRenameListContext

	// IsAlterTypeRenameContext differentiates from other interfaces.
	IsAlterTypeRenameContext()
}

type AlterTypeRenameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterTypeRenameContext() *AlterTypeRenameContext {
	var p = new(AlterTypeRenameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_alterTypeRename
	return p
}

func InitEmptyAlterTypeRenameContext(p *AlterTypeRenameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_alterTypeRename
}

func (*AlterTypeRenameContext) IsAlterTypeRenameContext() {}

func NewAlterTypeRenameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterTypeRenameContext {
	var p = new(AlterTypeRenameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_alterTypeRename

	return p
}

func (s *AlterTypeRenameContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterTypeRenameContext) KwRename() IKwRenameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwRenameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwRenameContext)
}

func (s *AlterTypeRenameContext) AlterTypeRenameList() IAlterTypeRenameListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterTypeRenameListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterTypeRenameListContext)
}

func (s *AlterTypeRenameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTypeRenameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterTypeRenameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterAlterTypeRename(s)
	}
}

func (s *AlterTypeRenameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitAlterTypeRename(s)
	}
}

func (p *CQLParser) AlterTypeRename() (localctx IAlterTypeRenameContext) {
	localctx = NewAlterTypeRenameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, CQLParserRULE_alterTypeRename)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1012)
		p.KwRename()
	}
	{
		p.SetState(1013)
		p.AlterTypeRenameList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterTypeRenameListContext is an interface to support dynamic dispatch.
type IAlterTypeRenameListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAlterTypeRenameItem() []IAlterTypeRenameItemContext
	AlterTypeRenameItem(i int) IAlterTypeRenameItemContext
	AllKwAnd() []IKwAndContext
	KwAnd(i int) IKwAndContext

	// IsAlterTypeRenameListContext differentiates from other interfaces.
	IsAlterTypeRenameListContext()
}

type AlterTypeRenameListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterTypeRenameListContext() *AlterTypeRenameListContext {
	var p = new(AlterTypeRenameListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_alterTypeRenameList
	return p
}

func InitEmptyAlterTypeRenameListContext(p *AlterTypeRenameListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_alterTypeRenameList
}

func (*AlterTypeRenameListContext) IsAlterTypeRenameListContext() {}

func NewAlterTypeRenameListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterTypeRenameListContext {
	var p = new(AlterTypeRenameListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_alterTypeRenameList

	return p
}

func (s *AlterTypeRenameListContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterTypeRenameListContext) AllAlterTypeRenameItem() []IAlterTypeRenameItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAlterTypeRenameItemContext); ok {
			len++
		}
	}

	tst := make([]IAlterTypeRenameItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAlterTypeRenameItemContext); ok {
			tst[i] = t.(IAlterTypeRenameItemContext)
			i++
		}
	}

	return tst
}

func (s *AlterTypeRenameListContext) AlterTypeRenameItem(i int) IAlterTypeRenameItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterTypeRenameItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterTypeRenameItemContext)
}

func (s *AlterTypeRenameListContext) AllKwAnd() []IKwAndContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IKwAndContext); ok {
			len++
		}
	}

	tst := make([]IKwAndContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IKwAndContext); ok {
			tst[i] = t.(IKwAndContext)
			i++
		}
	}

	return tst
}

func (s *AlterTypeRenameListContext) KwAnd(i int) IKwAndContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAndContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAndContext)
}

func (s *AlterTypeRenameListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTypeRenameListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterTypeRenameListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterAlterTypeRenameList(s)
	}
}

func (s *AlterTypeRenameListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitAlterTypeRenameList(s)
	}
}

func (p *CQLParser) AlterTypeRenameList() (localctx IAlterTypeRenameListContext) {
	localctx = NewAlterTypeRenameListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, CQLParserRULE_alterTypeRenameList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1015)
		p.AlterTypeRenameItem()
	}
	p.SetState(1021)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CQLParserK_AND {
		{
			p.SetState(1016)
			p.KwAnd()
		}
		{
			p.SetState(1017)
			p.AlterTypeRenameItem()
		}

		p.SetState(1023)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterTypeRenameItemContext is an interface to support dynamic dispatch.
type IAlterTypeRenameItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllColumn() []IColumnContext
	Column(i int) IColumnContext
	KwTo() IKwToContext

	// IsAlterTypeRenameItemContext differentiates from other interfaces.
	IsAlterTypeRenameItemContext()
}

type AlterTypeRenameItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterTypeRenameItemContext() *AlterTypeRenameItemContext {
	var p = new(AlterTypeRenameItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_alterTypeRenameItem
	return p
}

func InitEmptyAlterTypeRenameItemContext(p *AlterTypeRenameItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_alterTypeRenameItem
}

func (*AlterTypeRenameItemContext) IsAlterTypeRenameItemContext() {}

func NewAlterTypeRenameItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterTypeRenameItemContext {
	var p = new(AlterTypeRenameItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_alterTypeRenameItem

	return p
}

func (s *AlterTypeRenameItemContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterTypeRenameItemContext) AllColumn() []IColumnContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnContext); ok {
			len++
		}
	}

	tst := make([]IColumnContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnContext); ok {
			tst[i] = t.(IColumnContext)
			i++
		}
	}

	return tst
}

func (s *AlterTypeRenameItemContext) Column(i int) IColumnContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnContext)
}

func (s *AlterTypeRenameItemContext) KwTo() IKwToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwToContext)
}

func (s *AlterTypeRenameItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTypeRenameItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterTypeRenameItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterAlterTypeRenameItem(s)
	}
}

func (s *AlterTypeRenameItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitAlterTypeRenameItem(s)
	}
}

func (p *CQLParser) AlterTypeRenameItem() (localctx IAlterTypeRenameItemContext) {
	localctx = NewAlterTypeRenameItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, CQLParserRULE_alterTypeRenameItem)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1024)
		p.Column()
	}
	{
		p.SetState(1025)
		p.KwTo()
	}
	{
		p.SetState(1026)
		p.Column()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterTypeAddContext is an interface to support dynamic dispatch.
type IAlterTypeAddContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwAdd() IKwAddContext
	AllColumn() []IColumnContext
	Column(i int) IColumnContext
	AllDataType() []IDataTypeContext
	DataType(i int) IDataTypeContext
	AllSyntaxComma() []ISyntaxCommaContext
	SyntaxComma(i int) ISyntaxCommaContext

	// IsAlterTypeAddContext differentiates from other interfaces.
	IsAlterTypeAddContext()
}

type AlterTypeAddContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterTypeAddContext() *AlterTypeAddContext {
	var p = new(AlterTypeAddContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_alterTypeAdd
	return p
}

func InitEmptyAlterTypeAddContext(p *AlterTypeAddContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_alterTypeAdd
}

func (*AlterTypeAddContext) IsAlterTypeAddContext() {}

func NewAlterTypeAddContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterTypeAddContext {
	var p = new(AlterTypeAddContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_alterTypeAdd

	return p
}

func (s *AlterTypeAddContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterTypeAddContext) KwAdd() IKwAddContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAddContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAddContext)
}

func (s *AlterTypeAddContext) AllColumn() []IColumnContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnContext); ok {
			len++
		}
	}

	tst := make([]IColumnContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnContext); ok {
			tst[i] = t.(IColumnContext)
			i++
		}
	}

	return tst
}

func (s *AlterTypeAddContext) Column(i int) IColumnContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnContext)
}

func (s *AlterTypeAddContext) AllDataType() []IDataTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataTypeContext); ok {
			len++
		}
	}

	tst := make([]IDataTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataTypeContext); ok {
			tst[i] = t.(IDataTypeContext)
			i++
		}
	}

	return tst
}

func (s *AlterTypeAddContext) DataType(i int) IDataTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *AlterTypeAddContext) AllSyntaxComma() []ISyntaxCommaContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			len++
		}
	}

	tst := make([]ISyntaxCommaContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISyntaxCommaContext); ok {
			tst[i] = t.(ISyntaxCommaContext)
			i++
		}
	}

	return tst
}

func (s *AlterTypeAddContext) SyntaxComma(i int) ISyntaxCommaContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxCommaContext)
}

func (s *AlterTypeAddContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTypeAddContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterTypeAddContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterAlterTypeAdd(s)
	}
}

func (s *AlterTypeAddContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitAlterTypeAdd(s)
	}
}

func (p *CQLParser) AlterTypeAdd() (localctx IAlterTypeAddContext) {
	localctx = NewAlterTypeAddContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, CQLParserRULE_alterTypeAdd)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1028)
		p.KwAdd()
	}
	{
		p.SetState(1029)
		p.Column()
	}
	{
		p.SetState(1030)
		p.DataType()
	}
	p.SetState(1037)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CQLParserCOMMA {
		{
			p.SetState(1031)
			p.SyntaxComma()
		}
		{
			p.SetState(1032)
			p.Column()
		}
		{
			p.SetState(1033)
			p.DataType()
		}

		p.SetState(1039)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterTypeAlterTypeContext is an interface to support dynamic dispatch.
type IAlterTypeAlterTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwAlter() IKwAlterContext
	Column() IColumnContext
	KwType() IKwTypeContext
	DataType() IDataTypeContext

	// IsAlterTypeAlterTypeContext differentiates from other interfaces.
	IsAlterTypeAlterTypeContext()
}

type AlterTypeAlterTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterTypeAlterTypeContext() *AlterTypeAlterTypeContext {
	var p = new(AlterTypeAlterTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_alterTypeAlterType
	return p
}

func InitEmptyAlterTypeAlterTypeContext(p *AlterTypeAlterTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_alterTypeAlterType
}

func (*AlterTypeAlterTypeContext) IsAlterTypeAlterTypeContext() {}

func NewAlterTypeAlterTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterTypeAlterTypeContext {
	var p = new(AlterTypeAlterTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_alterTypeAlterType

	return p
}

func (s *AlterTypeAlterTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterTypeAlterTypeContext) KwAlter() IKwAlterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAlterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAlterContext)
}

func (s *AlterTypeAlterTypeContext) Column() IColumnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnContext)
}

func (s *AlterTypeAlterTypeContext) KwType() IKwTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwTypeContext)
}

func (s *AlterTypeAlterTypeContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *AlterTypeAlterTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTypeAlterTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterTypeAlterTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterAlterTypeAlterType(s)
	}
}

func (s *AlterTypeAlterTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitAlterTypeAlterType(s)
	}
}

func (p *CQLParser) AlterTypeAlterType() (localctx IAlterTypeAlterTypeContext) {
	localctx = NewAlterTypeAlterTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, CQLParserRULE_alterTypeAlterType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1040)
		p.KwAlter()
	}
	{
		p.SetState(1041)
		p.Column()
	}
	{
		p.SetState(1042)
		p.KwType()
	}
	{
		p.SetState(1043)
		p.DataType()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterTableContext is an interface to support dynamic dispatch.
type IAlterTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwAlter() IKwAlterContext
	KwTable() IKwTableContext
	Table() ITableContext
	AlterTableOperation() IAlterTableOperationContext
	Keyspace() IKeyspaceContext
	DOT() antlr.TerminalNode

	// IsAlterTableContext differentiates from other interfaces.
	IsAlterTableContext()
}

type AlterTableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterTableContext() *AlterTableContext {
	var p = new(AlterTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_alterTable
	return p
}

func InitEmptyAlterTableContext(p *AlterTableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_alterTable
}

func (*AlterTableContext) IsAlterTableContext() {}

func NewAlterTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterTableContext {
	var p = new(AlterTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_alterTable

	return p
}

func (s *AlterTableContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterTableContext) KwAlter() IKwAlterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAlterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAlterContext)
}

func (s *AlterTableContext) KwTable() IKwTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwTableContext)
}

func (s *AlterTableContext) Table() ITableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableContext)
}

func (s *AlterTableContext) AlterTableOperation() IAlterTableOperationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterTableOperationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterTableOperationContext)
}

func (s *AlterTableContext) Keyspace() IKeyspaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyspaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyspaceContext)
}

func (s *AlterTableContext) DOT() antlr.TerminalNode {
	return s.GetToken(CQLParserDOT, 0)
}

func (s *AlterTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterAlterTable(s)
	}
}

func (s *AlterTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitAlterTable(s)
	}
}

func (p *CQLParser) AlterTable() (localctx IAlterTableContext) {
	localctx = NewAlterTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, CQLParserRULE_alterTable)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1045)
		p.KwAlter()
	}
	{
		p.SetState(1046)
		p.KwTable()
	}
	p.SetState(1050)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 57, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1047)
			p.Keyspace()
		}
		{
			p.SetState(1048)
			p.Match(CQLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1052)
		p.Table()
	}
	{
		p.SetState(1053)
		p.AlterTableOperation()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterTableOperationContext is an interface to support dynamic dispatch.
type IAlterTableOperationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AlterTableAdd() IAlterTableAddContext
	AlterTableDropColumns() IAlterTableDropColumnsContext
	AlterTableDropCompactStorage() IAlterTableDropCompactStorageContext
	AlterTableRename() IAlterTableRenameContext
	AlterTableWith() IAlterTableWithContext

	// IsAlterTableOperationContext differentiates from other interfaces.
	IsAlterTableOperationContext()
}

type AlterTableOperationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterTableOperationContext() *AlterTableOperationContext {
	var p = new(AlterTableOperationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_alterTableOperation
	return p
}

func InitEmptyAlterTableOperationContext(p *AlterTableOperationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_alterTableOperation
}

func (*AlterTableOperationContext) IsAlterTableOperationContext() {}

func NewAlterTableOperationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterTableOperationContext {
	var p = new(AlterTableOperationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_alterTableOperation

	return p
}

func (s *AlterTableOperationContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterTableOperationContext) AlterTableAdd() IAlterTableAddContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterTableAddContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterTableAddContext)
}

func (s *AlterTableOperationContext) AlterTableDropColumns() IAlterTableDropColumnsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterTableDropColumnsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterTableDropColumnsContext)
}

func (s *AlterTableOperationContext) AlterTableDropCompactStorage() IAlterTableDropCompactStorageContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterTableDropCompactStorageContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterTableDropCompactStorageContext)
}

func (s *AlterTableOperationContext) AlterTableRename() IAlterTableRenameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterTableRenameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterTableRenameContext)
}

func (s *AlterTableOperationContext) AlterTableWith() IAlterTableWithContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterTableWithContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterTableWithContext)
}

func (s *AlterTableOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableOperationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterTableOperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterAlterTableOperation(s)
	}
}

func (s *AlterTableOperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitAlterTableOperation(s)
	}
}

func (p *CQLParser) AlterTableOperation() (localctx IAlterTableOperationContext) {
	localctx = NewAlterTableOperationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, CQLParserRULE_alterTableOperation)
	p.SetState(1060)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 58, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1055)
			p.AlterTableAdd()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1056)
			p.AlterTableDropColumns()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1057)
			p.AlterTableDropCompactStorage()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1058)
			p.AlterTableRename()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1059)
			p.AlterTableWith()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterTableWithContext is an interface to support dynamic dispatch.
type IAlterTableWithContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwWith() IKwWithContext
	TableOptions() ITableOptionsContext

	// IsAlterTableWithContext differentiates from other interfaces.
	IsAlterTableWithContext()
}

type AlterTableWithContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterTableWithContext() *AlterTableWithContext {
	var p = new(AlterTableWithContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_alterTableWith
	return p
}

func InitEmptyAlterTableWithContext(p *AlterTableWithContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_alterTableWith
}

func (*AlterTableWithContext) IsAlterTableWithContext() {}

func NewAlterTableWithContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterTableWithContext {
	var p = new(AlterTableWithContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_alterTableWith

	return p
}

func (s *AlterTableWithContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterTableWithContext) KwWith() IKwWithContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwWithContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwWithContext)
}

func (s *AlterTableWithContext) TableOptions() ITableOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableOptionsContext)
}

func (s *AlterTableWithContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableWithContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterTableWithContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterAlterTableWith(s)
	}
}

func (s *AlterTableWithContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitAlterTableWith(s)
	}
}

func (p *CQLParser) AlterTableWith() (localctx IAlterTableWithContext) {
	localctx = NewAlterTableWithContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, CQLParserRULE_alterTableWith)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1062)
		p.KwWith()
	}
	{
		p.SetState(1063)
		p.TableOptions()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterTableRenameContext is an interface to support dynamic dispatch.
type IAlterTableRenameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwRename() IKwRenameContext
	AllColumn() []IColumnContext
	Column(i int) IColumnContext
	KwTo() IKwToContext

	// IsAlterTableRenameContext differentiates from other interfaces.
	IsAlterTableRenameContext()
}

type AlterTableRenameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterTableRenameContext() *AlterTableRenameContext {
	var p = new(AlterTableRenameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_alterTableRename
	return p
}

func InitEmptyAlterTableRenameContext(p *AlterTableRenameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_alterTableRename
}

func (*AlterTableRenameContext) IsAlterTableRenameContext() {}

func NewAlterTableRenameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterTableRenameContext {
	var p = new(AlterTableRenameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_alterTableRename

	return p
}

func (s *AlterTableRenameContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterTableRenameContext) KwRename() IKwRenameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwRenameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwRenameContext)
}

func (s *AlterTableRenameContext) AllColumn() []IColumnContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnContext); ok {
			len++
		}
	}

	tst := make([]IColumnContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnContext); ok {
			tst[i] = t.(IColumnContext)
			i++
		}
	}

	return tst
}

func (s *AlterTableRenameContext) Column(i int) IColumnContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnContext)
}

func (s *AlterTableRenameContext) KwTo() IKwToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwToContext)
}

func (s *AlterTableRenameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableRenameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterTableRenameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterAlterTableRename(s)
	}
}

func (s *AlterTableRenameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitAlterTableRename(s)
	}
}

func (p *CQLParser) AlterTableRename() (localctx IAlterTableRenameContext) {
	localctx = NewAlterTableRenameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, CQLParserRULE_alterTableRename)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1065)
		p.KwRename()
	}
	{
		p.SetState(1066)
		p.Column()
	}
	{
		p.SetState(1067)
		p.KwTo()
	}
	{
		p.SetState(1068)
		p.Column()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterTableDropCompactStorageContext is an interface to support dynamic dispatch.
type IAlterTableDropCompactStorageContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwDrop() IKwDropContext
	KwCompact() IKwCompactContext
	KwStorage() IKwStorageContext

	// IsAlterTableDropCompactStorageContext differentiates from other interfaces.
	IsAlterTableDropCompactStorageContext()
}

type AlterTableDropCompactStorageContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterTableDropCompactStorageContext() *AlterTableDropCompactStorageContext {
	var p = new(AlterTableDropCompactStorageContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_alterTableDropCompactStorage
	return p
}

func InitEmptyAlterTableDropCompactStorageContext(p *AlterTableDropCompactStorageContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_alterTableDropCompactStorage
}

func (*AlterTableDropCompactStorageContext) IsAlterTableDropCompactStorageContext() {}

func NewAlterTableDropCompactStorageContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterTableDropCompactStorageContext {
	var p = new(AlterTableDropCompactStorageContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_alterTableDropCompactStorage

	return p
}

func (s *AlterTableDropCompactStorageContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterTableDropCompactStorageContext) KwDrop() IKwDropContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwDropContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwDropContext)
}

func (s *AlterTableDropCompactStorageContext) KwCompact() IKwCompactContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwCompactContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwCompactContext)
}

func (s *AlterTableDropCompactStorageContext) KwStorage() IKwStorageContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwStorageContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwStorageContext)
}

func (s *AlterTableDropCompactStorageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableDropCompactStorageContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterTableDropCompactStorageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterAlterTableDropCompactStorage(s)
	}
}

func (s *AlterTableDropCompactStorageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitAlterTableDropCompactStorage(s)
	}
}

func (p *CQLParser) AlterTableDropCompactStorage() (localctx IAlterTableDropCompactStorageContext) {
	localctx = NewAlterTableDropCompactStorageContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, CQLParserRULE_alterTableDropCompactStorage)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1070)
		p.KwDrop()
	}
	{
		p.SetState(1071)
		p.KwCompact()
	}
	{
		p.SetState(1072)
		p.KwStorage()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterTableDropColumnsContext is an interface to support dynamic dispatch.
type IAlterTableDropColumnsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwDrop() IKwDropContext
	AlterTableDropColumnList() IAlterTableDropColumnListContext

	// IsAlterTableDropColumnsContext differentiates from other interfaces.
	IsAlterTableDropColumnsContext()
}

type AlterTableDropColumnsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterTableDropColumnsContext() *AlterTableDropColumnsContext {
	var p = new(AlterTableDropColumnsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_alterTableDropColumns
	return p
}

func InitEmptyAlterTableDropColumnsContext(p *AlterTableDropColumnsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_alterTableDropColumns
}

func (*AlterTableDropColumnsContext) IsAlterTableDropColumnsContext() {}

func NewAlterTableDropColumnsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterTableDropColumnsContext {
	var p = new(AlterTableDropColumnsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_alterTableDropColumns

	return p
}

func (s *AlterTableDropColumnsContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterTableDropColumnsContext) KwDrop() IKwDropContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwDropContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwDropContext)
}

func (s *AlterTableDropColumnsContext) AlterTableDropColumnList() IAlterTableDropColumnListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterTableDropColumnListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterTableDropColumnListContext)
}

func (s *AlterTableDropColumnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableDropColumnsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterTableDropColumnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterAlterTableDropColumns(s)
	}
}

func (s *AlterTableDropColumnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitAlterTableDropColumns(s)
	}
}

func (p *CQLParser) AlterTableDropColumns() (localctx IAlterTableDropColumnsContext) {
	localctx = NewAlterTableDropColumnsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, CQLParserRULE_alterTableDropColumns)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1074)
		p.KwDrop()
	}
	{
		p.SetState(1075)
		p.AlterTableDropColumnList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterTableDropColumnListContext is an interface to support dynamic dispatch.
type IAlterTableDropColumnListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllColumn() []IColumnContext
	Column(i int) IColumnContext
	AllSyntaxComma() []ISyntaxCommaContext
	SyntaxComma(i int) ISyntaxCommaContext

	// IsAlterTableDropColumnListContext differentiates from other interfaces.
	IsAlterTableDropColumnListContext()
}

type AlterTableDropColumnListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterTableDropColumnListContext() *AlterTableDropColumnListContext {
	var p = new(AlterTableDropColumnListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_alterTableDropColumnList
	return p
}

func InitEmptyAlterTableDropColumnListContext(p *AlterTableDropColumnListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_alterTableDropColumnList
}

func (*AlterTableDropColumnListContext) IsAlterTableDropColumnListContext() {}

func NewAlterTableDropColumnListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterTableDropColumnListContext {
	var p = new(AlterTableDropColumnListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_alterTableDropColumnList

	return p
}

func (s *AlterTableDropColumnListContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterTableDropColumnListContext) AllColumn() []IColumnContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnContext); ok {
			len++
		}
	}

	tst := make([]IColumnContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnContext); ok {
			tst[i] = t.(IColumnContext)
			i++
		}
	}

	return tst
}

func (s *AlterTableDropColumnListContext) Column(i int) IColumnContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnContext)
}

func (s *AlterTableDropColumnListContext) AllSyntaxComma() []ISyntaxCommaContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			len++
		}
	}

	tst := make([]ISyntaxCommaContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISyntaxCommaContext); ok {
			tst[i] = t.(ISyntaxCommaContext)
			i++
		}
	}

	return tst
}

func (s *AlterTableDropColumnListContext) SyntaxComma(i int) ISyntaxCommaContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxCommaContext)
}

func (s *AlterTableDropColumnListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableDropColumnListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterTableDropColumnListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterAlterTableDropColumnList(s)
	}
}

func (s *AlterTableDropColumnListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitAlterTableDropColumnList(s)
	}
}

func (p *CQLParser) AlterTableDropColumnList() (localctx IAlterTableDropColumnListContext) {
	localctx = NewAlterTableDropColumnListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, CQLParserRULE_alterTableDropColumnList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1077)
		p.Column()
	}
	p.SetState(1083)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CQLParserCOMMA {
		{
			p.SetState(1078)
			p.SyntaxComma()
		}
		{
			p.SetState(1079)
			p.Column()
		}

		p.SetState(1085)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterTableAddContext is an interface to support dynamic dispatch.
type IAlterTableAddContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwAdd() IKwAddContext
	AlterTableColumnDefinition() IAlterTableColumnDefinitionContext

	// IsAlterTableAddContext differentiates from other interfaces.
	IsAlterTableAddContext()
}

type AlterTableAddContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterTableAddContext() *AlterTableAddContext {
	var p = new(AlterTableAddContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_alterTableAdd
	return p
}

func InitEmptyAlterTableAddContext(p *AlterTableAddContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_alterTableAdd
}

func (*AlterTableAddContext) IsAlterTableAddContext() {}

func NewAlterTableAddContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterTableAddContext {
	var p = new(AlterTableAddContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_alterTableAdd

	return p
}

func (s *AlterTableAddContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterTableAddContext) KwAdd() IKwAddContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAddContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAddContext)
}

func (s *AlterTableAddContext) AlterTableColumnDefinition() IAlterTableColumnDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterTableColumnDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterTableColumnDefinitionContext)
}

func (s *AlterTableAddContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableAddContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterTableAddContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterAlterTableAdd(s)
	}
}

func (s *AlterTableAddContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitAlterTableAdd(s)
	}
}

func (p *CQLParser) AlterTableAdd() (localctx IAlterTableAddContext) {
	localctx = NewAlterTableAddContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, CQLParserRULE_alterTableAdd)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1086)
		p.KwAdd()
	}
	{
		p.SetState(1087)
		p.AlterTableColumnDefinition()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterTableColumnDefinitionContext is an interface to support dynamic dispatch.
type IAlterTableColumnDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllColumn() []IColumnContext
	Column(i int) IColumnContext
	AllDataType() []IDataTypeContext
	DataType(i int) IDataTypeContext
	AllSyntaxComma() []ISyntaxCommaContext
	SyntaxComma(i int) ISyntaxCommaContext

	// IsAlterTableColumnDefinitionContext differentiates from other interfaces.
	IsAlterTableColumnDefinitionContext()
}

type AlterTableColumnDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterTableColumnDefinitionContext() *AlterTableColumnDefinitionContext {
	var p = new(AlterTableColumnDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_alterTableColumnDefinition
	return p
}

func InitEmptyAlterTableColumnDefinitionContext(p *AlterTableColumnDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_alterTableColumnDefinition
}

func (*AlterTableColumnDefinitionContext) IsAlterTableColumnDefinitionContext() {}

func NewAlterTableColumnDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterTableColumnDefinitionContext {
	var p = new(AlterTableColumnDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_alterTableColumnDefinition

	return p
}

func (s *AlterTableColumnDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterTableColumnDefinitionContext) AllColumn() []IColumnContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnContext); ok {
			len++
		}
	}

	tst := make([]IColumnContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnContext); ok {
			tst[i] = t.(IColumnContext)
			i++
		}
	}

	return tst
}

func (s *AlterTableColumnDefinitionContext) Column(i int) IColumnContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnContext)
}

func (s *AlterTableColumnDefinitionContext) AllDataType() []IDataTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataTypeContext); ok {
			len++
		}
	}

	tst := make([]IDataTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataTypeContext); ok {
			tst[i] = t.(IDataTypeContext)
			i++
		}
	}

	return tst
}

func (s *AlterTableColumnDefinitionContext) DataType(i int) IDataTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *AlterTableColumnDefinitionContext) AllSyntaxComma() []ISyntaxCommaContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			len++
		}
	}

	tst := make([]ISyntaxCommaContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISyntaxCommaContext); ok {
			tst[i] = t.(ISyntaxCommaContext)
			i++
		}
	}

	return tst
}

func (s *AlterTableColumnDefinitionContext) SyntaxComma(i int) ISyntaxCommaContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxCommaContext)
}

func (s *AlterTableColumnDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableColumnDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterTableColumnDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterAlterTableColumnDefinition(s)
	}
}

func (s *AlterTableColumnDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitAlterTableColumnDefinition(s)
	}
}

func (p *CQLParser) AlterTableColumnDefinition() (localctx IAlterTableColumnDefinitionContext) {
	localctx = NewAlterTableColumnDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, CQLParserRULE_alterTableColumnDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1089)
		p.Column()
	}
	{
		p.SetState(1090)
		p.DataType()
	}
	p.SetState(1097)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CQLParserCOMMA {
		{
			p.SetState(1091)
			p.SyntaxComma()
		}
		{
			p.SetState(1092)
			p.Column()
		}
		{
			p.SetState(1093)
			p.DataType()
		}

		p.SetState(1099)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterRoleContext is an interface to support dynamic dispatch.
type IAlterRoleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwAlter() IKwAlterContext
	KwRole() IKwRoleContext
	Role() IRoleContext
	RoleWith() IRoleWithContext

	// IsAlterRoleContext differentiates from other interfaces.
	IsAlterRoleContext()
}

type AlterRoleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterRoleContext() *AlterRoleContext {
	var p = new(AlterRoleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_alterRole
	return p
}

func InitEmptyAlterRoleContext(p *AlterRoleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_alterRole
}

func (*AlterRoleContext) IsAlterRoleContext() {}

func NewAlterRoleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterRoleContext {
	var p = new(AlterRoleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_alterRole

	return p
}

func (s *AlterRoleContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterRoleContext) KwAlter() IKwAlterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAlterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAlterContext)
}

func (s *AlterRoleContext) KwRole() IKwRoleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwRoleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwRoleContext)
}

func (s *AlterRoleContext) Role() IRoleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleContext)
}

func (s *AlterRoleContext) RoleWith() IRoleWithContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleWithContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleWithContext)
}

func (s *AlterRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterRoleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterRoleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterAlterRole(s)
	}
}

func (s *AlterRoleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitAlterRole(s)
	}
}

func (p *CQLParser) AlterRole() (localctx IAlterRoleContext) {
	localctx = NewAlterRoleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, CQLParserRULE_alterRole)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1100)
		p.KwAlter()
	}
	{
		p.SetState(1101)
		p.KwRole()
	}
	{
		p.SetState(1102)
		p.Role()
	}
	p.SetState(1104)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CQLParserK_WITH {
		{
			p.SetState(1103)
			p.RoleWith()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRoleWithContext is an interface to support dynamic dispatch.
type IRoleWithContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwWith() IKwWithContext
	AllRoleWithOptions() []IRoleWithOptionsContext
	RoleWithOptions(i int) IRoleWithOptionsContext
	AllKwAnd() []IKwAndContext
	KwAnd(i int) IKwAndContext

	// IsRoleWithContext differentiates from other interfaces.
	IsRoleWithContext()
}

type RoleWithContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoleWithContext() *RoleWithContext {
	var p = new(RoleWithContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_roleWith
	return p
}

func InitEmptyRoleWithContext(p *RoleWithContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_roleWith
}

func (*RoleWithContext) IsRoleWithContext() {}

func NewRoleWithContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoleWithContext {
	var p = new(RoleWithContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_roleWith

	return p
}

func (s *RoleWithContext) GetParser() antlr.Parser { return s.parser }

func (s *RoleWithContext) KwWith() IKwWithContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwWithContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwWithContext)
}

func (s *RoleWithContext) AllRoleWithOptions() []IRoleWithOptionsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRoleWithOptionsContext); ok {
			len++
		}
	}

	tst := make([]IRoleWithOptionsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRoleWithOptionsContext); ok {
			tst[i] = t.(IRoleWithOptionsContext)
			i++
		}
	}

	return tst
}

func (s *RoleWithContext) RoleWithOptions(i int) IRoleWithOptionsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleWithOptionsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleWithOptionsContext)
}

func (s *RoleWithContext) AllKwAnd() []IKwAndContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IKwAndContext); ok {
			len++
		}
	}

	tst := make([]IKwAndContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IKwAndContext); ok {
			tst[i] = t.(IKwAndContext)
			i++
		}
	}

	return tst
}

func (s *RoleWithContext) KwAnd(i int) IKwAndContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAndContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAndContext)
}

func (s *RoleWithContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoleWithContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RoleWithContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterRoleWith(s)
	}
}

func (s *RoleWithContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitRoleWith(s)
	}
}

func (p *CQLParser) RoleWith() (localctx IRoleWithContext) {
	localctx = NewRoleWithContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, CQLParserRULE_roleWith)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1106)
		p.KwWith()
	}

	{
		p.SetState(1107)
		p.RoleWithOptions()
	}
	p.SetState(1113)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CQLParserK_AND {
		{
			p.SetState(1108)
			p.KwAnd()
		}
		{
			p.SetState(1109)
			p.RoleWithOptions()
		}

		p.SetState(1115)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRoleWithOptionsContext is an interface to support dynamic dispatch.
type IRoleWithOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwPassword() IKwPasswordContext
	OPERATOR_EQ() antlr.TerminalNode
	StringLiteral() IStringLiteralContext
	KwLogin() IKwLoginContext
	BooleanLiteral() IBooleanLiteralContext
	KwSuperuser() IKwSuperuserContext
	KwOptions() IKwOptionsContext
	OptionHash() IOptionHashContext

	// IsRoleWithOptionsContext differentiates from other interfaces.
	IsRoleWithOptionsContext()
}

type RoleWithOptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoleWithOptionsContext() *RoleWithOptionsContext {
	var p = new(RoleWithOptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_roleWithOptions
	return p
}

func InitEmptyRoleWithOptionsContext(p *RoleWithOptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_roleWithOptions
}

func (*RoleWithOptionsContext) IsRoleWithOptionsContext() {}

func NewRoleWithOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoleWithOptionsContext {
	var p = new(RoleWithOptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_roleWithOptions

	return p
}

func (s *RoleWithOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *RoleWithOptionsContext) KwPassword() IKwPasswordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwPasswordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwPasswordContext)
}

func (s *RoleWithOptionsContext) OPERATOR_EQ() antlr.TerminalNode {
	return s.GetToken(CQLParserOPERATOR_EQ, 0)
}

func (s *RoleWithOptionsContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *RoleWithOptionsContext) KwLogin() IKwLoginContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwLoginContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwLoginContext)
}

func (s *RoleWithOptionsContext) BooleanLiteral() IBooleanLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanLiteralContext)
}

func (s *RoleWithOptionsContext) KwSuperuser() IKwSuperuserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwSuperuserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwSuperuserContext)
}

func (s *RoleWithOptionsContext) KwOptions() IKwOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwOptionsContext)
}

func (s *RoleWithOptionsContext) OptionHash() IOptionHashContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptionHashContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptionHashContext)
}

func (s *RoleWithOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoleWithOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RoleWithOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterRoleWithOptions(s)
	}
}

func (s *RoleWithOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitRoleWithOptions(s)
	}
}

func (p *CQLParser) RoleWithOptions() (localctx IRoleWithOptionsContext) {
	localctx = NewRoleWithOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, CQLParserRULE_roleWithOptions)
	p.SetState(1132)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CQLParserK_PASSWORD:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1116)
			p.KwPassword()
		}
		{
			p.SetState(1117)
			p.Match(CQLParserOPERATOR_EQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1118)
			p.StringLiteral()
		}

	case CQLParserK_LOGIN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1120)
			p.KwLogin()
		}
		{
			p.SetState(1121)
			p.Match(CQLParserOPERATOR_EQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1122)
			p.BooleanLiteral()
		}

	case CQLParserK_SUPERUSER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1124)
			p.KwSuperuser()
		}
		{
			p.SetState(1125)
			p.Match(CQLParserOPERATOR_EQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1126)
			p.BooleanLiteral()
		}

	case CQLParserK_OPTIONS:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1128)
			p.KwOptions()
		}
		{
			p.SetState(1129)
			p.Match(CQLParserOPERATOR_EQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1130)
			p.OptionHash()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterMaterializedViewContext is an interface to support dynamic dispatch.
type IAlterMaterializedViewContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwAlter() IKwAlterContext
	KwMaterialized() IKwMaterializedContext
	KwView() IKwViewContext
	MaterializedView() IMaterializedViewContext
	Keyspace() IKeyspaceContext
	DOT() antlr.TerminalNode
	KwWith() IKwWithContext
	TableOptions() ITableOptionsContext

	// IsAlterMaterializedViewContext differentiates from other interfaces.
	IsAlterMaterializedViewContext()
}

type AlterMaterializedViewContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterMaterializedViewContext() *AlterMaterializedViewContext {
	var p = new(AlterMaterializedViewContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_alterMaterializedView
	return p
}

func InitEmptyAlterMaterializedViewContext(p *AlterMaterializedViewContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_alterMaterializedView
}

func (*AlterMaterializedViewContext) IsAlterMaterializedViewContext() {}

func NewAlterMaterializedViewContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterMaterializedViewContext {
	var p = new(AlterMaterializedViewContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_alterMaterializedView

	return p
}

func (s *AlterMaterializedViewContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterMaterializedViewContext) KwAlter() IKwAlterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAlterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAlterContext)
}

func (s *AlterMaterializedViewContext) KwMaterialized() IKwMaterializedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwMaterializedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwMaterializedContext)
}

func (s *AlterMaterializedViewContext) KwView() IKwViewContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwViewContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwViewContext)
}

func (s *AlterMaterializedViewContext) MaterializedView() IMaterializedViewContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMaterializedViewContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMaterializedViewContext)
}

func (s *AlterMaterializedViewContext) Keyspace() IKeyspaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyspaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyspaceContext)
}

func (s *AlterMaterializedViewContext) DOT() antlr.TerminalNode {
	return s.GetToken(CQLParserDOT, 0)
}

func (s *AlterMaterializedViewContext) KwWith() IKwWithContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwWithContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwWithContext)
}

func (s *AlterMaterializedViewContext) TableOptions() ITableOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableOptionsContext)
}

func (s *AlterMaterializedViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterMaterializedViewContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterMaterializedViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterAlterMaterializedView(s)
	}
}

func (s *AlterMaterializedViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitAlterMaterializedView(s)
	}
}

func (p *CQLParser) AlterMaterializedView() (localctx IAlterMaterializedViewContext) {
	localctx = NewAlterMaterializedViewContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, CQLParserRULE_alterMaterializedView)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1134)
		p.KwAlter()
	}
	{
		p.SetState(1135)
		p.KwMaterialized()
	}
	{
		p.SetState(1136)
		p.KwView()
	}
	p.SetState(1140)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 64, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1137)
			p.Keyspace()
		}
		{
			p.SetState(1138)
			p.Match(CQLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1142)
		p.MaterializedView()
	}
	p.SetState(1146)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CQLParserK_WITH {
		{
			p.SetState(1143)
			p.KwWith()
		}
		{
			p.SetState(1144)
			p.TableOptions()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropUserContext is an interface to support dynamic dispatch.
type IDropUserContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwDrop() IKwDropContext
	KwUser() IKwUserContext
	User() IUserContext
	IfExist() IIfExistContext

	// IsDropUserContext differentiates from other interfaces.
	IsDropUserContext()
}

type DropUserContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropUserContext() *DropUserContext {
	var p = new(DropUserContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_dropUser
	return p
}

func InitEmptyDropUserContext(p *DropUserContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_dropUser
}

func (*DropUserContext) IsDropUserContext() {}

func NewDropUserContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropUserContext {
	var p = new(DropUserContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_dropUser

	return p
}

func (s *DropUserContext) GetParser() antlr.Parser { return s.parser }

func (s *DropUserContext) KwDrop() IKwDropContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwDropContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwDropContext)
}

func (s *DropUserContext) KwUser() IKwUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwUserContext)
}

func (s *DropUserContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *DropUserContext) IfExist() IIfExistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistContext)
}

func (s *DropUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropUserContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterDropUser(s)
	}
}

func (s *DropUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitDropUser(s)
	}
}

func (p *CQLParser) DropUser() (localctx IDropUserContext) {
	localctx = NewDropUserContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, CQLParserRULE_dropUser)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1148)
		p.KwDrop()
	}
	{
		p.SetState(1149)
		p.KwUser()
	}
	p.SetState(1151)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CQLParserK_IF {
		{
			p.SetState(1150)
			p.IfExist()
		}

	}
	{
		p.SetState(1153)
		p.User()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropTypeContext is an interface to support dynamic dispatch.
type IDropTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwDrop() IKwDropContext
	KwType() IKwTypeContext
	Type_() IType_Context
	IfExist() IIfExistContext
	Keyspace() IKeyspaceContext
	DOT() antlr.TerminalNode

	// IsDropTypeContext differentiates from other interfaces.
	IsDropTypeContext()
}

type DropTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropTypeContext() *DropTypeContext {
	var p = new(DropTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_dropType
	return p
}

func InitEmptyDropTypeContext(p *DropTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_dropType
}

func (*DropTypeContext) IsDropTypeContext() {}

func NewDropTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropTypeContext {
	var p = new(DropTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_dropType

	return p
}

func (s *DropTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *DropTypeContext) KwDrop() IKwDropContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwDropContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwDropContext)
}

func (s *DropTypeContext) KwType() IKwTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwTypeContext)
}

func (s *DropTypeContext) Type_() IType_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IType_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IType_Context)
}

func (s *DropTypeContext) IfExist() IIfExistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistContext)
}

func (s *DropTypeContext) Keyspace() IKeyspaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyspaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyspaceContext)
}

func (s *DropTypeContext) DOT() antlr.TerminalNode {
	return s.GetToken(CQLParserDOT, 0)
}

func (s *DropTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterDropType(s)
	}
}

func (s *DropTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitDropType(s)
	}
}

func (p *CQLParser) DropType() (localctx IDropTypeContext) {
	localctx = NewDropTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, CQLParserRULE_dropType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1155)
		p.KwDrop()
	}
	{
		p.SetState(1156)
		p.KwType()
	}
	p.SetState(1158)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CQLParserK_IF {
		{
			p.SetState(1157)
			p.IfExist()
		}

	}
	p.SetState(1163)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 68, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1160)
			p.Keyspace()
		}
		{
			p.SetState(1161)
			p.Match(CQLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1165)
		p.Type_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropMaterializedViewContext is an interface to support dynamic dispatch.
type IDropMaterializedViewContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwDrop() IKwDropContext
	KwMaterialized() IKwMaterializedContext
	KwView() IKwViewContext
	MaterializedView() IMaterializedViewContext
	IfExist() IIfExistContext
	Keyspace() IKeyspaceContext
	DOT() antlr.TerminalNode

	// IsDropMaterializedViewContext differentiates from other interfaces.
	IsDropMaterializedViewContext()
}

type DropMaterializedViewContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropMaterializedViewContext() *DropMaterializedViewContext {
	var p = new(DropMaterializedViewContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_dropMaterializedView
	return p
}

func InitEmptyDropMaterializedViewContext(p *DropMaterializedViewContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_dropMaterializedView
}

func (*DropMaterializedViewContext) IsDropMaterializedViewContext() {}

func NewDropMaterializedViewContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropMaterializedViewContext {
	var p = new(DropMaterializedViewContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_dropMaterializedView

	return p
}

func (s *DropMaterializedViewContext) GetParser() antlr.Parser { return s.parser }

func (s *DropMaterializedViewContext) KwDrop() IKwDropContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwDropContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwDropContext)
}

func (s *DropMaterializedViewContext) KwMaterialized() IKwMaterializedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwMaterializedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwMaterializedContext)
}

func (s *DropMaterializedViewContext) KwView() IKwViewContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwViewContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwViewContext)
}

func (s *DropMaterializedViewContext) MaterializedView() IMaterializedViewContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMaterializedViewContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMaterializedViewContext)
}

func (s *DropMaterializedViewContext) IfExist() IIfExistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistContext)
}

func (s *DropMaterializedViewContext) Keyspace() IKeyspaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyspaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyspaceContext)
}

func (s *DropMaterializedViewContext) DOT() antlr.TerminalNode {
	return s.GetToken(CQLParserDOT, 0)
}

func (s *DropMaterializedViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropMaterializedViewContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropMaterializedViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterDropMaterializedView(s)
	}
}

func (s *DropMaterializedViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitDropMaterializedView(s)
	}
}

func (p *CQLParser) DropMaterializedView() (localctx IDropMaterializedViewContext) {
	localctx = NewDropMaterializedViewContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, CQLParserRULE_dropMaterializedView)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1167)
		p.KwDrop()
	}
	{
		p.SetState(1168)
		p.KwMaterialized()
	}
	{
		p.SetState(1169)
		p.KwView()
	}
	p.SetState(1171)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CQLParserK_IF {
		{
			p.SetState(1170)
			p.IfExist()
		}

	}
	p.SetState(1176)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 70, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1173)
			p.Keyspace()
		}
		{
			p.SetState(1174)
			p.Match(CQLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1178)
		p.MaterializedView()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropAggregateContext is an interface to support dynamic dispatch.
type IDropAggregateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwDrop() IKwDropContext
	KwAggregate() IKwAggregateContext
	Aggregate() IAggregateContext
	IfExist() IIfExistContext
	Keyspace() IKeyspaceContext
	DOT() antlr.TerminalNode

	// IsDropAggregateContext differentiates from other interfaces.
	IsDropAggregateContext()
}

type DropAggregateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropAggregateContext() *DropAggregateContext {
	var p = new(DropAggregateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_dropAggregate
	return p
}

func InitEmptyDropAggregateContext(p *DropAggregateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_dropAggregate
}

func (*DropAggregateContext) IsDropAggregateContext() {}

func NewDropAggregateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropAggregateContext {
	var p = new(DropAggregateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_dropAggregate

	return p
}

func (s *DropAggregateContext) GetParser() antlr.Parser { return s.parser }

func (s *DropAggregateContext) KwDrop() IKwDropContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwDropContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwDropContext)
}

func (s *DropAggregateContext) KwAggregate() IKwAggregateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAggregateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAggregateContext)
}

func (s *DropAggregateContext) Aggregate() IAggregateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAggregateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAggregateContext)
}

func (s *DropAggregateContext) IfExist() IIfExistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistContext)
}

func (s *DropAggregateContext) Keyspace() IKeyspaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyspaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyspaceContext)
}

func (s *DropAggregateContext) DOT() antlr.TerminalNode {
	return s.GetToken(CQLParserDOT, 0)
}

func (s *DropAggregateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropAggregateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropAggregateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterDropAggregate(s)
	}
}

func (s *DropAggregateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitDropAggregate(s)
	}
}

func (p *CQLParser) DropAggregate() (localctx IDropAggregateContext) {
	localctx = NewDropAggregateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, CQLParserRULE_dropAggregate)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1180)
		p.KwDrop()
	}
	{
		p.SetState(1181)
		p.KwAggregate()
	}
	p.SetState(1183)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CQLParserK_IF {
		{
			p.SetState(1182)
			p.IfExist()
		}

	}
	p.SetState(1188)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 72, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1185)
			p.Keyspace()
		}
		{
			p.SetState(1186)
			p.Match(CQLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1190)
		p.Aggregate()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropFunctionContext is an interface to support dynamic dispatch.
type IDropFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwDrop() IKwDropContext
	KwFunction() IKwFunctionContext
	Function_() IFunction_Context
	IfExist() IIfExistContext
	Keyspace() IKeyspaceContext
	DOT() antlr.TerminalNode

	// IsDropFunctionContext differentiates from other interfaces.
	IsDropFunctionContext()
}

type DropFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropFunctionContext() *DropFunctionContext {
	var p = new(DropFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_dropFunction
	return p
}

func InitEmptyDropFunctionContext(p *DropFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_dropFunction
}

func (*DropFunctionContext) IsDropFunctionContext() {}

func NewDropFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropFunctionContext {
	var p = new(DropFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_dropFunction

	return p
}

func (s *DropFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *DropFunctionContext) KwDrop() IKwDropContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwDropContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwDropContext)
}

func (s *DropFunctionContext) KwFunction() IKwFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwFunctionContext)
}

func (s *DropFunctionContext) Function_() IFunction_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunction_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunction_Context)
}

func (s *DropFunctionContext) IfExist() IIfExistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistContext)
}

func (s *DropFunctionContext) Keyspace() IKeyspaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyspaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyspaceContext)
}

func (s *DropFunctionContext) DOT() antlr.TerminalNode {
	return s.GetToken(CQLParserDOT, 0)
}

func (s *DropFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterDropFunction(s)
	}
}

func (s *DropFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitDropFunction(s)
	}
}

func (p *CQLParser) DropFunction() (localctx IDropFunctionContext) {
	localctx = NewDropFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, CQLParserRULE_dropFunction)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1192)
		p.KwDrop()
	}
	{
		p.SetState(1193)
		p.KwFunction()
	}
	p.SetState(1195)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CQLParserK_IF {
		{
			p.SetState(1194)
			p.IfExist()
		}

	}
	p.SetState(1200)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 74, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1197)
			p.Keyspace()
		}
		{
			p.SetState(1198)
			p.Match(CQLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1202)
		p.Function_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropTriggerContext is an interface to support dynamic dispatch.
type IDropTriggerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwDrop() IKwDropContext
	KwTrigger() IKwTriggerContext
	Trigger() ITriggerContext
	KwOn() IKwOnContext
	Table() ITableContext
	IfExist() IIfExistContext
	Keyspace() IKeyspaceContext
	DOT() antlr.TerminalNode

	// IsDropTriggerContext differentiates from other interfaces.
	IsDropTriggerContext()
}

type DropTriggerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropTriggerContext() *DropTriggerContext {
	var p = new(DropTriggerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_dropTrigger
	return p
}

func InitEmptyDropTriggerContext(p *DropTriggerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_dropTrigger
}

func (*DropTriggerContext) IsDropTriggerContext() {}

func NewDropTriggerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropTriggerContext {
	var p = new(DropTriggerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_dropTrigger

	return p
}

func (s *DropTriggerContext) GetParser() antlr.Parser { return s.parser }

func (s *DropTriggerContext) KwDrop() IKwDropContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwDropContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwDropContext)
}

func (s *DropTriggerContext) KwTrigger() IKwTriggerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwTriggerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwTriggerContext)
}

func (s *DropTriggerContext) Trigger() ITriggerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITriggerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITriggerContext)
}

func (s *DropTriggerContext) KwOn() IKwOnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwOnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwOnContext)
}

func (s *DropTriggerContext) Table() ITableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableContext)
}

func (s *DropTriggerContext) IfExist() IIfExistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistContext)
}

func (s *DropTriggerContext) Keyspace() IKeyspaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyspaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyspaceContext)
}

func (s *DropTriggerContext) DOT() antlr.TerminalNode {
	return s.GetToken(CQLParserDOT, 0)
}

func (s *DropTriggerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropTriggerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropTriggerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterDropTrigger(s)
	}
}

func (s *DropTriggerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitDropTrigger(s)
	}
}

func (p *CQLParser) DropTrigger() (localctx IDropTriggerContext) {
	localctx = NewDropTriggerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, CQLParserRULE_dropTrigger)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1204)
		p.KwDrop()
	}
	{
		p.SetState(1205)
		p.KwTrigger()
	}
	p.SetState(1207)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CQLParserK_IF {
		{
			p.SetState(1206)
			p.IfExist()
		}

	}
	{
		p.SetState(1209)
		p.Trigger()
	}
	{
		p.SetState(1210)
		p.KwOn()
	}
	p.SetState(1214)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 76, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1211)
			p.Keyspace()
		}
		{
			p.SetState(1212)
			p.Match(CQLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1216)
		p.Table()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropRoleContext is an interface to support dynamic dispatch.
type IDropRoleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwDrop() IKwDropContext
	KwRole() IKwRoleContext
	Role() IRoleContext
	IfExist() IIfExistContext

	// IsDropRoleContext differentiates from other interfaces.
	IsDropRoleContext()
}

type DropRoleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropRoleContext() *DropRoleContext {
	var p = new(DropRoleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_dropRole
	return p
}

func InitEmptyDropRoleContext(p *DropRoleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_dropRole
}

func (*DropRoleContext) IsDropRoleContext() {}

func NewDropRoleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropRoleContext {
	var p = new(DropRoleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_dropRole

	return p
}

func (s *DropRoleContext) GetParser() antlr.Parser { return s.parser }

func (s *DropRoleContext) KwDrop() IKwDropContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwDropContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwDropContext)
}

func (s *DropRoleContext) KwRole() IKwRoleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwRoleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwRoleContext)
}

func (s *DropRoleContext) Role() IRoleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleContext)
}

func (s *DropRoleContext) IfExist() IIfExistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistContext)
}

func (s *DropRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropRoleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropRoleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterDropRole(s)
	}
}

func (s *DropRoleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitDropRole(s)
	}
}

func (p *CQLParser) DropRole() (localctx IDropRoleContext) {
	localctx = NewDropRoleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, CQLParserRULE_dropRole)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1218)
		p.KwDrop()
	}
	{
		p.SetState(1219)
		p.KwRole()
	}
	p.SetState(1221)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CQLParserK_IF {
		{
			p.SetState(1220)
			p.IfExist()
		}

	}
	{
		p.SetState(1223)
		p.Role()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropTableContext is an interface to support dynamic dispatch.
type IDropTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwDrop() IKwDropContext
	KwTable() IKwTableContext
	Table() ITableContext
	IfExist() IIfExistContext
	Keyspace() IKeyspaceContext
	DOT() antlr.TerminalNode

	// IsDropTableContext differentiates from other interfaces.
	IsDropTableContext()
}

type DropTableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropTableContext() *DropTableContext {
	var p = new(DropTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_dropTable
	return p
}

func InitEmptyDropTableContext(p *DropTableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_dropTable
}

func (*DropTableContext) IsDropTableContext() {}

func NewDropTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropTableContext {
	var p = new(DropTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_dropTable

	return p
}

func (s *DropTableContext) GetParser() antlr.Parser { return s.parser }

func (s *DropTableContext) KwDrop() IKwDropContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwDropContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwDropContext)
}

func (s *DropTableContext) KwTable() IKwTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwTableContext)
}

func (s *DropTableContext) Table() ITableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableContext)
}

func (s *DropTableContext) IfExist() IIfExistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistContext)
}

func (s *DropTableContext) Keyspace() IKeyspaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyspaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyspaceContext)
}

func (s *DropTableContext) DOT() antlr.TerminalNode {
	return s.GetToken(CQLParserDOT, 0)
}

func (s *DropTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterDropTable(s)
	}
}

func (s *DropTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitDropTable(s)
	}
}

func (p *CQLParser) DropTable() (localctx IDropTableContext) {
	localctx = NewDropTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, CQLParserRULE_dropTable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1225)
		p.KwDrop()
	}
	{
		p.SetState(1226)
		p.KwTable()
	}
	p.SetState(1228)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CQLParserK_IF {
		{
			p.SetState(1227)
			p.IfExist()
		}

	}
	p.SetState(1233)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 79, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1230)
			p.Keyspace()
		}
		{
			p.SetState(1231)
			p.Match(CQLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1235)
		p.Table()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropKeyspaceContext is an interface to support dynamic dispatch.
type IDropKeyspaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwDrop() IKwDropContext
	KwKeyspace() IKwKeyspaceContext
	Keyspace() IKeyspaceContext
	IfExist() IIfExistContext

	// IsDropKeyspaceContext differentiates from other interfaces.
	IsDropKeyspaceContext()
}

type DropKeyspaceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropKeyspaceContext() *DropKeyspaceContext {
	var p = new(DropKeyspaceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_dropKeyspace
	return p
}

func InitEmptyDropKeyspaceContext(p *DropKeyspaceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_dropKeyspace
}

func (*DropKeyspaceContext) IsDropKeyspaceContext() {}

func NewDropKeyspaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropKeyspaceContext {
	var p = new(DropKeyspaceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_dropKeyspace

	return p
}

func (s *DropKeyspaceContext) GetParser() antlr.Parser { return s.parser }

func (s *DropKeyspaceContext) KwDrop() IKwDropContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwDropContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwDropContext)
}

func (s *DropKeyspaceContext) KwKeyspace() IKwKeyspaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwKeyspaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwKeyspaceContext)
}

func (s *DropKeyspaceContext) Keyspace() IKeyspaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyspaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyspaceContext)
}

func (s *DropKeyspaceContext) IfExist() IIfExistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistContext)
}

func (s *DropKeyspaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropKeyspaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropKeyspaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterDropKeyspace(s)
	}
}

func (s *DropKeyspaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitDropKeyspace(s)
	}
}

func (p *CQLParser) DropKeyspace() (localctx IDropKeyspaceContext) {
	localctx = NewDropKeyspaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, CQLParserRULE_dropKeyspace)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1237)
		p.KwDrop()
	}
	{
		p.SetState(1238)
		p.KwKeyspace()
	}
	p.SetState(1240)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CQLParserK_IF {
		{
			p.SetState(1239)
			p.IfExist()
		}

	}
	{
		p.SetState(1242)
		p.Keyspace()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropIndexContext is an interface to support dynamic dispatch.
type IDropIndexContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwDrop() IKwDropContext
	KwIndex() IKwIndexContext
	IndexName() IIndexNameContext
	IfExist() IIfExistContext
	Keyspace() IKeyspaceContext
	DOT() antlr.TerminalNode

	// IsDropIndexContext differentiates from other interfaces.
	IsDropIndexContext()
}

type DropIndexContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropIndexContext() *DropIndexContext {
	var p = new(DropIndexContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_dropIndex
	return p
}

func InitEmptyDropIndexContext(p *DropIndexContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_dropIndex
}

func (*DropIndexContext) IsDropIndexContext() {}

func NewDropIndexContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropIndexContext {
	var p = new(DropIndexContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_dropIndex

	return p
}

func (s *DropIndexContext) GetParser() antlr.Parser { return s.parser }

func (s *DropIndexContext) KwDrop() IKwDropContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwDropContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwDropContext)
}

func (s *DropIndexContext) KwIndex() IKwIndexContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwIndexContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwIndexContext)
}

func (s *DropIndexContext) IndexName() IIndexNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexNameContext)
}

func (s *DropIndexContext) IfExist() IIfExistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistContext)
}

func (s *DropIndexContext) Keyspace() IKeyspaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyspaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyspaceContext)
}

func (s *DropIndexContext) DOT() antlr.TerminalNode {
	return s.GetToken(CQLParserDOT, 0)
}

func (s *DropIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropIndexContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterDropIndex(s)
	}
}

func (s *DropIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitDropIndex(s)
	}
}

func (p *CQLParser) DropIndex() (localctx IDropIndexContext) {
	localctx = NewDropIndexContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, CQLParserRULE_dropIndex)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1244)
		p.KwDrop()
	}
	{
		p.SetState(1245)
		p.KwIndex()
	}
	p.SetState(1247)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CQLParserK_IF {
		{
			p.SetState(1246)
			p.IfExist()
		}

	}
	p.SetState(1252)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 82, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1249)
			p.Keyspace()
		}
		{
			p.SetState(1250)
			p.Match(CQLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1254)
		p.IndexName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateTableContext is an interface to support dynamic dispatch.
type ICreateTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwCreate() IKwCreateContext
	KwTable() IKwTableContext
	Table() ITableContext
	SyntaxBracketLr() ISyntaxBracketLrContext
	ColumnDefinitionList() IColumnDefinitionListContext
	SyntaxBracketRr() ISyntaxBracketRrContext
	IfNotExist() IIfNotExistContext
	Keyspace() IKeyspaceContext
	DOT() antlr.TerminalNode
	WithElement() IWithElementContext

	// IsCreateTableContext differentiates from other interfaces.
	IsCreateTableContext()
}

type CreateTableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateTableContext() *CreateTableContext {
	var p = new(CreateTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_createTable
	return p
}

func InitEmptyCreateTableContext(p *CreateTableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_createTable
}

func (*CreateTableContext) IsCreateTableContext() {}

func NewCreateTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateTableContext {
	var p = new(CreateTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_createTable

	return p
}

func (s *CreateTableContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateTableContext) KwCreate() IKwCreateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwCreateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwCreateContext)
}

func (s *CreateTableContext) KwTable() IKwTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwTableContext)
}

func (s *CreateTableContext) Table() ITableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableContext)
}

func (s *CreateTableContext) SyntaxBracketLr() ISyntaxBracketLrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketLrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketLrContext)
}

func (s *CreateTableContext) ColumnDefinitionList() IColumnDefinitionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDefinitionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDefinitionListContext)
}

func (s *CreateTableContext) SyntaxBracketRr() ISyntaxBracketRrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketRrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketRrContext)
}

func (s *CreateTableContext) IfNotExist() IIfNotExistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistContext)
}

func (s *CreateTableContext) Keyspace() IKeyspaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyspaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyspaceContext)
}

func (s *CreateTableContext) DOT() antlr.TerminalNode {
	return s.GetToken(CQLParserDOT, 0)
}

func (s *CreateTableContext) WithElement() IWithElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithElementContext)
}

func (s *CreateTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterCreateTable(s)
	}
}

func (s *CreateTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitCreateTable(s)
	}
}

func (p *CQLParser) CreateTable() (localctx ICreateTableContext) {
	localctx = NewCreateTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, CQLParserRULE_createTable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1256)
		p.KwCreate()
	}
	{
		p.SetState(1257)
		p.KwTable()
	}
	p.SetState(1259)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CQLParserK_IF {
		{
			p.SetState(1258)
			p.IfNotExist()
		}

	}
	p.SetState(1264)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 84, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1261)
			p.Keyspace()
		}
		{
			p.SetState(1262)
			p.Match(CQLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1266)
		p.Table()
	}
	{
		p.SetState(1267)
		p.SyntaxBracketLr()
	}
	{
		p.SetState(1268)
		p.ColumnDefinitionList()
	}
	{
		p.SetState(1269)
		p.SyntaxBracketRr()
	}
	p.SetState(1271)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CQLParserK_WITH {
		{
			p.SetState(1270)
			p.WithElement()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWithElementContext is an interface to support dynamic dispatch.
type IWithElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwWith() IKwWithContext
	TableOptions() ITableOptionsContext

	// IsWithElementContext differentiates from other interfaces.
	IsWithElementContext()
}

type WithElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithElementContext() *WithElementContext {
	var p = new(WithElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_withElement
	return p
}

func InitEmptyWithElementContext(p *WithElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_withElement
}

func (*WithElementContext) IsWithElementContext() {}

func NewWithElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithElementContext {
	var p = new(WithElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_withElement

	return p
}

func (s *WithElementContext) GetParser() antlr.Parser { return s.parser }

func (s *WithElementContext) KwWith() IKwWithContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwWithContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwWithContext)
}

func (s *WithElementContext) TableOptions() ITableOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableOptionsContext)
}

func (s *WithElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterWithElement(s)
	}
}

func (s *WithElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitWithElement(s)
	}
}

func (p *CQLParser) WithElement() (localctx IWithElementContext) {
	localctx = NewWithElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, CQLParserRULE_withElement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1273)
		p.KwWith()
	}
	{
		p.SetState(1274)
		p.TableOptions()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableOptionsContext is an interface to support dynamic dispatch.
type ITableOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwCompact() IKwCompactContext
	KwStorage() IKwStorageContext
	AllKwAnd() []IKwAndContext
	KwAnd(i int) IKwAndContext
	TableOptions() ITableOptionsContext
	ClusteringOrder() IClusteringOrderContext
	AllTableOptionItem() []ITableOptionItemContext
	TableOptionItem(i int) ITableOptionItemContext
	KwTtl() IKwTtlContext

	// IsTableOptionsContext differentiates from other interfaces.
	IsTableOptionsContext()
}

type TableOptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableOptionsContext() *TableOptionsContext {
	var p = new(TableOptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_tableOptions
	return p
}

func InitEmptyTableOptionsContext(p *TableOptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_tableOptions
}

func (*TableOptionsContext) IsTableOptionsContext() {}

func NewTableOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableOptionsContext {
	var p = new(TableOptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_tableOptions

	return p
}

func (s *TableOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *TableOptionsContext) KwCompact() IKwCompactContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwCompactContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwCompactContext)
}

func (s *TableOptionsContext) KwStorage() IKwStorageContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwStorageContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwStorageContext)
}

func (s *TableOptionsContext) AllKwAnd() []IKwAndContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IKwAndContext); ok {
			len++
		}
	}

	tst := make([]IKwAndContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IKwAndContext); ok {
			tst[i] = t.(IKwAndContext)
			i++
		}
	}

	return tst
}

func (s *TableOptionsContext) KwAnd(i int) IKwAndContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAndContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAndContext)
}

func (s *TableOptionsContext) TableOptions() ITableOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableOptionsContext)
}

func (s *TableOptionsContext) ClusteringOrder() IClusteringOrderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClusteringOrderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClusteringOrderContext)
}

func (s *TableOptionsContext) AllTableOptionItem() []ITableOptionItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableOptionItemContext); ok {
			len++
		}
	}

	tst := make([]ITableOptionItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableOptionItemContext); ok {
			tst[i] = t.(ITableOptionItemContext)
			i++
		}
	}

	return tst
}

func (s *TableOptionsContext) TableOptionItem(i int) ITableOptionItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableOptionItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableOptionItemContext)
}

func (s *TableOptionsContext) KwTtl() IKwTtlContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwTtlContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwTtlContext)
}

func (s *TableOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterTableOptions(s)
	}
}

func (s *TableOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitTableOptions(s)
	}
}

func (p *CQLParser) TableOptions() (localctx ITableOptionsContext) {
	localctx = NewTableOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, CQLParserRULE_tableOptions)
	var _alt int

	p.SetState(1299)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CQLParserK_COMPACT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1276)
			p.KwCompact()
		}
		{
			p.SetState(1277)
			p.KwStorage()
		}
		p.SetState(1281)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 86, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1278)
				p.KwAnd()
			}
			{
				p.SetState(1279)
				p.TableOptions()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case CQLParserK_CLUSTERING:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1283)
			p.ClusteringOrder()
		}
		p.SetState(1287)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 87, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1284)
				p.KwAnd()
			}
			{
				p.SetState(1285)
				p.TableOptions()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case CQLParserOBJECT_NAME:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1289)
			p.TableOptionItem()
		}
		p.SetState(1295)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 88, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1290)
					p.KwAnd()
				}
				{
					p.SetState(1291)
					p.TableOptionItem()
				}

			}
			p.SetState(1297)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 88, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case CQLParserK_TTL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1298)
			p.KwTtl()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClusteringOrderContext is an interface to support dynamic dispatch.
type IClusteringOrderContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwClustering() IKwClusteringContext
	KwOrder() IKwOrderContext
	KwBy() IKwByContext
	SyntaxBracketLr() ISyntaxBracketLrContext
	SyntaxBracketRr() ISyntaxBracketRrContext
	AllColumn() []IColumnContext
	Column(i int) IColumnContext
	AllSyntaxComma() []ISyntaxCommaContext
	SyntaxComma(i int) ISyntaxCommaContext
	AllOrderDirection() []IOrderDirectionContext
	OrderDirection(i int) IOrderDirectionContext

	// IsClusteringOrderContext differentiates from other interfaces.
	IsClusteringOrderContext()
}

type ClusteringOrderContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClusteringOrderContext() *ClusteringOrderContext {
	var p = new(ClusteringOrderContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_clusteringOrder
	return p
}

func InitEmptyClusteringOrderContext(p *ClusteringOrderContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_clusteringOrder
}

func (*ClusteringOrderContext) IsClusteringOrderContext() {}

func NewClusteringOrderContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClusteringOrderContext {
	var p = new(ClusteringOrderContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_clusteringOrder

	return p
}

func (s *ClusteringOrderContext) GetParser() antlr.Parser { return s.parser }

func (s *ClusteringOrderContext) KwClustering() IKwClusteringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwClusteringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwClusteringContext)
}

func (s *ClusteringOrderContext) KwOrder() IKwOrderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwOrderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwOrderContext)
}

func (s *ClusteringOrderContext) KwBy() IKwByContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwByContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwByContext)
}

func (s *ClusteringOrderContext) SyntaxBracketLr() ISyntaxBracketLrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketLrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketLrContext)
}

func (s *ClusteringOrderContext) SyntaxBracketRr() ISyntaxBracketRrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketRrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketRrContext)
}

func (s *ClusteringOrderContext) AllColumn() []IColumnContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnContext); ok {
			len++
		}
	}

	tst := make([]IColumnContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnContext); ok {
			tst[i] = t.(IColumnContext)
			i++
		}
	}

	return tst
}

func (s *ClusteringOrderContext) Column(i int) IColumnContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnContext)
}

func (s *ClusteringOrderContext) AllSyntaxComma() []ISyntaxCommaContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			len++
		}
	}

	tst := make([]ISyntaxCommaContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISyntaxCommaContext); ok {
			tst[i] = t.(ISyntaxCommaContext)
			i++
		}
	}

	return tst
}

func (s *ClusteringOrderContext) SyntaxComma(i int) ISyntaxCommaContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxCommaContext)
}

func (s *ClusteringOrderContext) AllOrderDirection() []IOrderDirectionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOrderDirectionContext); ok {
			len++
		}
	}

	tst := make([]IOrderDirectionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOrderDirectionContext); ok {
			tst[i] = t.(IOrderDirectionContext)
			i++
		}
	}

	return tst
}

func (s *ClusteringOrderContext) OrderDirection(i int) IOrderDirectionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderDirectionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderDirectionContext)
}

func (s *ClusteringOrderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClusteringOrderContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClusteringOrderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterClusteringOrder(s)
	}
}

func (s *ClusteringOrderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitClusteringOrder(s)
	}
}

func (p *CQLParser) ClusteringOrder() (localctx IClusteringOrderContext) {
	localctx = NewClusteringOrderContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, CQLParserRULE_clusteringOrder)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1301)
		p.KwClustering()
	}
	{
		p.SetState(1302)
		p.KwOrder()
	}
	{
		p.SetState(1303)
		p.KwBy()
	}
	{
		p.SetState(1304)
		p.SyntaxBracketLr()
	}

	{
		p.SetState(1305)
		p.Column()
	}
	p.SetState(1307)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CQLParserK_ASC || _la == CQLParserK_DESC {
		{
			p.SetState(1306)
			p.OrderDirection()
		}

	}

	p.SetState(1316)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CQLParserCOMMA {
		{
			p.SetState(1309)
			p.SyntaxComma()
		}
		{
			p.SetState(1310)
			p.Column()
		}
		p.SetState(1312)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CQLParserK_ASC || _la == CQLParserK_DESC {
			{
				p.SetState(1311)
				p.OrderDirection()
			}

		}

		p.SetState(1318)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1319)
		p.SyntaxBracketRr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableOptionItemContext is an interface to support dynamic dispatch.
type ITableOptionItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TableOptionName() ITableOptionNameContext
	OPERATOR_EQ() antlr.TerminalNode
	TableOptionValue() ITableOptionValueContext
	OptionHash() IOptionHashContext

	// IsTableOptionItemContext differentiates from other interfaces.
	IsTableOptionItemContext()
}

type TableOptionItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableOptionItemContext() *TableOptionItemContext {
	var p = new(TableOptionItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_tableOptionItem
	return p
}

func InitEmptyTableOptionItemContext(p *TableOptionItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_tableOptionItem
}

func (*TableOptionItemContext) IsTableOptionItemContext() {}

func NewTableOptionItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableOptionItemContext {
	var p = new(TableOptionItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_tableOptionItem

	return p
}

func (s *TableOptionItemContext) GetParser() antlr.Parser { return s.parser }

func (s *TableOptionItemContext) TableOptionName() ITableOptionNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableOptionNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableOptionNameContext)
}

func (s *TableOptionItemContext) OPERATOR_EQ() antlr.TerminalNode {
	return s.GetToken(CQLParserOPERATOR_EQ, 0)
}

func (s *TableOptionItemContext) TableOptionValue() ITableOptionValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableOptionValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableOptionValueContext)
}

func (s *TableOptionItemContext) OptionHash() IOptionHashContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptionHashContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptionHashContext)
}

func (s *TableOptionItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableOptionItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterTableOptionItem(s)
	}
}

func (s *TableOptionItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitTableOptionItem(s)
	}
}

func (p *CQLParser) TableOptionItem() (localctx ITableOptionItemContext) {
	localctx = NewTableOptionItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, CQLParserRULE_tableOptionItem)
	p.SetState(1329)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 93, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1321)
			p.TableOptionName()
		}
		{
			p.SetState(1322)
			p.Match(CQLParserOPERATOR_EQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1323)
			p.TableOptionValue()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1325)
			p.TableOptionName()
		}
		{
			p.SetState(1326)
			p.Match(CQLParserOPERATOR_EQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1327)
			p.OptionHash()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableOptionNameContext is an interface to support dynamic dispatch.
type ITableOptionNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OBJECT_NAME() antlr.TerminalNode

	// IsTableOptionNameContext differentiates from other interfaces.
	IsTableOptionNameContext()
}

type TableOptionNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableOptionNameContext() *TableOptionNameContext {
	var p = new(TableOptionNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_tableOptionName
	return p
}

func InitEmptyTableOptionNameContext(p *TableOptionNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_tableOptionName
}

func (*TableOptionNameContext) IsTableOptionNameContext() {}

func NewTableOptionNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableOptionNameContext {
	var p = new(TableOptionNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_tableOptionName

	return p
}

func (s *TableOptionNameContext) GetParser() antlr.Parser { return s.parser }

func (s *TableOptionNameContext) OBJECT_NAME() antlr.TerminalNode {
	return s.GetToken(CQLParserOBJECT_NAME, 0)
}

func (s *TableOptionNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableOptionNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterTableOptionName(s)
	}
}

func (s *TableOptionNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitTableOptionName(s)
	}
}

func (p *CQLParser) TableOptionName() (localctx ITableOptionNameContext) {
	localctx = NewTableOptionNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, CQLParserRULE_tableOptionName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1331)
		p.Match(CQLParserOBJECT_NAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableOptionValueContext is an interface to support dynamic dispatch.
type ITableOptionValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StringLiteral() IStringLiteralContext
	FloatLiteral() IFloatLiteralContext

	// IsTableOptionValueContext differentiates from other interfaces.
	IsTableOptionValueContext()
}

type TableOptionValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableOptionValueContext() *TableOptionValueContext {
	var p = new(TableOptionValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_tableOptionValue
	return p
}

func InitEmptyTableOptionValueContext(p *TableOptionValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_tableOptionValue
}

func (*TableOptionValueContext) IsTableOptionValueContext() {}

func NewTableOptionValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableOptionValueContext {
	var p = new(TableOptionValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_tableOptionValue

	return p
}

func (s *TableOptionValueContext) GetParser() antlr.Parser { return s.parser }

func (s *TableOptionValueContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *TableOptionValueContext) FloatLiteral() IFloatLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFloatLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFloatLiteralContext)
}

func (s *TableOptionValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOptionValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableOptionValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterTableOptionValue(s)
	}
}

func (s *TableOptionValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitTableOptionValue(s)
	}
}

func (p *CQLParser) TableOptionValue() (localctx ITableOptionValueContext) {
	localctx = NewTableOptionValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, CQLParserRULE_tableOptionValue)
	p.SetState(1335)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CQLParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1333)
			p.StringLiteral()
		}

	case CQLParserDECIMAL_LITERAL, CQLParserFLOAT_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1334)
			p.FloatLiteral()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOptionHashContext is an interface to support dynamic dispatch.
type IOptionHashContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SyntaxBracketLc() ISyntaxBracketLcContext
	AllOptionHashItem() []IOptionHashItemContext
	OptionHashItem(i int) IOptionHashItemContext
	SyntaxBracketRc() ISyntaxBracketRcContext
	AllSyntaxComma() []ISyntaxCommaContext
	SyntaxComma(i int) ISyntaxCommaContext

	// IsOptionHashContext differentiates from other interfaces.
	IsOptionHashContext()
}

type OptionHashContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptionHashContext() *OptionHashContext {
	var p = new(OptionHashContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_optionHash
	return p
}

func InitEmptyOptionHashContext(p *OptionHashContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_optionHash
}

func (*OptionHashContext) IsOptionHashContext() {}

func NewOptionHashContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptionHashContext {
	var p = new(OptionHashContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_optionHash

	return p
}

func (s *OptionHashContext) GetParser() antlr.Parser { return s.parser }

func (s *OptionHashContext) SyntaxBracketLc() ISyntaxBracketLcContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketLcContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketLcContext)
}

func (s *OptionHashContext) AllOptionHashItem() []IOptionHashItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOptionHashItemContext); ok {
			len++
		}
	}

	tst := make([]IOptionHashItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOptionHashItemContext); ok {
			tst[i] = t.(IOptionHashItemContext)
			i++
		}
	}

	return tst
}

func (s *OptionHashContext) OptionHashItem(i int) IOptionHashItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptionHashItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptionHashItemContext)
}

func (s *OptionHashContext) SyntaxBracketRc() ISyntaxBracketRcContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketRcContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketRcContext)
}

func (s *OptionHashContext) AllSyntaxComma() []ISyntaxCommaContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			len++
		}
	}

	tst := make([]ISyntaxCommaContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISyntaxCommaContext); ok {
			tst[i] = t.(ISyntaxCommaContext)
			i++
		}
	}

	return tst
}

func (s *OptionHashContext) SyntaxComma(i int) ISyntaxCommaContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxCommaContext)
}

func (s *OptionHashContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptionHashContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptionHashContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterOptionHash(s)
	}
}

func (s *OptionHashContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitOptionHash(s)
	}
}

func (p *CQLParser) OptionHash() (localctx IOptionHashContext) {
	localctx = NewOptionHashContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, CQLParserRULE_optionHash)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1337)
		p.SyntaxBracketLc()
	}
	{
		p.SetState(1338)
		p.OptionHashItem()
	}
	p.SetState(1344)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CQLParserCOMMA {
		{
			p.SetState(1339)
			p.SyntaxComma()
		}
		{
			p.SetState(1340)
			p.OptionHashItem()
		}

		p.SetState(1346)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1347)
		p.SyntaxBracketRc()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOptionHashItemContext is an interface to support dynamic dispatch.
type IOptionHashItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OptionHashKey() IOptionHashKeyContext
	COLON() antlr.TerminalNode
	OptionHashValue() IOptionHashValueContext

	// IsOptionHashItemContext differentiates from other interfaces.
	IsOptionHashItemContext()
}

type OptionHashItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptionHashItemContext() *OptionHashItemContext {
	var p = new(OptionHashItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_optionHashItem
	return p
}

func InitEmptyOptionHashItemContext(p *OptionHashItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_optionHashItem
}

func (*OptionHashItemContext) IsOptionHashItemContext() {}

func NewOptionHashItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptionHashItemContext {
	var p = new(OptionHashItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_optionHashItem

	return p
}

func (s *OptionHashItemContext) GetParser() antlr.Parser { return s.parser }

func (s *OptionHashItemContext) OptionHashKey() IOptionHashKeyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptionHashKeyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptionHashKeyContext)
}

func (s *OptionHashItemContext) COLON() antlr.TerminalNode {
	return s.GetToken(CQLParserCOLON, 0)
}

func (s *OptionHashItemContext) OptionHashValue() IOptionHashValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptionHashValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptionHashValueContext)
}

func (s *OptionHashItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptionHashItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptionHashItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterOptionHashItem(s)
	}
}

func (s *OptionHashItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitOptionHashItem(s)
	}
}

func (p *CQLParser) OptionHashItem() (localctx IOptionHashItemContext) {
	localctx = NewOptionHashItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, CQLParserRULE_optionHashItem)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1349)
		p.OptionHashKey()
	}
	{
		p.SetState(1350)
		p.Match(CQLParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1351)
		p.OptionHashValue()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOptionHashKeyContext is an interface to support dynamic dispatch.
type IOptionHashKeyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StringLiteral() IStringLiteralContext

	// IsOptionHashKeyContext differentiates from other interfaces.
	IsOptionHashKeyContext()
}

type OptionHashKeyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptionHashKeyContext() *OptionHashKeyContext {
	var p = new(OptionHashKeyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_optionHashKey
	return p
}

func InitEmptyOptionHashKeyContext(p *OptionHashKeyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_optionHashKey
}

func (*OptionHashKeyContext) IsOptionHashKeyContext() {}

func NewOptionHashKeyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptionHashKeyContext {
	var p = new(OptionHashKeyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_optionHashKey

	return p
}

func (s *OptionHashKeyContext) GetParser() antlr.Parser { return s.parser }

func (s *OptionHashKeyContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *OptionHashKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptionHashKeyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptionHashKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterOptionHashKey(s)
	}
}

func (s *OptionHashKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitOptionHashKey(s)
	}
}

func (p *CQLParser) OptionHashKey() (localctx IOptionHashKeyContext) {
	localctx = NewOptionHashKeyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, CQLParserRULE_optionHashKey)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1353)
		p.StringLiteral()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOptionHashValueContext is an interface to support dynamic dispatch.
type IOptionHashValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StringLiteral() IStringLiteralContext
	FloatLiteral() IFloatLiteralContext

	// IsOptionHashValueContext differentiates from other interfaces.
	IsOptionHashValueContext()
}

type OptionHashValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptionHashValueContext() *OptionHashValueContext {
	var p = new(OptionHashValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_optionHashValue
	return p
}

func InitEmptyOptionHashValueContext(p *OptionHashValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_optionHashValue
}

func (*OptionHashValueContext) IsOptionHashValueContext() {}

func NewOptionHashValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptionHashValueContext {
	var p = new(OptionHashValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_optionHashValue

	return p
}

func (s *OptionHashValueContext) GetParser() antlr.Parser { return s.parser }

func (s *OptionHashValueContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *OptionHashValueContext) FloatLiteral() IFloatLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFloatLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFloatLiteralContext)
}

func (s *OptionHashValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptionHashValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptionHashValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterOptionHashValue(s)
	}
}

func (s *OptionHashValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitOptionHashValue(s)
	}
}

func (p *CQLParser) OptionHashValue() (localctx IOptionHashValueContext) {
	localctx = NewOptionHashValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, CQLParserRULE_optionHashValue)
	p.SetState(1357)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CQLParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1355)
			p.StringLiteral()
		}

	case CQLParserDECIMAL_LITERAL, CQLParserFLOAT_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1356)
			p.FloatLiteral()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnDefinitionListContext is an interface to support dynamic dispatch.
type IColumnDefinitionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllColumnDefinition() []IColumnDefinitionContext
	ColumnDefinition(i int) IColumnDefinitionContext
	AllSyntaxComma() []ISyntaxCommaContext
	SyntaxComma(i int) ISyntaxCommaContext
	PrimaryKeyElement() IPrimaryKeyElementContext

	// IsColumnDefinitionListContext differentiates from other interfaces.
	IsColumnDefinitionListContext()
}

type ColumnDefinitionListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnDefinitionListContext() *ColumnDefinitionListContext {
	var p = new(ColumnDefinitionListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_columnDefinitionList
	return p
}

func InitEmptyColumnDefinitionListContext(p *ColumnDefinitionListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_columnDefinitionList
}

func (*ColumnDefinitionListContext) IsColumnDefinitionListContext() {}

func NewColumnDefinitionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnDefinitionListContext {
	var p = new(ColumnDefinitionListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_columnDefinitionList

	return p
}

func (s *ColumnDefinitionListContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnDefinitionListContext) AllColumnDefinition() []IColumnDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IColumnDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnDefinitionContext); ok {
			tst[i] = t.(IColumnDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *ColumnDefinitionListContext) ColumnDefinition(i int) IColumnDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDefinitionContext)
}

func (s *ColumnDefinitionListContext) AllSyntaxComma() []ISyntaxCommaContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			len++
		}
	}

	tst := make([]ISyntaxCommaContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISyntaxCommaContext); ok {
			tst[i] = t.(ISyntaxCommaContext)
			i++
		}
	}

	return tst
}

func (s *ColumnDefinitionListContext) SyntaxComma(i int) ISyntaxCommaContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxCommaContext)
}

func (s *ColumnDefinitionListContext) PrimaryKeyElement() IPrimaryKeyElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryKeyElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryKeyElementContext)
}

func (s *ColumnDefinitionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnDefinitionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnDefinitionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterColumnDefinitionList(s)
	}
}

func (s *ColumnDefinitionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitColumnDefinitionList(s)
	}
}

func (p *CQLParser) ColumnDefinitionList() (localctx IColumnDefinitionListContext) {
	localctx = NewColumnDefinitionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, CQLParserRULE_columnDefinitionList)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1359)
		p.ColumnDefinition()
	}

	p.SetState(1365)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 97, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1360)
				p.SyntaxComma()
			}
			{
				p.SetState(1361)
				p.ColumnDefinition()
			}

		}
		p.SetState(1367)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 97, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1371)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CQLParserCOMMA {
		{
			p.SetState(1368)
			p.SyntaxComma()
		}
		{
			p.SetState(1369)
			p.PrimaryKeyElement()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnDefinitionContext is an interface to support dynamic dispatch.
type IColumnDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Column() IColumnContext
	DataType() IDataTypeContext
	PrimaryKeyColumn() IPrimaryKeyColumnContext

	// IsColumnDefinitionContext differentiates from other interfaces.
	IsColumnDefinitionContext()
}

type ColumnDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnDefinitionContext() *ColumnDefinitionContext {
	var p = new(ColumnDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_columnDefinition
	return p
}

func InitEmptyColumnDefinitionContext(p *ColumnDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_columnDefinition
}

func (*ColumnDefinitionContext) IsColumnDefinitionContext() {}

func NewColumnDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnDefinitionContext {
	var p = new(ColumnDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_columnDefinition

	return p
}

func (s *ColumnDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnDefinitionContext) Column() IColumnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnContext)
}

func (s *ColumnDefinitionContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *ColumnDefinitionContext) PrimaryKeyColumn() IPrimaryKeyColumnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryKeyColumnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryKeyColumnContext)
}

func (s *ColumnDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterColumnDefinition(s)
	}
}

func (s *ColumnDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitColumnDefinition(s)
	}
}

func (p *CQLParser) ColumnDefinition() (localctx IColumnDefinitionContext) {
	localctx = NewColumnDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, CQLParserRULE_columnDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1373)
		p.Column()
	}
	{
		p.SetState(1374)
		p.DataType()
	}
	p.SetState(1376)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CQLParserK_PRIMARY {
		{
			p.SetState(1375)
			p.PrimaryKeyColumn()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrimaryKeyColumnContext is an interface to support dynamic dispatch.
type IPrimaryKeyColumnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwPrimary() IKwPrimaryContext
	KwKey() IKwKeyContext

	// IsPrimaryKeyColumnContext differentiates from other interfaces.
	IsPrimaryKeyColumnContext()
}

type PrimaryKeyColumnContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryKeyColumnContext() *PrimaryKeyColumnContext {
	var p = new(PrimaryKeyColumnContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_primaryKeyColumn
	return p
}

func InitEmptyPrimaryKeyColumnContext(p *PrimaryKeyColumnContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_primaryKeyColumn
}

func (*PrimaryKeyColumnContext) IsPrimaryKeyColumnContext() {}

func NewPrimaryKeyColumnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryKeyColumnContext {
	var p = new(PrimaryKeyColumnContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_primaryKeyColumn

	return p
}

func (s *PrimaryKeyColumnContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryKeyColumnContext) KwPrimary() IKwPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwPrimaryContext)
}

func (s *PrimaryKeyColumnContext) KwKey() IKwKeyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwKeyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwKeyContext)
}

func (s *PrimaryKeyColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryKeyColumnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimaryKeyColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterPrimaryKeyColumn(s)
	}
}

func (s *PrimaryKeyColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitPrimaryKeyColumn(s)
	}
}

func (p *CQLParser) PrimaryKeyColumn() (localctx IPrimaryKeyColumnContext) {
	localctx = NewPrimaryKeyColumnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, CQLParserRULE_primaryKeyColumn)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1378)
		p.KwPrimary()
	}
	{
		p.SetState(1379)
		p.KwKey()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrimaryKeyElementContext is an interface to support dynamic dispatch.
type IPrimaryKeyElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwPrimary() IKwPrimaryContext
	KwKey() IKwKeyContext
	SyntaxBracketLr() ISyntaxBracketLrContext
	PrimaryKeyDefinition() IPrimaryKeyDefinitionContext
	SyntaxBracketRr() ISyntaxBracketRrContext

	// IsPrimaryKeyElementContext differentiates from other interfaces.
	IsPrimaryKeyElementContext()
}

type PrimaryKeyElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryKeyElementContext() *PrimaryKeyElementContext {
	var p = new(PrimaryKeyElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_primaryKeyElement
	return p
}

func InitEmptyPrimaryKeyElementContext(p *PrimaryKeyElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_primaryKeyElement
}

func (*PrimaryKeyElementContext) IsPrimaryKeyElementContext() {}

func NewPrimaryKeyElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryKeyElementContext {
	var p = new(PrimaryKeyElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_primaryKeyElement

	return p
}

func (s *PrimaryKeyElementContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryKeyElementContext) KwPrimary() IKwPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwPrimaryContext)
}

func (s *PrimaryKeyElementContext) KwKey() IKwKeyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwKeyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwKeyContext)
}

func (s *PrimaryKeyElementContext) SyntaxBracketLr() ISyntaxBracketLrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketLrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketLrContext)
}

func (s *PrimaryKeyElementContext) PrimaryKeyDefinition() IPrimaryKeyDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryKeyDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryKeyDefinitionContext)
}

func (s *PrimaryKeyElementContext) SyntaxBracketRr() ISyntaxBracketRrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketRrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketRrContext)
}

func (s *PrimaryKeyElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryKeyElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimaryKeyElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterPrimaryKeyElement(s)
	}
}

func (s *PrimaryKeyElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitPrimaryKeyElement(s)
	}
}

func (p *CQLParser) PrimaryKeyElement() (localctx IPrimaryKeyElementContext) {
	localctx = NewPrimaryKeyElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, CQLParserRULE_primaryKeyElement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1381)
		p.KwPrimary()
	}
	{
		p.SetState(1382)
		p.KwKey()
	}
	{
		p.SetState(1383)
		p.SyntaxBracketLr()
	}
	{
		p.SetState(1384)
		p.PrimaryKeyDefinition()
	}
	{
		p.SetState(1385)
		p.SyntaxBracketRr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrimaryKeyDefinitionContext is an interface to support dynamic dispatch.
type IPrimaryKeyDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SinglePrimaryKey() ISinglePrimaryKeyContext
	CompoundKey() ICompoundKeyContext
	CompositeKey() ICompositeKeyContext

	// IsPrimaryKeyDefinitionContext differentiates from other interfaces.
	IsPrimaryKeyDefinitionContext()
}

type PrimaryKeyDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryKeyDefinitionContext() *PrimaryKeyDefinitionContext {
	var p = new(PrimaryKeyDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_primaryKeyDefinition
	return p
}

func InitEmptyPrimaryKeyDefinitionContext(p *PrimaryKeyDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_primaryKeyDefinition
}

func (*PrimaryKeyDefinitionContext) IsPrimaryKeyDefinitionContext() {}

func NewPrimaryKeyDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryKeyDefinitionContext {
	var p = new(PrimaryKeyDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_primaryKeyDefinition

	return p
}

func (s *PrimaryKeyDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryKeyDefinitionContext) SinglePrimaryKey() ISinglePrimaryKeyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISinglePrimaryKeyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISinglePrimaryKeyContext)
}

func (s *PrimaryKeyDefinitionContext) CompoundKey() ICompoundKeyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompoundKeyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompoundKeyContext)
}

func (s *PrimaryKeyDefinitionContext) CompositeKey() ICompositeKeyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompositeKeyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompositeKeyContext)
}

func (s *PrimaryKeyDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryKeyDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimaryKeyDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterPrimaryKeyDefinition(s)
	}
}

func (s *PrimaryKeyDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitPrimaryKeyDefinition(s)
	}
}

func (p *CQLParser) PrimaryKeyDefinition() (localctx IPrimaryKeyDefinitionContext) {
	localctx = NewPrimaryKeyDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, CQLParserRULE_primaryKeyDefinition)
	p.SetState(1390)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 100, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1387)
			p.SinglePrimaryKey()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1388)
			p.CompoundKey()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1389)
			p.CompositeKey()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISinglePrimaryKeyContext is an interface to support dynamic dispatch.
type ISinglePrimaryKeyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Column() IColumnContext

	// IsSinglePrimaryKeyContext differentiates from other interfaces.
	IsSinglePrimaryKeyContext()
}

type SinglePrimaryKeyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySinglePrimaryKeyContext() *SinglePrimaryKeyContext {
	var p = new(SinglePrimaryKeyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_singlePrimaryKey
	return p
}

func InitEmptySinglePrimaryKeyContext(p *SinglePrimaryKeyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_singlePrimaryKey
}

func (*SinglePrimaryKeyContext) IsSinglePrimaryKeyContext() {}

func NewSinglePrimaryKeyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SinglePrimaryKeyContext {
	var p = new(SinglePrimaryKeyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_singlePrimaryKey

	return p
}

func (s *SinglePrimaryKeyContext) GetParser() antlr.Parser { return s.parser }

func (s *SinglePrimaryKeyContext) Column() IColumnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnContext)
}

func (s *SinglePrimaryKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SinglePrimaryKeyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SinglePrimaryKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterSinglePrimaryKey(s)
	}
}

func (s *SinglePrimaryKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitSinglePrimaryKey(s)
	}
}

func (p *CQLParser) SinglePrimaryKey() (localctx ISinglePrimaryKeyContext) {
	localctx = NewSinglePrimaryKeyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, CQLParserRULE_singlePrimaryKey)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1392)
		p.Column()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICompoundKeyContext is an interface to support dynamic dispatch.
type ICompoundKeyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PartitionKey() IPartitionKeyContext
	SyntaxComma() ISyntaxCommaContext
	ClusteringKeyList() IClusteringKeyListContext

	// IsCompoundKeyContext differentiates from other interfaces.
	IsCompoundKeyContext()
}

type CompoundKeyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompoundKeyContext() *CompoundKeyContext {
	var p = new(CompoundKeyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_compoundKey
	return p
}

func InitEmptyCompoundKeyContext(p *CompoundKeyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_compoundKey
}

func (*CompoundKeyContext) IsCompoundKeyContext() {}

func NewCompoundKeyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompoundKeyContext {
	var p = new(CompoundKeyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_compoundKey

	return p
}

func (s *CompoundKeyContext) GetParser() antlr.Parser { return s.parser }

func (s *CompoundKeyContext) PartitionKey() IPartitionKeyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionKeyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionKeyContext)
}

func (s *CompoundKeyContext) SyntaxComma() ISyntaxCommaContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxCommaContext)
}

func (s *CompoundKeyContext) ClusteringKeyList() IClusteringKeyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClusteringKeyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClusteringKeyListContext)
}

func (s *CompoundKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompoundKeyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompoundKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterCompoundKey(s)
	}
}

func (s *CompoundKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitCompoundKey(s)
	}
}

func (p *CQLParser) CompoundKey() (localctx ICompoundKeyContext) {
	localctx = NewCompoundKeyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, CQLParserRULE_compoundKey)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1394)
		p.PartitionKey()
	}

	{
		p.SetState(1395)
		p.SyntaxComma()
	}
	{
		p.SetState(1396)
		p.ClusteringKeyList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICompositeKeyContext is an interface to support dynamic dispatch.
type ICompositeKeyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SyntaxBracketLr() ISyntaxBracketLrContext
	PartitionKeyList() IPartitionKeyListContext
	SyntaxBracketRr() ISyntaxBracketRrContext
	SyntaxComma() ISyntaxCommaContext
	ClusteringKeyList() IClusteringKeyListContext

	// IsCompositeKeyContext differentiates from other interfaces.
	IsCompositeKeyContext()
}

type CompositeKeyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompositeKeyContext() *CompositeKeyContext {
	var p = new(CompositeKeyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_compositeKey
	return p
}

func InitEmptyCompositeKeyContext(p *CompositeKeyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_compositeKey
}

func (*CompositeKeyContext) IsCompositeKeyContext() {}

func NewCompositeKeyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompositeKeyContext {
	var p = new(CompositeKeyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_compositeKey

	return p
}

func (s *CompositeKeyContext) GetParser() antlr.Parser { return s.parser }

func (s *CompositeKeyContext) SyntaxBracketLr() ISyntaxBracketLrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketLrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketLrContext)
}

func (s *CompositeKeyContext) PartitionKeyList() IPartitionKeyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionKeyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionKeyListContext)
}

func (s *CompositeKeyContext) SyntaxBracketRr() ISyntaxBracketRrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketRrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketRrContext)
}

func (s *CompositeKeyContext) SyntaxComma() ISyntaxCommaContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxCommaContext)
}

func (s *CompositeKeyContext) ClusteringKeyList() IClusteringKeyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClusteringKeyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClusteringKeyListContext)
}

func (s *CompositeKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompositeKeyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompositeKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterCompositeKey(s)
	}
}

func (s *CompositeKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitCompositeKey(s)
	}
}

func (p *CQLParser) CompositeKey() (localctx ICompositeKeyContext) {
	localctx = NewCompositeKeyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, CQLParserRULE_compositeKey)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1398)
		p.SyntaxBracketLr()
	}
	{
		p.SetState(1399)
		p.PartitionKeyList()
	}
	{
		p.SetState(1400)
		p.SyntaxBracketRr()
	}

	{
		p.SetState(1401)
		p.SyntaxComma()
	}
	{
		p.SetState(1402)
		p.ClusteringKeyList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionKeyListContext is an interface to support dynamic dispatch.
type IPartitionKeyListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPartitionKey() []IPartitionKeyContext
	PartitionKey(i int) IPartitionKeyContext
	AllSyntaxComma() []ISyntaxCommaContext
	SyntaxComma(i int) ISyntaxCommaContext

	// IsPartitionKeyListContext differentiates from other interfaces.
	IsPartitionKeyListContext()
}

type PartitionKeyListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionKeyListContext() *PartitionKeyListContext {
	var p = new(PartitionKeyListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_partitionKeyList
	return p
}

func InitEmptyPartitionKeyListContext(p *PartitionKeyListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_partitionKeyList
}

func (*PartitionKeyListContext) IsPartitionKeyListContext() {}

func NewPartitionKeyListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionKeyListContext {
	var p = new(PartitionKeyListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_partitionKeyList

	return p
}

func (s *PartitionKeyListContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionKeyListContext) AllPartitionKey() []IPartitionKeyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionKeyContext); ok {
			len++
		}
	}

	tst := make([]IPartitionKeyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionKeyContext); ok {
			tst[i] = t.(IPartitionKeyContext)
			i++
		}
	}

	return tst
}

func (s *PartitionKeyListContext) PartitionKey(i int) IPartitionKeyContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionKeyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionKeyContext)
}

func (s *PartitionKeyListContext) AllSyntaxComma() []ISyntaxCommaContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			len++
		}
	}

	tst := make([]ISyntaxCommaContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISyntaxCommaContext); ok {
			tst[i] = t.(ISyntaxCommaContext)
			i++
		}
	}

	return tst
}

func (s *PartitionKeyListContext) SyntaxComma(i int) ISyntaxCommaContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxCommaContext)
}

func (s *PartitionKeyListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionKeyListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionKeyListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterPartitionKeyList(s)
	}
}

func (s *PartitionKeyListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitPartitionKeyList(s)
	}
}

func (p *CQLParser) PartitionKeyList() (localctx IPartitionKeyListContext) {
	localctx = NewPartitionKeyListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, CQLParserRULE_partitionKeyList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1404)
		p.PartitionKey()
	}

	p.SetState(1410)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CQLParserCOMMA {
		{
			p.SetState(1405)
			p.SyntaxComma()
		}
		{
			p.SetState(1406)
			p.PartitionKey()
		}

		p.SetState(1412)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClusteringKeyListContext is an interface to support dynamic dispatch.
type IClusteringKeyListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllClusteringKey() []IClusteringKeyContext
	ClusteringKey(i int) IClusteringKeyContext
	AllSyntaxComma() []ISyntaxCommaContext
	SyntaxComma(i int) ISyntaxCommaContext

	// IsClusteringKeyListContext differentiates from other interfaces.
	IsClusteringKeyListContext()
}

type ClusteringKeyListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClusteringKeyListContext() *ClusteringKeyListContext {
	var p = new(ClusteringKeyListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_clusteringKeyList
	return p
}

func InitEmptyClusteringKeyListContext(p *ClusteringKeyListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_clusteringKeyList
}

func (*ClusteringKeyListContext) IsClusteringKeyListContext() {}

func NewClusteringKeyListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClusteringKeyListContext {
	var p = new(ClusteringKeyListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_clusteringKeyList

	return p
}

func (s *ClusteringKeyListContext) GetParser() antlr.Parser { return s.parser }

func (s *ClusteringKeyListContext) AllClusteringKey() []IClusteringKeyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClusteringKeyContext); ok {
			len++
		}
	}

	tst := make([]IClusteringKeyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClusteringKeyContext); ok {
			tst[i] = t.(IClusteringKeyContext)
			i++
		}
	}

	return tst
}

func (s *ClusteringKeyListContext) ClusteringKey(i int) IClusteringKeyContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClusteringKeyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClusteringKeyContext)
}

func (s *ClusteringKeyListContext) AllSyntaxComma() []ISyntaxCommaContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			len++
		}
	}

	tst := make([]ISyntaxCommaContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISyntaxCommaContext); ok {
			tst[i] = t.(ISyntaxCommaContext)
			i++
		}
	}

	return tst
}

func (s *ClusteringKeyListContext) SyntaxComma(i int) ISyntaxCommaContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxCommaContext)
}

func (s *ClusteringKeyListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClusteringKeyListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClusteringKeyListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterClusteringKeyList(s)
	}
}

func (s *ClusteringKeyListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitClusteringKeyList(s)
	}
}

func (p *CQLParser) ClusteringKeyList() (localctx IClusteringKeyListContext) {
	localctx = NewClusteringKeyListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, CQLParserRULE_clusteringKeyList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1413)
		p.ClusteringKey()
	}

	p.SetState(1419)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CQLParserCOMMA {
		{
			p.SetState(1414)
			p.SyntaxComma()
		}
		{
			p.SetState(1415)
			p.ClusteringKey()
		}

		p.SetState(1421)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionKeyContext is an interface to support dynamic dispatch.
type IPartitionKeyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Column() IColumnContext

	// IsPartitionKeyContext differentiates from other interfaces.
	IsPartitionKeyContext()
}

type PartitionKeyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionKeyContext() *PartitionKeyContext {
	var p = new(PartitionKeyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_partitionKey
	return p
}

func InitEmptyPartitionKeyContext(p *PartitionKeyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_partitionKey
}

func (*PartitionKeyContext) IsPartitionKeyContext() {}

func NewPartitionKeyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionKeyContext {
	var p = new(PartitionKeyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_partitionKey

	return p
}

func (s *PartitionKeyContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionKeyContext) Column() IColumnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnContext)
}

func (s *PartitionKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionKeyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterPartitionKey(s)
	}
}

func (s *PartitionKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitPartitionKey(s)
	}
}

func (p *CQLParser) PartitionKey() (localctx IPartitionKeyContext) {
	localctx = NewPartitionKeyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, CQLParserRULE_partitionKey)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1422)
		p.Column()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClusteringKeyContext is an interface to support dynamic dispatch.
type IClusteringKeyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Column() IColumnContext

	// IsClusteringKeyContext differentiates from other interfaces.
	IsClusteringKeyContext()
}

type ClusteringKeyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClusteringKeyContext() *ClusteringKeyContext {
	var p = new(ClusteringKeyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_clusteringKey
	return p
}

func InitEmptyClusteringKeyContext(p *ClusteringKeyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_clusteringKey
}

func (*ClusteringKeyContext) IsClusteringKeyContext() {}

func NewClusteringKeyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClusteringKeyContext {
	var p = new(ClusteringKeyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_clusteringKey

	return p
}

func (s *ClusteringKeyContext) GetParser() antlr.Parser { return s.parser }

func (s *ClusteringKeyContext) Column() IColumnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnContext)
}

func (s *ClusteringKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClusteringKeyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClusteringKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterClusteringKey(s)
	}
}

func (s *ClusteringKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitClusteringKey(s)
	}
}

func (p *CQLParser) ClusteringKey() (localctx IClusteringKeyContext) {
	localctx = NewClusteringKeyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, CQLParserRULE_clusteringKey)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1424)
		p.Column()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IApplyBatchContext is an interface to support dynamic dispatch.
type IApplyBatchContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwApply() IKwApplyContext
	KwBatch() IKwBatchContext

	// IsApplyBatchContext differentiates from other interfaces.
	IsApplyBatchContext()
}

type ApplyBatchContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyApplyBatchContext() *ApplyBatchContext {
	var p = new(ApplyBatchContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_applyBatch
	return p
}

func InitEmptyApplyBatchContext(p *ApplyBatchContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_applyBatch
}

func (*ApplyBatchContext) IsApplyBatchContext() {}

func NewApplyBatchContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ApplyBatchContext {
	var p = new(ApplyBatchContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_applyBatch

	return p
}

func (s *ApplyBatchContext) GetParser() antlr.Parser { return s.parser }

func (s *ApplyBatchContext) KwApply() IKwApplyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwApplyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwApplyContext)
}

func (s *ApplyBatchContext) KwBatch() IKwBatchContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwBatchContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwBatchContext)
}

func (s *ApplyBatchContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ApplyBatchContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ApplyBatchContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterApplyBatch(s)
	}
}

func (s *ApplyBatchContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitApplyBatch(s)
	}
}

func (p *CQLParser) ApplyBatch() (localctx IApplyBatchContext) {
	localctx = NewApplyBatchContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, CQLParserRULE_applyBatch)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1426)
		p.KwApply()
	}
	{
		p.SetState(1427)
		p.KwBatch()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBeginBatchContext is an interface to support dynamic dispatch.
type IBeginBatchContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwBegin() IKwBeginContext
	KwBatch() IKwBatchContext
	BatchType() IBatchTypeContext
	UsingTimestampSpec() IUsingTimestampSpecContext

	// IsBeginBatchContext differentiates from other interfaces.
	IsBeginBatchContext()
}

type BeginBatchContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBeginBatchContext() *BeginBatchContext {
	var p = new(BeginBatchContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_beginBatch
	return p
}

func InitEmptyBeginBatchContext(p *BeginBatchContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_beginBatch
}

func (*BeginBatchContext) IsBeginBatchContext() {}

func NewBeginBatchContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BeginBatchContext {
	var p = new(BeginBatchContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_beginBatch

	return p
}

func (s *BeginBatchContext) GetParser() antlr.Parser { return s.parser }

func (s *BeginBatchContext) KwBegin() IKwBeginContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwBeginContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwBeginContext)
}

func (s *BeginBatchContext) KwBatch() IKwBatchContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwBatchContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwBatchContext)
}

func (s *BeginBatchContext) BatchType() IBatchTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBatchTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBatchTypeContext)
}

func (s *BeginBatchContext) UsingTimestampSpec() IUsingTimestampSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsingTimestampSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsingTimestampSpecContext)
}

func (s *BeginBatchContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BeginBatchContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BeginBatchContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterBeginBatch(s)
	}
}

func (s *BeginBatchContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitBeginBatch(s)
	}
}

func (p *CQLParser) BeginBatch() (localctx IBeginBatchContext) {
	localctx = NewBeginBatchContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, CQLParserRULE_beginBatch)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1429)
		p.KwBegin()
	}
	p.SetState(1431)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CQLParserK_LOGGED || _la == CQLParserK_UNLOGGED {
		{
			p.SetState(1430)
			p.BatchType()
		}

	}
	{
		p.SetState(1433)
		p.KwBatch()
	}
	p.SetState(1435)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CQLParserK_USING {
		{
			p.SetState(1434)
			p.UsingTimestampSpec()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBatchTypeContext is an interface to support dynamic dispatch.
type IBatchTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwLogged() IKwLoggedContext
	KwUnlogged() IKwUnloggedContext

	// IsBatchTypeContext differentiates from other interfaces.
	IsBatchTypeContext()
}

type BatchTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBatchTypeContext() *BatchTypeContext {
	var p = new(BatchTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_batchType
	return p
}

func InitEmptyBatchTypeContext(p *BatchTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_batchType
}

func (*BatchTypeContext) IsBatchTypeContext() {}

func NewBatchTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BatchTypeContext {
	var p = new(BatchTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_batchType

	return p
}

func (s *BatchTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *BatchTypeContext) KwLogged() IKwLoggedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwLoggedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwLoggedContext)
}

func (s *BatchTypeContext) KwUnlogged() IKwUnloggedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwUnloggedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwUnloggedContext)
}

func (s *BatchTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BatchTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BatchTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterBatchType(s)
	}
}

func (s *BatchTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitBatchType(s)
	}
}

func (p *CQLParser) BatchType() (localctx IBatchTypeContext) {
	localctx = NewBatchTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, CQLParserRULE_batchType)
	p.SetState(1439)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CQLParserK_LOGGED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1437)
			p.KwLogged()
		}

	case CQLParserK_UNLOGGED:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1438)
			p.KwUnlogged()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterKeyspaceContext is an interface to support dynamic dispatch.
type IAlterKeyspaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwAlter() IKwAlterContext
	KwKeyspace() IKwKeyspaceContext
	Keyspace() IKeyspaceContext
	KwWith() IKwWithContext
	KwReplication() IKwReplicationContext
	OPERATOR_EQ() antlr.TerminalNode
	SyntaxBracketLc() ISyntaxBracketLcContext
	ReplicationList() IReplicationListContext
	SyntaxBracketRc() ISyntaxBracketRcContext
	KwAnd() IKwAndContext
	DurableWrites() IDurableWritesContext

	// IsAlterKeyspaceContext differentiates from other interfaces.
	IsAlterKeyspaceContext()
}

type AlterKeyspaceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterKeyspaceContext() *AlterKeyspaceContext {
	var p = new(AlterKeyspaceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_alterKeyspace
	return p
}

func InitEmptyAlterKeyspaceContext(p *AlterKeyspaceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_alterKeyspace
}

func (*AlterKeyspaceContext) IsAlterKeyspaceContext() {}

func NewAlterKeyspaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterKeyspaceContext {
	var p = new(AlterKeyspaceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_alterKeyspace

	return p
}

func (s *AlterKeyspaceContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterKeyspaceContext) KwAlter() IKwAlterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAlterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAlterContext)
}

func (s *AlterKeyspaceContext) KwKeyspace() IKwKeyspaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwKeyspaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwKeyspaceContext)
}

func (s *AlterKeyspaceContext) Keyspace() IKeyspaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyspaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyspaceContext)
}

func (s *AlterKeyspaceContext) KwWith() IKwWithContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwWithContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwWithContext)
}

func (s *AlterKeyspaceContext) KwReplication() IKwReplicationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwReplicationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwReplicationContext)
}

func (s *AlterKeyspaceContext) OPERATOR_EQ() antlr.TerminalNode {
	return s.GetToken(CQLParserOPERATOR_EQ, 0)
}

func (s *AlterKeyspaceContext) SyntaxBracketLc() ISyntaxBracketLcContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketLcContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketLcContext)
}

func (s *AlterKeyspaceContext) ReplicationList() IReplicationListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplicationListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplicationListContext)
}

func (s *AlterKeyspaceContext) SyntaxBracketRc() ISyntaxBracketRcContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketRcContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketRcContext)
}

func (s *AlterKeyspaceContext) KwAnd() IKwAndContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAndContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAndContext)
}

func (s *AlterKeyspaceContext) DurableWrites() IDurableWritesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDurableWritesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDurableWritesContext)
}

func (s *AlterKeyspaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterKeyspaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterKeyspaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterAlterKeyspace(s)
	}
}

func (s *AlterKeyspaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitAlterKeyspace(s)
	}
}

func (p *CQLParser) AlterKeyspace() (localctx IAlterKeyspaceContext) {
	localctx = NewAlterKeyspaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, CQLParserRULE_alterKeyspace)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1441)
		p.KwAlter()
	}
	{
		p.SetState(1442)
		p.KwKeyspace()
	}
	{
		p.SetState(1443)
		p.Keyspace()
	}
	{
		p.SetState(1444)
		p.KwWith()
	}
	{
		p.SetState(1445)
		p.KwReplication()
	}
	{
		p.SetState(1446)
		p.Match(CQLParserOPERATOR_EQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1447)
		p.SyntaxBracketLc()
	}
	{
		p.SetState(1448)
		p.ReplicationList()
	}
	{
		p.SetState(1449)
		p.SyntaxBracketRc()
	}
	p.SetState(1453)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CQLParserK_AND {
		{
			p.SetState(1450)
			p.KwAnd()
		}
		{
			p.SetState(1451)
			p.DurableWrites()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReplicationListContext is an interface to support dynamic dispatch.
type IReplicationListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllReplicationListItem() []IReplicationListItemContext
	ReplicationListItem(i int) IReplicationListItemContext
	AllSyntaxComma() []ISyntaxCommaContext
	SyntaxComma(i int) ISyntaxCommaContext

	// IsReplicationListContext differentiates from other interfaces.
	IsReplicationListContext()
}

type ReplicationListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReplicationListContext() *ReplicationListContext {
	var p = new(ReplicationListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_replicationList
	return p
}

func InitEmptyReplicationListContext(p *ReplicationListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_replicationList
}

func (*ReplicationListContext) IsReplicationListContext() {}

func NewReplicationListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReplicationListContext {
	var p = new(ReplicationListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_replicationList

	return p
}

func (s *ReplicationListContext) GetParser() antlr.Parser { return s.parser }

func (s *ReplicationListContext) AllReplicationListItem() []IReplicationListItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IReplicationListItemContext); ok {
			len++
		}
	}

	tst := make([]IReplicationListItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IReplicationListItemContext); ok {
			tst[i] = t.(IReplicationListItemContext)
			i++
		}
	}

	return tst
}

func (s *ReplicationListContext) ReplicationListItem(i int) IReplicationListItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplicationListItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplicationListItemContext)
}

func (s *ReplicationListContext) AllSyntaxComma() []ISyntaxCommaContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			len++
		}
	}

	tst := make([]ISyntaxCommaContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISyntaxCommaContext); ok {
			tst[i] = t.(ISyntaxCommaContext)
			i++
		}
	}

	return tst
}

func (s *ReplicationListContext) SyntaxComma(i int) ISyntaxCommaContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxCommaContext)
}

func (s *ReplicationListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplicationListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReplicationListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterReplicationList(s)
	}
}

func (s *ReplicationListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitReplicationList(s)
	}
}

func (p *CQLParser) ReplicationList() (localctx IReplicationListContext) {
	localctx = NewReplicationListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, CQLParserRULE_replicationList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1455)
		p.ReplicationListItem()
	}

	p.SetState(1461)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CQLParserCOMMA {
		{
			p.SetState(1456)
			p.SyntaxComma()
		}
		{
			p.SetState(1457)
			p.ReplicationListItem()
		}

		p.SetState(1463)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReplicationListItemContext is an interface to support dynamic dispatch.
type IReplicationListItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSTRING_LITERAL() []antlr.TerminalNode
	STRING_LITERAL(i int) antlr.TerminalNode
	COLON() antlr.TerminalNode
	DECIMAL_LITERAL() antlr.TerminalNode

	// IsReplicationListItemContext differentiates from other interfaces.
	IsReplicationListItemContext()
}

type ReplicationListItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReplicationListItemContext() *ReplicationListItemContext {
	var p = new(ReplicationListItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_replicationListItem
	return p
}

func InitEmptyReplicationListItemContext(p *ReplicationListItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_replicationListItem
}

func (*ReplicationListItemContext) IsReplicationListItemContext() {}

func NewReplicationListItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReplicationListItemContext {
	var p = new(ReplicationListItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_replicationListItem

	return p
}

func (s *ReplicationListItemContext) GetParser() antlr.Parser { return s.parser }

func (s *ReplicationListItemContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(CQLParserSTRING_LITERAL)
}

func (s *ReplicationListItemContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(CQLParserSTRING_LITERAL, i)
}

func (s *ReplicationListItemContext) COLON() antlr.TerminalNode {
	return s.GetToken(CQLParserCOLON, 0)
}

func (s *ReplicationListItemContext) DECIMAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(CQLParserDECIMAL_LITERAL, 0)
}

func (s *ReplicationListItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplicationListItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReplicationListItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterReplicationListItem(s)
	}
}

func (s *ReplicationListItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitReplicationListItem(s)
	}
}

func (p *CQLParser) ReplicationListItem() (localctx IReplicationListItemContext) {
	localctx = NewReplicationListItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, CQLParserRULE_replicationListItem)
	p.SetState(1470)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 108, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1464)
			p.Match(CQLParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1465)
			p.Match(CQLParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1466)
			p.Match(CQLParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1467)
			p.Match(CQLParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1468)
			p.Match(CQLParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1469)
			p.Match(CQLParserDECIMAL_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDurableWritesContext is an interface to support dynamic dispatch.
type IDurableWritesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwDurableWrites() IKwDurableWritesContext
	OPERATOR_EQ() antlr.TerminalNode
	BooleanLiteral() IBooleanLiteralContext

	// IsDurableWritesContext differentiates from other interfaces.
	IsDurableWritesContext()
}

type DurableWritesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDurableWritesContext() *DurableWritesContext {
	var p = new(DurableWritesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_durableWrites
	return p
}

func InitEmptyDurableWritesContext(p *DurableWritesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_durableWrites
}

func (*DurableWritesContext) IsDurableWritesContext() {}

func NewDurableWritesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DurableWritesContext {
	var p = new(DurableWritesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_durableWrites

	return p
}

func (s *DurableWritesContext) GetParser() antlr.Parser { return s.parser }

func (s *DurableWritesContext) KwDurableWrites() IKwDurableWritesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwDurableWritesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwDurableWritesContext)
}

func (s *DurableWritesContext) OPERATOR_EQ() antlr.TerminalNode {
	return s.GetToken(CQLParserOPERATOR_EQ, 0)
}

func (s *DurableWritesContext) BooleanLiteral() IBooleanLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanLiteralContext)
}

func (s *DurableWritesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DurableWritesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DurableWritesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterDurableWrites(s)
	}
}

func (s *DurableWritesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitDurableWrites(s)
	}
}

func (p *CQLParser) DurableWrites() (localctx IDurableWritesContext) {
	localctx = NewDurableWritesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, CQLParserRULE_durableWrites)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1472)
		p.KwDurableWrites()
	}
	{
		p.SetState(1473)
		p.Match(CQLParserOPERATOR_EQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1474)
		p.BooleanLiteral()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUse_Context is an interface to support dynamic dispatch.
type IUse_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwUse() IKwUseContext
	Keyspace() IKeyspaceContext

	// IsUse_Context differentiates from other interfaces.
	IsUse_Context()
}

type Use_Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUse_Context() *Use_Context {
	var p = new(Use_Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_use_
	return p
}

func InitEmptyUse_Context(p *Use_Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_use_
}

func (*Use_Context) IsUse_Context() {}

func NewUse_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Use_Context {
	var p = new(Use_Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_use_

	return p
}

func (s *Use_Context) GetParser() antlr.Parser { return s.parser }

func (s *Use_Context) KwUse() IKwUseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwUseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwUseContext)
}

func (s *Use_Context) Keyspace() IKeyspaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyspaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyspaceContext)
}

func (s *Use_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Use_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Use_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterUse_(s)
	}
}

func (s *Use_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitUse_(s)
	}
}

func (p *CQLParser) Use_() (localctx IUse_Context) {
	localctx = NewUse_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, CQLParserRULE_use_)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1476)
		p.KwUse()
	}
	{
		p.SetState(1477)
		p.Keyspace()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITruncateContext is an interface to support dynamic dispatch.
type ITruncateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwTruncate() IKwTruncateContext
	Table() ITableContext
	KwTable() IKwTableContext
	Keyspace() IKeyspaceContext
	DOT() antlr.TerminalNode

	// IsTruncateContext differentiates from other interfaces.
	IsTruncateContext()
}

type TruncateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTruncateContext() *TruncateContext {
	var p = new(TruncateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_truncate
	return p
}

func InitEmptyTruncateContext(p *TruncateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_truncate
}

func (*TruncateContext) IsTruncateContext() {}

func NewTruncateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TruncateContext {
	var p = new(TruncateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_truncate

	return p
}

func (s *TruncateContext) GetParser() antlr.Parser { return s.parser }

func (s *TruncateContext) KwTruncate() IKwTruncateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwTruncateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwTruncateContext)
}

func (s *TruncateContext) Table() ITableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableContext)
}

func (s *TruncateContext) KwTable() IKwTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwTableContext)
}

func (s *TruncateContext) Keyspace() IKeyspaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyspaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyspaceContext)
}

func (s *TruncateContext) DOT() antlr.TerminalNode {
	return s.GetToken(CQLParserDOT, 0)
}

func (s *TruncateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TruncateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TruncateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterTruncate(s)
	}
}

func (s *TruncateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitTruncate(s)
	}
}

func (p *CQLParser) Truncate() (localctx ITruncateContext) {
	localctx = NewTruncateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, CQLParserRULE_truncate)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1479)
		p.KwTruncate()
	}
	p.SetState(1481)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CQLParserK_TABLE {
		{
			p.SetState(1480)
			p.KwTable()
		}

	}
	p.SetState(1486)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 110, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1483)
			p.Keyspace()
		}
		{
			p.SetState(1484)
			p.Match(CQLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1488)
		p.Table()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateIndexContext is an interface to support dynamic dispatch.
type ICreateIndexContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwCreate() IKwCreateContext
	KwIndex() IKwIndexContext
	KwOn() IKwOnContext
	Table() ITableContext
	SyntaxBracketLr() ISyntaxBracketLrContext
	IndexColumnSpec() IIndexColumnSpecContext
	SyntaxBracketRr() ISyntaxBracketRrContext
	IfNotExist() IIfNotExistContext
	IndexName() IIndexNameContext
	Keyspace() IKeyspaceContext
	DOT() antlr.TerminalNode

	// IsCreateIndexContext differentiates from other interfaces.
	IsCreateIndexContext()
}

type CreateIndexContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateIndexContext() *CreateIndexContext {
	var p = new(CreateIndexContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_createIndex
	return p
}

func InitEmptyCreateIndexContext(p *CreateIndexContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_createIndex
}

func (*CreateIndexContext) IsCreateIndexContext() {}

func NewCreateIndexContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateIndexContext {
	var p = new(CreateIndexContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_createIndex

	return p
}

func (s *CreateIndexContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateIndexContext) KwCreate() IKwCreateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwCreateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwCreateContext)
}

func (s *CreateIndexContext) KwIndex() IKwIndexContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwIndexContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwIndexContext)
}

func (s *CreateIndexContext) KwOn() IKwOnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwOnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwOnContext)
}

func (s *CreateIndexContext) Table() ITableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableContext)
}

func (s *CreateIndexContext) SyntaxBracketLr() ISyntaxBracketLrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketLrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketLrContext)
}

func (s *CreateIndexContext) IndexColumnSpec() IIndexColumnSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexColumnSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexColumnSpecContext)
}

func (s *CreateIndexContext) SyntaxBracketRr() ISyntaxBracketRrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketRrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketRrContext)
}

func (s *CreateIndexContext) IfNotExist() IIfNotExistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistContext)
}

func (s *CreateIndexContext) IndexName() IIndexNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexNameContext)
}

func (s *CreateIndexContext) Keyspace() IKeyspaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyspaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyspaceContext)
}

func (s *CreateIndexContext) DOT() antlr.TerminalNode {
	return s.GetToken(CQLParserDOT, 0)
}

func (s *CreateIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateIndexContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterCreateIndex(s)
	}
}

func (s *CreateIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitCreateIndex(s)
	}
}

func (p *CQLParser) CreateIndex() (localctx ICreateIndexContext) {
	localctx = NewCreateIndexContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, CQLParserRULE_createIndex)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1490)
		p.KwCreate()
	}
	{
		p.SetState(1491)
		p.KwIndex()
	}
	p.SetState(1493)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CQLParserK_IF {
		{
			p.SetState(1492)
			p.IfNotExist()
		}

	}
	p.SetState(1496)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CQLParserSTRING_LITERAL || _la == CQLParserOBJECT_NAME {
		{
			p.SetState(1495)
			p.IndexName()
		}

	}
	{
		p.SetState(1498)
		p.KwOn()
	}
	p.SetState(1502)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 113, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1499)
			p.Keyspace()
		}
		{
			p.SetState(1500)
			p.Match(CQLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1504)
		p.Table()
	}
	{
		p.SetState(1505)
		p.SyntaxBracketLr()
	}
	{
		p.SetState(1506)
		p.IndexColumnSpec()
	}
	{
		p.SetState(1507)
		p.SyntaxBracketRr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexNameContext is an interface to support dynamic dispatch.
type IIndexNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OBJECT_NAME() antlr.TerminalNode
	StringLiteral() IStringLiteralContext

	// IsIndexNameContext differentiates from other interfaces.
	IsIndexNameContext()
}

type IndexNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexNameContext() *IndexNameContext {
	var p = new(IndexNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_indexName
	return p
}

func InitEmptyIndexNameContext(p *IndexNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_indexName
}

func (*IndexNameContext) IsIndexNameContext() {}

func NewIndexNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexNameContext {
	var p = new(IndexNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_indexName

	return p
}

func (s *IndexNameContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexNameContext) OBJECT_NAME() antlr.TerminalNode {
	return s.GetToken(CQLParserOBJECT_NAME, 0)
}

func (s *IndexNameContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *IndexNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterIndexName(s)
	}
}

func (s *IndexNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitIndexName(s)
	}
}

func (p *CQLParser) IndexName() (localctx IIndexNameContext) {
	localctx = NewIndexNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, CQLParserRULE_indexName)
	p.SetState(1511)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CQLParserOBJECT_NAME:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1509)
			p.Match(CQLParserOBJECT_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case CQLParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1510)
			p.StringLiteral()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexColumnSpecContext is an interface to support dynamic dispatch.
type IIndexColumnSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Column() IColumnContext
	IndexKeysSpec() IIndexKeysSpecContext
	IndexEntriesSSpec() IIndexEntriesSSpecContext
	IndexFullSpec() IIndexFullSpecContext

	// IsIndexColumnSpecContext differentiates from other interfaces.
	IsIndexColumnSpecContext()
}

type IndexColumnSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexColumnSpecContext() *IndexColumnSpecContext {
	var p = new(IndexColumnSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_indexColumnSpec
	return p
}

func InitEmptyIndexColumnSpecContext(p *IndexColumnSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_indexColumnSpec
}

func (*IndexColumnSpecContext) IsIndexColumnSpecContext() {}

func NewIndexColumnSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexColumnSpecContext {
	var p = new(IndexColumnSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_indexColumnSpec

	return p
}

func (s *IndexColumnSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexColumnSpecContext) Column() IColumnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnContext)
}

func (s *IndexColumnSpecContext) IndexKeysSpec() IIndexKeysSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexKeysSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexKeysSpecContext)
}

func (s *IndexColumnSpecContext) IndexEntriesSSpec() IIndexEntriesSSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexEntriesSSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexEntriesSSpecContext)
}

func (s *IndexColumnSpecContext) IndexFullSpec() IIndexFullSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexFullSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexFullSpecContext)
}

func (s *IndexColumnSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexColumnSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexColumnSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterIndexColumnSpec(s)
	}
}

func (s *IndexColumnSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitIndexColumnSpec(s)
	}
}

func (p *CQLParser) IndexColumnSpec() (localctx IIndexColumnSpecContext) {
	localctx = NewIndexColumnSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, CQLParserRULE_indexColumnSpec)
	p.SetState(1517)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CQLParserDQUOTE, CQLParserOBJECT_NAME:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1513)
			p.Column()
		}

	case CQLParserK_KEYS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1514)
			p.IndexKeysSpec()
		}

	case CQLParserK_ENTRIES:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1515)
			p.IndexEntriesSSpec()
		}

	case CQLParserK_FULL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1516)
			p.IndexFullSpec()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexKeysSpecContext is an interface to support dynamic dispatch.
type IIndexKeysSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwKeys() IKwKeysContext
	SyntaxBracketLr() ISyntaxBracketLrContext
	OBJECT_NAME() antlr.TerminalNode
	SyntaxBracketRr() ISyntaxBracketRrContext

	// IsIndexKeysSpecContext differentiates from other interfaces.
	IsIndexKeysSpecContext()
}

type IndexKeysSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexKeysSpecContext() *IndexKeysSpecContext {
	var p = new(IndexKeysSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_indexKeysSpec
	return p
}

func InitEmptyIndexKeysSpecContext(p *IndexKeysSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_indexKeysSpec
}

func (*IndexKeysSpecContext) IsIndexKeysSpecContext() {}

func NewIndexKeysSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexKeysSpecContext {
	var p = new(IndexKeysSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_indexKeysSpec

	return p
}

func (s *IndexKeysSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexKeysSpecContext) KwKeys() IKwKeysContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwKeysContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwKeysContext)
}

func (s *IndexKeysSpecContext) SyntaxBracketLr() ISyntaxBracketLrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketLrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketLrContext)
}

func (s *IndexKeysSpecContext) OBJECT_NAME() antlr.TerminalNode {
	return s.GetToken(CQLParserOBJECT_NAME, 0)
}

func (s *IndexKeysSpecContext) SyntaxBracketRr() ISyntaxBracketRrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketRrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketRrContext)
}

func (s *IndexKeysSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexKeysSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexKeysSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterIndexKeysSpec(s)
	}
}

func (s *IndexKeysSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitIndexKeysSpec(s)
	}
}

func (p *CQLParser) IndexKeysSpec() (localctx IIndexKeysSpecContext) {
	localctx = NewIndexKeysSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, CQLParserRULE_indexKeysSpec)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1519)
		p.KwKeys()
	}
	{
		p.SetState(1520)
		p.SyntaxBracketLr()
	}
	{
		p.SetState(1521)
		p.Match(CQLParserOBJECT_NAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1522)
		p.SyntaxBracketRr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexEntriesSSpecContext is an interface to support dynamic dispatch.
type IIndexEntriesSSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwEntries() IKwEntriesContext
	SyntaxBracketLr() ISyntaxBracketLrContext
	OBJECT_NAME() antlr.TerminalNode
	SyntaxBracketRr() ISyntaxBracketRrContext

	// IsIndexEntriesSSpecContext differentiates from other interfaces.
	IsIndexEntriesSSpecContext()
}

type IndexEntriesSSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexEntriesSSpecContext() *IndexEntriesSSpecContext {
	var p = new(IndexEntriesSSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_indexEntriesSSpec
	return p
}

func InitEmptyIndexEntriesSSpecContext(p *IndexEntriesSSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_indexEntriesSSpec
}

func (*IndexEntriesSSpecContext) IsIndexEntriesSSpecContext() {}

func NewIndexEntriesSSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexEntriesSSpecContext {
	var p = new(IndexEntriesSSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_indexEntriesSSpec

	return p
}

func (s *IndexEntriesSSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexEntriesSSpecContext) KwEntries() IKwEntriesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwEntriesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwEntriesContext)
}

func (s *IndexEntriesSSpecContext) SyntaxBracketLr() ISyntaxBracketLrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketLrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketLrContext)
}

func (s *IndexEntriesSSpecContext) OBJECT_NAME() antlr.TerminalNode {
	return s.GetToken(CQLParserOBJECT_NAME, 0)
}

func (s *IndexEntriesSSpecContext) SyntaxBracketRr() ISyntaxBracketRrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketRrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketRrContext)
}

func (s *IndexEntriesSSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexEntriesSSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexEntriesSSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterIndexEntriesSSpec(s)
	}
}

func (s *IndexEntriesSSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitIndexEntriesSSpec(s)
	}
}

func (p *CQLParser) IndexEntriesSSpec() (localctx IIndexEntriesSSpecContext) {
	localctx = NewIndexEntriesSSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, CQLParserRULE_indexEntriesSSpec)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1524)
		p.KwEntries()
	}
	{
		p.SetState(1525)
		p.SyntaxBracketLr()
	}
	{
		p.SetState(1526)
		p.Match(CQLParserOBJECT_NAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1527)
		p.SyntaxBracketRr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexFullSpecContext is an interface to support dynamic dispatch.
type IIndexFullSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwFull() IKwFullContext
	SyntaxBracketLr() ISyntaxBracketLrContext
	OBJECT_NAME() antlr.TerminalNode
	SyntaxBracketRr() ISyntaxBracketRrContext

	// IsIndexFullSpecContext differentiates from other interfaces.
	IsIndexFullSpecContext()
}

type IndexFullSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexFullSpecContext() *IndexFullSpecContext {
	var p = new(IndexFullSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_indexFullSpec
	return p
}

func InitEmptyIndexFullSpecContext(p *IndexFullSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_indexFullSpec
}

func (*IndexFullSpecContext) IsIndexFullSpecContext() {}

func NewIndexFullSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexFullSpecContext {
	var p = new(IndexFullSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_indexFullSpec

	return p
}

func (s *IndexFullSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexFullSpecContext) KwFull() IKwFullContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwFullContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwFullContext)
}

func (s *IndexFullSpecContext) SyntaxBracketLr() ISyntaxBracketLrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketLrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketLrContext)
}

func (s *IndexFullSpecContext) OBJECT_NAME() antlr.TerminalNode {
	return s.GetToken(CQLParserOBJECT_NAME, 0)
}

func (s *IndexFullSpecContext) SyntaxBracketRr() ISyntaxBracketRrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketRrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketRrContext)
}

func (s *IndexFullSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexFullSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexFullSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterIndexFullSpec(s)
	}
}

func (s *IndexFullSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitIndexFullSpec(s)
	}
}

func (p *CQLParser) IndexFullSpec() (localctx IIndexFullSpecContext) {
	localctx = NewIndexFullSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, CQLParserRULE_indexFullSpec)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1529)
		p.KwFull()
	}
	{
		p.SetState(1530)
		p.SyntaxBracketLr()
	}
	{
		p.SetState(1531)
		p.Match(CQLParserOBJECT_NAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1532)
		p.SyntaxBracketRr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDelete_Context is an interface to support dynamic dispatch.
type IDelete_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwDelete() IKwDeleteContext
	FromSpec() IFromSpecContext
	WhereSpec() IWhereSpecContext
	BeginBatch() IBeginBatchContext
	DeleteColumnList() IDeleteColumnListContext
	UsingTimestampSpec() IUsingTimestampSpecContext
	IfExist() IIfExistContext
	IfSpec() IIfSpecContext

	// IsDelete_Context differentiates from other interfaces.
	IsDelete_Context()
}

type Delete_Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDelete_Context() *Delete_Context {
	var p = new(Delete_Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_delete_
	return p
}

func InitEmptyDelete_Context(p *Delete_Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_delete_
}

func (*Delete_Context) IsDelete_Context() {}

func NewDelete_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Delete_Context {
	var p = new(Delete_Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_delete_

	return p
}

func (s *Delete_Context) GetParser() antlr.Parser { return s.parser }

func (s *Delete_Context) KwDelete() IKwDeleteContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwDeleteContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwDeleteContext)
}

func (s *Delete_Context) FromSpec() IFromSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromSpecContext)
}

func (s *Delete_Context) WhereSpec() IWhereSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereSpecContext)
}

func (s *Delete_Context) BeginBatch() IBeginBatchContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBeginBatchContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBeginBatchContext)
}

func (s *Delete_Context) DeleteColumnList() IDeleteColumnListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeleteColumnListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeleteColumnListContext)
}

func (s *Delete_Context) UsingTimestampSpec() IUsingTimestampSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsingTimestampSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsingTimestampSpecContext)
}

func (s *Delete_Context) IfExist() IIfExistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistContext)
}

func (s *Delete_Context) IfSpec() IIfSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfSpecContext)
}

func (s *Delete_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Delete_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Delete_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterDelete_(s)
	}
}

func (s *Delete_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitDelete_(s)
	}
}

func (p *CQLParser) Delete_() (localctx IDelete_Context) {
	localctx = NewDelete_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, CQLParserRULE_delete_)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1535)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CQLParserK_BEGIN {
		{
			p.SetState(1534)
			p.BeginBatch()
		}

	}
	{
		p.SetState(1537)
		p.KwDelete()
	}
	p.SetState(1539)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CQLParserOBJECT_NAME {
		{
			p.SetState(1538)
			p.DeleteColumnList()
		}

	}
	{
		p.SetState(1541)
		p.FromSpec()
	}
	p.SetState(1543)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CQLParserK_USING {
		{
			p.SetState(1542)
			p.UsingTimestampSpec()
		}

	}
	{
		p.SetState(1545)
		p.WhereSpec()
	}
	p.SetState(1548)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 119, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1546)
			p.IfExist()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 119, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(1547)
			p.IfSpec()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeleteColumnListContext is an interface to support dynamic dispatch.
type IDeleteColumnListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllDeleteColumnItem() []IDeleteColumnItemContext
	DeleteColumnItem(i int) IDeleteColumnItemContext
	AllSyntaxComma() []ISyntaxCommaContext
	SyntaxComma(i int) ISyntaxCommaContext

	// IsDeleteColumnListContext differentiates from other interfaces.
	IsDeleteColumnListContext()
}

type DeleteColumnListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeleteColumnListContext() *DeleteColumnListContext {
	var p = new(DeleteColumnListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_deleteColumnList
	return p
}

func InitEmptyDeleteColumnListContext(p *DeleteColumnListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_deleteColumnList
}

func (*DeleteColumnListContext) IsDeleteColumnListContext() {}

func NewDeleteColumnListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeleteColumnListContext {
	var p = new(DeleteColumnListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_deleteColumnList

	return p
}

func (s *DeleteColumnListContext) GetParser() antlr.Parser { return s.parser }

func (s *DeleteColumnListContext) AllDeleteColumnItem() []IDeleteColumnItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDeleteColumnItemContext); ok {
			len++
		}
	}

	tst := make([]IDeleteColumnItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDeleteColumnItemContext); ok {
			tst[i] = t.(IDeleteColumnItemContext)
			i++
		}
	}

	return tst
}

func (s *DeleteColumnListContext) DeleteColumnItem(i int) IDeleteColumnItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeleteColumnItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeleteColumnItemContext)
}

func (s *DeleteColumnListContext) AllSyntaxComma() []ISyntaxCommaContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			len++
		}
	}

	tst := make([]ISyntaxCommaContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISyntaxCommaContext); ok {
			tst[i] = t.(ISyntaxCommaContext)
			i++
		}
	}

	return tst
}

func (s *DeleteColumnListContext) SyntaxComma(i int) ISyntaxCommaContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxCommaContext)
}

func (s *DeleteColumnListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeleteColumnListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeleteColumnListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterDeleteColumnList(s)
	}
}

func (s *DeleteColumnListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitDeleteColumnList(s)
	}
}

func (p *CQLParser) DeleteColumnList() (localctx IDeleteColumnListContext) {
	localctx = NewDeleteColumnListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, CQLParserRULE_deleteColumnList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1550)
		p.DeleteColumnItem()
	}

	p.SetState(1556)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CQLParserCOMMA {
		{
			p.SetState(1551)
			p.SyntaxComma()
		}
		{
			p.SetState(1552)
			p.DeleteColumnItem()
		}

		p.SetState(1558)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeleteColumnItemContext is an interface to support dynamic dispatch.
type IDeleteColumnItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OBJECT_NAME() antlr.TerminalNode
	LS_BRACKET() antlr.TerminalNode
	RS_BRACKET() antlr.TerminalNode
	StringLiteral() IStringLiteralContext
	DecimalLiteral() IDecimalLiteralContext

	// IsDeleteColumnItemContext differentiates from other interfaces.
	IsDeleteColumnItemContext()
}

type DeleteColumnItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeleteColumnItemContext() *DeleteColumnItemContext {
	var p = new(DeleteColumnItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_deleteColumnItem
	return p
}

func InitEmptyDeleteColumnItemContext(p *DeleteColumnItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_deleteColumnItem
}

func (*DeleteColumnItemContext) IsDeleteColumnItemContext() {}

func NewDeleteColumnItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeleteColumnItemContext {
	var p = new(DeleteColumnItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_deleteColumnItem

	return p
}

func (s *DeleteColumnItemContext) GetParser() antlr.Parser { return s.parser }

func (s *DeleteColumnItemContext) OBJECT_NAME() antlr.TerminalNode {
	return s.GetToken(CQLParserOBJECT_NAME, 0)
}

func (s *DeleteColumnItemContext) LS_BRACKET() antlr.TerminalNode {
	return s.GetToken(CQLParserLS_BRACKET, 0)
}

func (s *DeleteColumnItemContext) RS_BRACKET() antlr.TerminalNode {
	return s.GetToken(CQLParserRS_BRACKET, 0)
}

func (s *DeleteColumnItemContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *DeleteColumnItemContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *DeleteColumnItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeleteColumnItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeleteColumnItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterDeleteColumnItem(s)
	}
}

func (s *DeleteColumnItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitDeleteColumnItem(s)
	}
}

func (p *CQLParser) DeleteColumnItem() (localctx IDeleteColumnItemContext) {
	localctx = NewDeleteColumnItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, CQLParserRULE_deleteColumnItem)
	p.SetState(1568)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 122, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1559)
			p.Match(CQLParserOBJECT_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1560)
			p.Match(CQLParserOBJECT_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1561)
			p.Match(CQLParserLS_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1564)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case CQLParserSTRING_LITERAL:
			{
				p.SetState(1562)
				p.StringLiteral()
			}

		case CQLParserDECIMAL_LITERAL:
			{
				p.SetState(1563)
				p.DecimalLiteral()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(1566)
			p.Match(CQLParserRS_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUpdateContext is an interface to support dynamic dispatch.
type IUpdateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwUpdate() IKwUpdateContext
	Table() ITableContext
	KwSet() IKwSetContext
	Assignments() IAssignmentsContext
	WhereSpec() IWhereSpecContext
	BeginBatch() IBeginBatchContext
	Keyspace() IKeyspaceContext
	DOT() antlr.TerminalNode
	UsingTtlTimestamp() IUsingTtlTimestampContext
	IfExist() IIfExistContext
	IfSpec() IIfSpecContext

	// IsUpdateContext differentiates from other interfaces.
	IsUpdateContext()
}

type UpdateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUpdateContext() *UpdateContext {
	var p = new(UpdateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_update
	return p
}

func InitEmptyUpdateContext(p *UpdateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_update
}

func (*UpdateContext) IsUpdateContext() {}

func NewUpdateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UpdateContext {
	var p = new(UpdateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_update

	return p
}

func (s *UpdateContext) GetParser() antlr.Parser { return s.parser }

func (s *UpdateContext) KwUpdate() IKwUpdateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwUpdateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwUpdateContext)
}

func (s *UpdateContext) Table() ITableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableContext)
}

func (s *UpdateContext) KwSet() IKwSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwSetContext)
}

func (s *UpdateContext) Assignments() IAssignmentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentsContext)
}

func (s *UpdateContext) WhereSpec() IWhereSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereSpecContext)
}

func (s *UpdateContext) BeginBatch() IBeginBatchContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBeginBatchContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBeginBatchContext)
}

func (s *UpdateContext) Keyspace() IKeyspaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyspaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyspaceContext)
}

func (s *UpdateContext) DOT() antlr.TerminalNode {
	return s.GetToken(CQLParserDOT, 0)
}

func (s *UpdateContext) UsingTtlTimestamp() IUsingTtlTimestampContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsingTtlTimestampContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsingTtlTimestampContext)
}

func (s *UpdateContext) IfExist() IIfExistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistContext)
}

func (s *UpdateContext) IfSpec() IIfSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfSpecContext)
}

func (s *UpdateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UpdateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UpdateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterUpdate(s)
	}
}

func (s *UpdateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitUpdate(s)
	}
}

func (p *CQLParser) Update() (localctx IUpdateContext) {
	localctx = NewUpdateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, CQLParserRULE_update)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1571)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CQLParserK_BEGIN {
		{
			p.SetState(1570)
			p.BeginBatch()
		}

	}
	{
		p.SetState(1573)
		p.KwUpdate()
	}
	p.SetState(1577)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 124, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1574)
			p.Keyspace()
		}
		{
			p.SetState(1575)
			p.Match(CQLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1579)
		p.Table()
	}
	p.SetState(1581)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CQLParserK_USING {
		{
			p.SetState(1580)
			p.UsingTtlTimestamp()
		}

	}
	{
		p.SetState(1583)
		p.KwSet()
	}
	{
		p.SetState(1584)
		p.Assignments()
	}
	{
		p.SetState(1585)
		p.WhereSpec()
	}
	p.SetState(1588)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 126, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1586)
			p.IfExist()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 126, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(1587)
			p.IfSpec()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfSpecContext is an interface to support dynamic dispatch.
type IIfSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwIf() IKwIfContext
	IfConditionList() IIfConditionListContext

	// IsIfSpecContext differentiates from other interfaces.
	IsIfSpecContext()
}

type IfSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfSpecContext() *IfSpecContext {
	var p = new(IfSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_ifSpec
	return p
}

func InitEmptyIfSpecContext(p *IfSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_ifSpec
}

func (*IfSpecContext) IsIfSpecContext() {}

func NewIfSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfSpecContext {
	var p = new(IfSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_ifSpec

	return p
}

func (s *IfSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *IfSpecContext) KwIf() IKwIfContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwIfContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwIfContext)
}

func (s *IfSpecContext) IfConditionList() IIfConditionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfConditionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfConditionListContext)
}

func (s *IfSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterIfSpec(s)
	}
}

func (s *IfSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitIfSpec(s)
	}
}

func (p *CQLParser) IfSpec() (localctx IIfSpecContext) {
	localctx = NewIfSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, CQLParserRULE_ifSpec)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1590)
		p.KwIf()
	}
	{
		p.SetState(1591)
		p.IfConditionList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfConditionListContext is an interface to support dynamic dispatch.
type IIfConditionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIfCondition() []IIfConditionContext
	IfCondition(i int) IIfConditionContext
	AllKwAnd() []IKwAndContext
	KwAnd(i int) IKwAndContext

	// IsIfConditionListContext differentiates from other interfaces.
	IsIfConditionListContext()
}

type IfConditionListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfConditionListContext() *IfConditionListContext {
	var p = new(IfConditionListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_ifConditionList
	return p
}

func InitEmptyIfConditionListContext(p *IfConditionListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_ifConditionList
}

func (*IfConditionListContext) IsIfConditionListContext() {}

func NewIfConditionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfConditionListContext {
	var p = new(IfConditionListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_ifConditionList

	return p
}

func (s *IfConditionListContext) GetParser() antlr.Parser { return s.parser }

func (s *IfConditionListContext) AllIfCondition() []IIfConditionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIfConditionContext); ok {
			len++
		}
	}

	tst := make([]IIfConditionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIfConditionContext); ok {
			tst[i] = t.(IIfConditionContext)
			i++
		}
	}

	return tst
}

func (s *IfConditionListContext) IfCondition(i int) IIfConditionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfConditionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfConditionContext)
}

func (s *IfConditionListContext) AllKwAnd() []IKwAndContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IKwAndContext); ok {
			len++
		}
	}

	tst := make([]IKwAndContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IKwAndContext); ok {
			tst[i] = t.(IKwAndContext)
			i++
		}
	}

	return tst
}

func (s *IfConditionListContext) KwAnd(i int) IKwAndContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAndContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAndContext)
}

func (s *IfConditionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfConditionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfConditionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterIfConditionList(s)
	}
}

func (s *IfConditionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitIfConditionList(s)
	}
}

func (p *CQLParser) IfConditionList() (localctx IIfConditionListContext) {
	localctx = NewIfConditionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, CQLParserRULE_ifConditionList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1593)
		p.IfCondition()
	}

	p.SetState(1599)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CQLParserK_AND {
		{
			p.SetState(1594)
			p.KwAnd()
		}
		{
			p.SetState(1595)
			p.IfCondition()
		}

		p.SetState(1601)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfConditionContext is an interface to support dynamic dispatch.
type IIfConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OBJECT_NAME() antlr.TerminalNode
	OPERATOR_EQ() antlr.TerminalNode
	Constant() IConstantContext

	// IsIfConditionContext differentiates from other interfaces.
	IsIfConditionContext()
}

type IfConditionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfConditionContext() *IfConditionContext {
	var p = new(IfConditionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_ifCondition
	return p
}

func InitEmptyIfConditionContext(p *IfConditionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_ifCondition
}

func (*IfConditionContext) IsIfConditionContext() {}

func NewIfConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfConditionContext {
	var p = new(IfConditionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_ifCondition

	return p
}

func (s *IfConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *IfConditionContext) OBJECT_NAME() antlr.TerminalNode {
	return s.GetToken(CQLParserOBJECT_NAME, 0)
}

func (s *IfConditionContext) OPERATOR_EQ() antlr.TerminalNode {
	return s.GetToken(CQLParserOPERATOR_EQ, 0)
}

func (s *IfConditionContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *IfConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfConditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterIfCondition(s)
	}
}

func (s *IfConditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitIfCondition(s)
	}
}

func (p *CQLParser) IfCondition() (localctx IIfConditionContext) {
	localctx = NewIfConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, CQLParserRULE_ifCondition)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1602)
		p.Match(CQLParserOBJECT_NAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1603)
		p.Match(CQLParserOPERATOR_EQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1604)
		p.Constant()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignmentsContext is an interface to support dynamic dispatch.
type IAssignmentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAssignmentElement() []IAssignmentElementContext
	AssignmentElement(i int) IAssignmentElementContext
	AllSyntaxComma() []ISyntaxCommaContext
	SyntaxComma(i int) ISyntaxCommaContext

	// IsAssignmentsContext differentiates from other interfaces.
	IsAssignmentsContext()
}

type AssignmentsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentsContext() *AssignmentsContext {
	var p = new(AssignmentsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_assignments
	return p
}

func InitEmptyAssignmentsContext(p *AssignmentsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_assignments
}

func (*AssignmentsContext) IsAssignmentsContext() {}

func NewAssignmentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentsContext {
	var p = new(AssignmentsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_assignments

	return p
}

func (s *AssignmentsContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentsContext) AllAssignmentElement() []IAssignmentElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAssignmentElementContext); ok {
			len++
		}
	}

	tst := make([]IAssignmentElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAssignmentElementContext); ok {
			tst[i] = t.(IAssignmentElementContext)
			i++
		}
	}

	return tst
}

func (s *AssignmentsContext) AssignmentElement(i int) IAssignmentElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentElementContext)
}

func (s *AssignmentsContext) AllSyntaxComma() []ISyntaxCommaContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			len++
		}
	}

	tst := make([]ISyntaxCommaContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISyntaxCommaContext); ok {
			tst[i] = t.(ISyntaxCommaContext)
			i++
		}
	}

	return tst
}

func (s *AssignmentsContext) SyntaxComma(i int) ISyntaxCommaContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxCommaContext)
}

func (s *AssignmentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterAssignments(s)
	}
}

func (s *AssignmentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitAssignments(s)
	}
}

func (p *CQLParser) Assignments() (localctx IAssignmentsContext) {
	localctx = NewAssignmentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, CQLParserRULE_assignments)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1606)
		p.AssignmentElement()
	}

	p.SetState(1612)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CQLParserCOMMA {
		{
			p.SetState(1607)
			p.SyntaxComma()
		}
		{
			p.SetState(1608)
			p.AssignmentElement()
		}

		p.SetState(1614)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignmentElementContext is an interface to support dynamic dispatch.
type IAssignmentElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllOBJECT_NAME() []antlr.TerminalNode
	OBJECT_NAME(i int) antlr.TerminalNode
	OPERATOR_EQ() antlr.TerminalNode
	Constant() IConstantContext
	AssignmentMap() IAssignmentMapContext
	AssignmentSet() IAssignmentSetContext
	AssignmentList() IAssignmentListContext
	DecimalLiteral() IDecimalLiteralContext
	PLUS() antlr.TerminalNode
	MINUS() antlr.TerminalNode
	SyntaxBracketLs() ISyntaxBracketLsContext
	SyntaxBracketRs() ISyntaxBracketRsContext

	// IsAssignmentElementContext differentiates from other interfaces.
	IsAssignmentElementContext()
}

type AssignmentElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentElementContext() *AssignmentElementContext {
	var p = new(AssignmentElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_assignmentElement
	return p
}

func InitEmptyAssignmentElementContext(p *AssignmentElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_assignmentElement
}

func (*AssignmentElementContext) IsAssignmentElementContext() {}

func NewAssignmentElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentElementContext {
	var p = new(AssignmentElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_assignmentElement

	return p
}

func (s *AssignmentElementContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentElementContext) AllOBJECT_NAME() []antlr.TerminalNode {
	return s.GetTokens(CQLParserOBJECT_NAME)
}

func (s *AssignmentElementContext) OBJECT_NAME(i int) antlr.TerminalNode {
	return s.GetToken(CQLParserOBJECT_NAME, i)
}

func (s *AssignmentElementContext) OPERATOR_EQ() antlr.TerminalNode {
	return s.GetToken(CQLParserOPERATOR_EQ, 0)
}

func (s *AssignmentElementContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *AssignmentElementContext) AssignmentMap() IAssignmentMapContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentMapContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentMapContext)
}

func (s *AssignmentElementContext) AssignmentSet() IAssignmentSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentSetContext)
}

func (s *AssignmentElementContext) AssignmentList() IAssignmentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentListContext)
}

func (s *AssignmentElementContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *AssignmentElementContext) PLUS() antlr.TerminalNode {
	return s.GetToken(CQLParserPLUS, 0)
}

func (s *AssignmentElementContext) MINUS() antlr.TerminalNode {
	return s.GetToken(CQLParserMINUS, 0)
}

func (s *AssignmentElementContext) SyntaxBracketLs() ISyntaxBracketLsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketLsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketLsContext)
}

func (s *AssignmentElementContext) SyntaxBracketRs() ISyntaxBracketRsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketRsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketRsContext)
}

func (s *AssignmentElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterAssignmentElement(s)
	}
}

func (s *AssignmentElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitAssignmentElement(s)
	}
}

func (p *CQLParser) AssignmentElement() (localctx IAssignmentElementContext) {
	localctx = NewAssignmentElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, CQLParserRULE_assignmentElement)
	var _la int

	p.SetState(1668)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 130, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1615)
			p.Match(CQLParserOBJECT_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1616)
			p.Match(CQLParserOPERATOR_EQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1621)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 129, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1617)
				p.Constant()
			}

		case 2:
			{
				p.SetState(1618)
				p.AssignmentMap()
			}

		case 3:
			{
				p.SetState(1619)
				p.AssignmentSet()
			}

		case 4:
			{
				p.SetState(1620)
				p.AssignmentList()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1623)
			p.Match(CQLParserOBJECT_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1624)
			p.Match(CQLParserOPERATOR_EQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1625)
			p.Match(CQLParserOBJECT_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1626)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CQLParserPLUS || _la == CQLParserMINUS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1627)
			p.DecimalLiteral()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1628)
			p.Match(CQLParserOBJECT_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1629)
			p.Match(CQLParserOPERATOR_EQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1630)
			p.Match(CQLParserOBJECT_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1631)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CQLParserPLUS || _la == CQLParserMINUS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1632)
			p.AssignmentSet()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1633)
			p.Match(CQLParserOBJECT_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1634)
			p.Match(CQLParserOPERATOR_EQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1635)
			p.AssignmentSet()
		}
		{
			p.SetState(1636)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CQLParserPLUS || _la == CQLParserMINUS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1637)
			p.Match(CQLParserOBJECT_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1639)
			p.Match(CQLParserOBJECT_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1640)
			p.Match(CQLParserOPERATOR_EQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1641)
			p.Match(CQLParserOBJECT_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1642)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CQLParserPLUS || _la == CQLParserMINUS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1643)
			p.AssignmentMap()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1644)
			p.Match(CQLParserOBJECT_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1645)
			p.Match(CQLParserOPERATOR_EQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1646)
			p.AssignmentMap()
		}
		{
			p.SetState(1647)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CQLParserPLUS || _la == CQLParserMINUS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1648)
			p.Match(CQLParserOBJECT_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1650)
			p.Match(CQLParserOBJECT_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1651)
			p.Match(CQLParserOPERATOR_EQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1652)
			p.Match(CQLParserOBJECT_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1653)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CQLParserPLUS || _la == CQLParserMINUS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1654)
			p.AssignmentList()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1655)
			p.Match(CQLParserOBJECT_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1656)
			p.Match(CQLParserOPERATOR_EQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1657)
			p.AssignmentList()
		}
		{
			p.SetState(1658)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CQLParserPLUS || _la == CQLParserMINUS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1659)
			p.Match(CQLParserOBJECT_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1661)
			p.Match(CQLParserOBJECT_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1662)
			p.SyntaxBracketLs()
		}
		{
			p.SetState(1663)
			p.DecimalLiteral()
		}
		{
			p.SetState(1664)
			p.SyntaxBracketRs()
		}
		{
			p.SetState(1665)
			p.Match(CQLParserOPERATOR_EQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1666)
			p.Constant()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignmentSetContext is an interface to support dynamic dispatch.
type IAssignmentSetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SyntaxBracketLc() ISyntaxBracketLcContext
	SyntaxBracketRc() ISyntaxBracketRcContext
	AllConstant() []IConstantContext
	Constant(i int) IConstantContext
	AllSyntaxComma() []ISyntaxCommaContext
	SyntaxComma(i int) ISyntaxCommaContext

	// IsAssignmentSetContext differentiates from other interfaces.
	IsAssignmentSetContext()
}

type AssignmentSetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentSetContext() *AssignmentSetContext {
	var p = new(AssignmentSetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_assignmentSet
	return p
}

func InitEmptyAssignmentSetContext(p *AssignmentSetContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_assignmentSet
}

func (*AssignmentSetContext) IsAssignmentSetContext() {}

func NewAssignmentSetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentSetContext {
	var p = new(AssignmentSetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_assignmentSet

	return p
}

func (s *AssignmentSetContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentSetContext) SyntaxBracketLc() ISyntaxBracketLcContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketLcContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketLcContext)
}

func (s *AssignmentSetContext) SyntaxBracketRc() ISyntaxBracketRcContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketRcContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketRcContext)
}

func (s *AssignmentSetContext) AllConstant() []IConstantContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantContext); ok {
			len++
		}
	}

	tst := make([]IConstantContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantContext); ok {
			tst[i] = t.(IConstantContext)
			i++
		}
	}

	return tst
}

func (s *AssignmentSetContext) Constant(i int) IConstantContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *AssignmentSetContext) AllSyntaxComma() []ISyntaxCommaContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			len++
		}
	}

	tst := make([]ISyntaxCommaContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISyntaxCommaContext); ok {
			tst[i] = t.(ISyntaxCommaContext)
			i++
		}
	}

	return tst
}

func (s *AssignmentSetContext) SyntaxComma(i int) ISyntaxCommaContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxCommaContext)
}

func (s *AssignmentSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentSetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterAssignmentSet(s)
	}
}

func (s *AssignmentSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitAssignmentSet(s)
	}
}

func (p *CQLParser) AssignmentSet() (localctx IAssignmentSetContext) {
	localctx = NewAssignmentSetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, CQLParserRULE_assignmentSet)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1670)
		p.SyntaxBracketLc()
	}
	p.SetState(1680)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CQLParserK_FALSE || _la == CQLParserK_NULL || ((int64((_la-126)) & ^0x3f) == 0 && ((int64(1)<<(_la-126))&43705587204097) != 0) {
		{
			p.SetState(1671)
			p.Constant()
		}
		p.SetState(1677)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == CQLParserCOMMA {
			{
				p.SetState(1672)
				p.SyntaxComma()
			}
			{
				p.SetState(1673)
				p.Constant()
			}

			p.SetState(1679)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(1682)
		p.SyntaxBracketRc()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignmentMapContext is an interface to support dynamic dispatch.
type IAssignmentMapContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SyntaxBracketLc() ISyntaxBracketLcContext
	SyntaxBracketRc() ISyntaxBracketRcContext
	AllConstant() []IConstantContext
	Constant(i int) IConstantContext
	AllSyntaxColon() []ISyntaxColonContext
	SyntaxColon(i int) ISyntaxColonContext
	AllSyntaxComma() []ISyntaxCommaContext
	SyntaxComma(i int) ISyntaxCommaContext

	// IsAssignmentMapContext differentiates from other interfaces.
	IsAssignmentMapContext()
}

type AssignmentMapContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentMapContext() *AssignmentMapContext {
	var p = new(AssignmentMapContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_assignmentMap
	return p
}

func InitEmptyAssignmentMapContext(p *AssignmentMapContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_assignmentMap
}

func (*AssignmentMapContext) IsAssignmentMapContext() {}

func NewAssignmentMapContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentMapContext {
	var p = new(AssignmentMapContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_assignmentMap

	return p
}

func (s *AssignmentMapContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentMapContext) SyntaxBracketLc() ISyntaxBracketLcContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketLcContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketLcContext)
}

func (s *AssignmentMapContext) SyntaxBracketRc() ISyntaxBracketRcContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketRcContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketRcContext)
}

func (s *AssignmentMapContext) AllConstant() []IConstantContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantContext); ok {
			len++
		}
	}

	tst := make([]IConstantContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantContext); ok {
			tst[i] = t.(IConstantContext)
			i++
		}
	}

	return tst
}

func (s *AssignmentMapContext) Constant(i int) IConstantContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *AssignmentMapContext) AllSyntaxColon() []ISyntaxColonContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISyntaxColonContext); ok {
			len++
		}
	}

	tst := make([]ISyntaxColonContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISyntaxColonContext); ok {
			tst[i] = t.(ISyntaxColonContext)
			i++
		}
	}

	return tst
}

func (s *AssignmentMapContext) SyntaxColon(i int) ISyntaxColonContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxColonContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxColonContext)
}

func (s *AssignmentMapContext) AllSyntaxComma() []ISyntaxCommaContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			len++
		}
	}

	tst := make([]ISyntaxCommaContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISyntaxCommaContext); ok {
			tst[i] = t.(ISyntaxCommaContext)
			i++
		}
	}

	return tst
}

func (s *AssignmentMapContext) SyntaxComma(i int) ISyntaxCommaContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxCommaContext)
}

func (s *AssignmentMapContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentMapContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentMapContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterAssignmentMap(s)
	}
}

func (s *AssignmentMapContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitAssignmentMap(s)
	}
}

func (p *CQLParser) AssignmentMap() (localctx IAssignmentMapContext) {
	localctx = NewAssignmentMapContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, CQLParserRULE_assignmentMap)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1684)
		p.SyntaxBracketLc()
	}

	{
		p.SetState(1685)
		p.Constant()
	}
	{
		p.SetState(1686)
		p.SyntaxColon()
	}
	{
		p.SetState(1687)
		p.Constant()
	}

	p.SetState(1696)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CQLParserCOMMA {
		{
			p.SetState(1689)
			p.SyntaxComma()
		}
		{
			p.SetState(1690)
			p.Constant()
		}
		{
			p.SetState(1691)
			p.SyntaxColon()
		}
		{
			p.SetState(1692)
			p.Constant()
		}

		p.SetState(1698)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1699)
		p.SyntaxBracketRc()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignmentListContext is an interface to support dynamic dispatch.
type IAssignmentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SyntaxBracketLs() ISyntaxBracketLsContext
	AllConstant() []IConstantContext
	Constant(i int) IConstantContext
	SyntaxBracketRs() ISyntaxBracketRsContext
	AllSyntaxComma() []ISyntaxCommaContext
	SyntaxComma(i int) ISyntaxCommaContext

	// IsAssignmentListContext differentiates from other interfaces.
	IsAssignmentListContext()
}

type AssignmentListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentListContext() *AssignmentListContext {
	var p = new(AssignmentListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_assignmentList
	return p
}

func InitEmptyAssignmentListContext(p *AssignmentListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_assignmentList
}

func (*AssignmentListContext) IsAssignmentListContext() {}

func NewAssignmentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentListContext {
	var p = new(AssignmentListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_assignmentList

	return p
}

func (s *AssignmentListContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentListContext) SyntaxBracketLs() ISyntaxBracketLsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketLsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketLsContext)
}

func (s *AssignmentListContext) AllConstant() []IConstantContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantContext); ok {
			len++
		}
	}

	tst := make([]IConstantContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantContext); ok {
			tst[i] = t.(IConstantContext)
			i++
		}
	}

	return tst
}

func (s *AssignmentListContext) Constant(i int) IConstantContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *AssignmentListContext) SyntaxBracketRs() ISyntaxBracketRsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketRsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketRsContext)
}

func (s *AssignmentListContext) AllSyntaxComma() []ISyntaxCommaContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			len++
		}
	}

	tst := make([]ISyntaxCommaContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISyntaxCommaContext); ok {
			tst[i] = t.(ISyntaxCommaContext)
			i++
		}
	}

	return tst
}

func (s *AssignmentListContext) SyntaxComma(i int) ISyntaxCommaContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxCommaContext)
}

func (s *AssignmentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterAssignmentList(s)
	}
}

func (s *AssignmentListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitAssignmentList(s)
	}
}

func (p *CQLParser) AssignmentList() (localctx IAssignmentListContext) {
	localctx = NewAssignmentListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, CQLParserRULE_assignmentList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1701)
		p.SyntaxBracketLs()
	}
	{
		p.SetState(1702)
		p.Constant()
	}
	p.SetState(1708)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CQLParserCOMMA {
		{
			p.SetState(1703)
			p.SyntaxComma()
		}
		{
			p.SetState(1704)
			p.Constant()
		}

		p.SetState(1710)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1711)
		p.SyntaxBracketRs()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignmentTupleContext is an interface to support dynamic dispatch.
type IAssignmentTupleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SyntaxBracketLr() ISyntaxBracketLrContext
	SyntaxBracketRr() ISyntaxBracketRrContext
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllSyntaxComma() []ISyntaxCommaContext
	SyntaxComma(i int) ISyntaxCommaContext

	// IsAssignmentTupleContext differentiates from other interfaces.
	IsAssignmentTupleContext()
}

type AssignmentTupleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentTupleContext() *AssignmentTupleContext {
	var p = new(AssignmentTupleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_assignmentTuple
	return p
}

func InitEmptyAssignmentTupleContext(p *AssignmentTupleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_assignmentTuple
}

func (*AssignmentTupleContext) IsAssignmentTupleContext() {}

func NewAssignmentTupleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentTupleContext {
	var p = new(AssignmentTupleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_assignmentTuple

	return p
}

func (s *AssignmentTupleContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentTupleContext) SyntaxBracketLr() ISyntaxBracketLrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketLrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketLrContext)
}

func (s *AssignmentTupleContext) SyntaxBracketRr() ISyntaxBracketRrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketRrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketRrContext)
}

func (s *AssignmentTupleContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AssignmentTupleContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AssignmentTupleContext) AllSyntaxComma() []ISyntaxCommaContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			len++
		}
	}

	tst := make([]ISyntaxCommaContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISyntaxCommaContext); ok {
			tst[i] = t.(ISyntaxCommaContext)
			i++
		}
	}

	return tst
}

func (s *AssignmentTupleContext) SyntaxComma(i int) ISyntaxCommaContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxCommaContext)
}

func (s *AssignmentTupleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentTupleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentTupleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterAssignmentTuple(s)
	}
}

func (s *AssignmentTupleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitAssignmentTuple(s)
	}
}

func (p *CQLParser) AssignmentTuple() (localctx IAssignmentTupleContext) {
	localctx = NewAssignmentTupleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, CQLParserRULE_assignmentTuple)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1713)
		p.SyntaxBracketLr()
	}

	{
		p.SetState(1714)
		p.Expression()
	}
	p.SetState(1720)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CQLParserCOMMA {
		{
			p.SetState(1715)
			p.SyntaxComma()
		}
		{
			p.SetState(1716)
			p.Expression()
		}

		p.SetState(1722)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

	{
		p.SetState(1723)
		p.SyntaxBracketRr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInsertContext is an interface to support dynamic dispatch.
type IInsertContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwInsert() IKwInsertContext
	KwInto() IKwIntoContext
	Table() ITableContext
	InsertValuesSpec() IInsertValuesSpecContext
	BeginBatch() IBeginBatchContext
	Keyspace() IKeyspaceContext
	DOT() antlr.TerminalNode
	InsertColumnSpec() IInsertColumnSpecContext
	IfNotExist() IIfNotExistContext
	UsingTtlTimestamp() IUsingTtlTimestampContext

	// IsInsertContext differentiates from other interfaces.
	IsInsertContext()
}

type InsertContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsertContext() *InsertContext {
	var p = new(InsertContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_insert
	return p
}

func InitEmptyInsertContext(p *InsertContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_insert
}

func (*InsertContext) IsInsertContext() {}

func NewInsertContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InsertContext {
	var p = new(InsertContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_insert

	return p
}

func (s *InsertContext) GetParser() antlr.Parser { return s.parser }

func (s *InsertContext) KwInsert() IKwInsertContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwInsertContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwInsertContext)
}

func (s *InsertContext) KwInto() IKwIntoContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwIntoContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwIntoContext)
}

func (s *InsertContext) Table() ITableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableContext)
}

func (s *InsertContext) InsertValuesSpec() IInsertValuesSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertValuesSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertValuesSpecContext)
}

func (s *InsertContext) BeginBatch() IBeginBatchContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBeginBatchContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBeginBatchContext)
}

func (s *InsertContext) Keyspace() IKeyspaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyspaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyspaceContext)
}

func (s *InsertContext) DOT() antlr.TerminalNode {
	return s.GetToken(CQLParserDOT, 0)
}

func (s *InsertContext) InsertColumnSpec() IInsertColumnSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertColumnSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertColumnSpecContext)
}

func (s *InsertContext) IfNotExist() IIfNotExistContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistContext)
}

func (s *InsertContext) UsingTtlTimestamp() IUsingTtlTimestampContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsingTtlTimestampContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsingTtlTimestampContext)
}

func (s *InsertContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InsertContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterInsert(s)
	}
}

func (s *InsertContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitInsert(s)
	}
}

func (p *CQLParser) Insert() (localctx IInsertContext) {
	localctx = NewInsertContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, CQLParserRULE_insert)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1726)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CQLParserK_BEGIN {
		{
			p.SetState(1725)
			p.BeginBatch()
		}

	}
	{
		p.SetState(1728)
		p.KwInsert()
	}
	{
		p.SetState(1729)
		p.KwInto()
	}
	p.SetState(1733)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 137, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1730)
			p.Keyspace()
		}
		{
			p.SetState(1731)
			p.Match(CQLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1735)
		p.Table()
	}
	p.SetState(1737)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CQLParserLR_BRACKET {
		{
			p.SetState(1736)
			p.InsertColumnSpec()
		}

	}
	{
		p.SetState(1739)
		p.InsertValuesSpec()
	}
	p.SetState(1741)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CQLParserK_IF {
		{
			p.SetState(1740)
			p.IfNotExist()
		}

	}
	p.SetState(1744)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CQLParserK_USING {
		{
			p.SetState(1743)
			p.UsingTtlTimestamp()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUsingTtlTimestampContext is an interface to support dynamic dispatch.
type IUsingTtlTimestampContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwUsing() IKwUsingContext
	Ttl() ITtlContext
	KwAnd() IKwAndContext
	Timestamp() ITimestampContext

	// IsUsingTtlTimestampContext differentiates from other interfaces.
	IsUsingTtlTimestampContext()
}

type UsingTtlTimestampContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUsingTtlTimestampContext() *UsingTtlTimestampContext {
	var p = new(UsingTtlTimestampContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_usingTtlTimestamp
	return p
}

func InitEmptyUsingTtlTimestampContext(p *UsingTtlTimestampContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_usingTtlTimestamp
}

func (*UsingTtlTimestampContext) IsUsingTtlTimestampContext() {}

func NewUsingTtlTimestampContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UsingTtlTimestampContext {
	var p = new(UsingTtlTimestampContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_usingTtlTimestamp

	return p
}

func (s *UsingTtlTimestampContext) GetParser() antlr.Parser { return s.parser }

func (s *UsingTtlTimestampContext) KwUsing() IKwUsingContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwUsingContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwUsingContext)
}

func (s *UsingTtlTimestampContext) Ttl() ITtlContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITtlContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITtlContext)
}

func (s *UsingTtlTimestampContext) KwAnd() IKwAndContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAndContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAndContext)
}

func (s *UsingTtlTimestampContext) Timestamp() ITimestampContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITimestampContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITimestampContext)
}

func (s *UsingTtlTimestampContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UsingTtlTimestampContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UsingTtlTimestampContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterUsingTtlTimestamp(s)
	}
}

func (s *UsingTtlTimestampContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitUsingTtlTimestamp(s)
	}
}

func (p *CQLParser) UsingTtlTimestamp() (localctx IUsingTtlTimestampContext) {
	localctx = NewUsingTtlTimestampContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, CQLParserRULE_usingTtlTimestamp)
	p.SetState(1762)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 141, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1746)
			p.KwUsing()
		}
		{
			p.SetState(1747)
			p.Ttl()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1749)
			p.KwUsing()
		}
		{
			p.SetState(1750)
			p.Ttl()
		}
		{
			p.SetState(1751)
			p.KwAnd()
		}
		{
			p.SetState(1752)
			p.Timestamp()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1754)
			p.KwUsing()
		}
		{
			p.SetState(1755)
			p.Timestamp()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1757)
			p.KwUsing()
		}
		{
			p.SetState(1758)
			p.Timestamp()
		}
		{
			p.SetState(1759)
			p.KwAnd()
		}
		{
			p.SetState(1760)
			p.Ttl()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITimestampContext is an interface to support dynamic dispatch.
type ITimestampContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwTimestamp() IKwTimestampContext
	DecimalLiteral() IDecimalLiteralContext

	// IsTimestampContext differentiates from other interfaces.
	IsTimestampContext()
}

type TimestampContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTimestampContext() *TimestampContext {
	var p = new(TimestampContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_timestamp
	return p
}

func InitEmptyTimestampContext(p *TimestampContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_timestamp
}

func (*TimestampContext) IsTimestampContext() {}

func NewTimestampContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TimestampContext {
	var p = new(TimestampContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_timestamp

	return p
}

func (s *TimestampContext) GetParser() antlr.Parser { return s.parser }

func (s *TimestampContext) KwTimestamp() IKwTimestampContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwTimestampContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwTimestampContext)
}

func (s *TimestampContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *TimestampContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimestampContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TimestampContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterTimestamp(s)
	}
}

func (s *TimestampContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitTimestamp(s)
	}
}

func (p *CQLParser) Timestamp() (localctx ITimestampContext) {
	localctx = NewTimestampContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, CQLParserRULE_timestamp)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1764)
		p.KwTimestamp()
	}
	{
		p.SetState(1765)
		p.DecimalLiteral()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITtlContext is an interface to support dynamic dispatch.
type ITtlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwTtl() IKwTtlContext
	DecimalLiteral() IDecimalLiteralContext

	// IsTtlContext differentiates from other interfaces.
	IsTtlContext()
}

type TtlContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTtlContext() *TtlContext {
	var p = new(TtlContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_ttl
	return p
}

func InitEmptyTtlContext(p *TtlContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_ttl
}

func (*TtlContext) IsTtlContext() {}

func NewTtlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TtlContext {
	var p = new(TtlContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_ttl

	return p
}

func (s *TtlContext) GetParser() antlr.Parser { return s.parser }

func (s *TtlContext) KwTtl() IKwTtlContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwTtlContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwTtlContext)
}

func (s *TtlContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *TtlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TtlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TtlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterTtl(s)
	}
}

func (s *TtlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitTtl(s)
	}
}

func (p *CQLParser) Ttl() (localctx ITtlContext) {
	localctx = NewTtlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, CQLParserRULE_ttl)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1767)
		p.KwTtl()
	}
	{
		p.SetState(1768)
		p.DecimalLiteral()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUsingTimestampSpecContext is an interface to support dynamic dispatch.
type IUsingTimestampSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwUsing() IKwUsingContext
	Timestamp() ITimestampContext

	// IsUsingTimestampSpecContext differentiates from other interfaces.
	IsUsingTimestampSpecContext()
}

type UsingTimestampSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUsingTimestampSpecContext() *UsingTimestampSpecContext {
	var p = new(UsingTimestampSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_usingTimestampSpec
	return p
}

func InitEmptyUsingTimestampSpecContext(p *UsingTimestampSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_usingTimestampSpec
}

func (*UsingTimestampSpecContext) IsUsingTimestampSpecContext() {}

func NewUsingTimestampSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UsingTimestampSpecContext {
	var p = new(UsingTimestampSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_usingTimestampSpec

	return p
}

func (s *UsingTimestampSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *UsingTimestampSpecContext) KwUsing() IKwUsingContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwUsingContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwUsingContext)
}

func (s *UsingTimestampSpecContext) Timestamp() ITimestampContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITimestampContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITimestampContext)
}

func (s *UsingTimestampSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UsingTimestampSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UsingTimestampSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterUsingTimestampSpec(s)
	}
}

func (s *UsingTimestampSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitUsingTimestampSpec(s)
	}
}

func (p *CQLParser) UsingTimestampSpec() (localctx IUsingTimestampSpecContext) {
	localctx = NewUsingTimestampSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, CQLParserRULE_usingTimestampSpec)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1770)
		p.KwUsing()
	}
	{
		p.SetState(1771)
		p.Timestamp()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfNotExistContext is an interface to support dynamic dispatch.
type IIfNotExistContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwIf() IKwIfContext
	KwNot() IKwNotContext
	KwExists() IKwExistsContext

	// IsIfNotExistContext differentiates from other interfaces.
	IsIfNotExistContext()
}

type IfNotExistContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfNotExistContext() *IfNotExistContext {
	var p = new(IfNotExistContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_ifNotExist
	return p
}

func InitEmptyIfNotExistContext(p *IfNotExistContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_ifNotExist
}

func (*IfNotExistContext) IsIfNotExistContext() {}

func NewIfNotExistContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfNotExistContext {
	var p = new(IfNotExistContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_ifNotExist

	return p
}

func (s *IfNotExistContext) GetParser() antlr.Parser { return s.parser }

func (s *IfNotExistContext) KwIf() IKwIfContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwIfContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwIfContext)
}

func (s *IfNotExistContext) KwNot() IKwNotContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwNotContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwNotContext)
}

func (s *IfNotExistContext) KwExists() IKwExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwExistsContext)
}

func (s *IfNotExistContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfNotExistContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfNotExistContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterIfNotExist(s)
	}
}

func (s *IfNotExistContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitIfNotExist(s)
	}
}

func (p *CQLParser) IfNotExist() (localctx IIfNotExistContext) {
	localctx = NewIfNotExistContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, CQLParserRULE_ifNotExist)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1773)
		p.KwIf()
	}
	{
		p.SetState(1774)
		p.KwNot()
	}
	{
		p.SetState(1775)
		p.KwExists()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfExistContext is an interface to support dynamic dispatch.
type IIfExistContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwIf() IKwIfContext
	KwExists() IKwExistsContext

	// IsIfExistContext differentiates from other interfaces.
	IsIfExistContext()
}

type IfExistContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfExistContext() *IfExistContext {
	var p = new(IfExistContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_ifExist
	return p
}

func InitEmptyIfExistContext(p *IfExistContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_ifExist
}

func (*IfExistContext) IsIfExistContext() {}

func NewIfExistContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfExistContext {
	var p = new(IfExistContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_ifExist

	return p
}

func (s *IfExistContext) GetParser() antlr.Parser { return s.parser }

func (s *IfExistContext) KwIf() IKwIfContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwIfContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwIfContext)
}

func (s *IfExistContext) KwExists() IKwExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwExistsContext)
}

func (s *IfExistContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfExistContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfExistContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterIfExist(s)
	}
}

func (s *IfExistContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitIfExist(s)
	}
}

func (p *CQLParser) IfExist() (localctx IIfExistContext) {
	localctx = NewIfExistContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, CQLParserRULE_ifExist)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1777)
		p.KwIf()
	}
	{
		p.SetState(1778)
		p.KwExists()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInsertValuesSpecContext is an interface to support dynamic dispatch.
type IInsertValuesSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwValues() IKwValuesContext
	LR_BRACKET() antlr.TerminalNode
	ExpressionList() IExpressionListContext
	RR_BRACKET() antlr.TerminalNode
	KwJson() IKwJsonContext
	Constant() IConstantContext

	// IsInsertValuesSpecContext differentiates from other interfaces.
	IsInsertValuesSpecContext()
}

type InsertValuesSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsertValuesSpecContext() *InsertValuesSpecContext {
	var p = new(InsertValuesSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_insertValuesSpec
	return p
}

func InitEmptyInsertValuesSpecContext(p *InsertValuesSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_insertValuesSpec
}

func (*InsertValuesSpecContext) IsInsertValuesSpecContext() {}

func NewInsertValuesSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InsertValuesSpecContext {
	var p = new(InsertValuesSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_insertValuesSpec

	return p
}

func (s *InsertValuesSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *InsertValuesSpecContext) KwValues() IKwValuesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwValuesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwValuesContext)
}

func (s *InsertValuesSpecContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(CQLParserLR_BRACKET, 0)
}

func (s *InsertValuesSpecContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *InsertValuesSpecContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(CQLParserRR_BRACKET, 0)
}

func (s *InsertValuesSpecContext) KwJson() IKwJsonContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwJsonContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwJsonContext)
}

func (s *InsertValuesSpecContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *InsertValuesSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertValuesSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InsertValuesSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterInsertValuesSpec(s)
	}
}

func (s *InsertValuesSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitInsertValuesSpec(s)
	}
}

func (p *CQLParser) InsertValuesSpec() (localctx IInsertValuesSpecContext) {
	localctx = NewInsertValuesSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, CQLParserRULE_insertValuesSpec)
	p.SetState(1788)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CQLParserK_VALUES:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1780)
			p.KwValues()
		}
		{
			p.SetState(1781)
			p.Match(CQLParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1782)
			p.ExpressionList()
		}
		{
			p.SetState(1783)
			p.Match(CQLParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case CQLParserK_JSON:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1785)
			p.KwJson()
		}
		{
			p.SetState(1786)
			p.Constant()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInsertColumnSpecContext is an interface to support dynamic dispatch.
type IInsertColumnSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode
	ColumnList() IColumnListContext
	RR_BRACKET() antlr.TerminalNode

	// IsInsertColumnSpecContext differentiates from other interfaces.
	IsInsertColumnSpecContext()
}

type InsertColumnSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsertColumnSpecContext() *InsertColumnSpecContext {
	var p = new(InsertColumnSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_insertColumnSpec
	return p
}

func InitEmptyInsertColumnSpecContext(p *InsertColumnSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_insertColumnSpec
}

func (*InsertColumnSpecContext) IsInsertColumnSpecContext() {}

func NewInsertColumnSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InsertColumnSpecContext {
	var p = new(InsertColumnSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_insertColumnSpec

	return p
}

func (s *InsertColumnSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *InsertColumnSpecContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(CQLParserLR_BRACKET, 0)
}

func (s *InsertColumnSpecContext) ColumnList() IColumnListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnListContext)
}

func (s *InsertColumnSpecContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(CQLParserRR_BRACKET, 0)
}

func (s *InsertColumnSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertColumnSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InsertColumnSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterInsertColumnSpec(s)
	}
}

func (s *InsertColumnSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitInsertColumnSpec(s)
	}
}

func (p *CQLParser) InsertColumnSpec() (localctx IInsertColumnSpecContext) {
	localctx = NewInsertColumnSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, CQLParserRULE_insertColumnSpec)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1790)
		p.Match(CQLParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1791)
		p.ColumnList()
	}
	{
		p.SetState(1792)
		p.Match(CQLParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnListContext is an interface to support dynamic dispatch.
type IColumnListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllColumn() []IColumnContext
	Column(i int) IColumnContext
	AllSyntaxComma() []ISyntaxCommaContext
	SyntaxComma(i int) ISyntaxCommaContext

	// IsColumnListContext differentiates from other interfaces.
	IsColumnListContext()
}

type ColumnListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnListContext() *ColumnListContext {
	var p = new(ColumnListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_columnList
	return p
}

func InitEmptyColumnListContext(p *ColumnListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_columnList
}

func (*ColumnListContext) IsColumnListContext() {}

func NewColumnListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnListContext {
	var p = new(ColumnListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_columnList

	return p
}

func (s *ColumnListContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnListContext) AllColumn() []IColumnContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnContext); ok {
			len++
		}
	}

	tst := make([]IColumnContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnContext); ok {
			tst[i] = t.(IColumnContext)
			i++
		}
	}

	return tst
}

func (s *ColumnListContext) Column(i int) IColumnContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnContext)
}

func (s *ColumnListContext) AllSyntaxComma() []ISyntaxCommaContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			len++
		}
	}

	tst := make([]ISyntaxCommaContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISyntaxCommaContext); ok {
			tst[i] = t.(ISyntaxCommaContext)
			i++
		}
	}

	return tst
}

func (s *ColumnListContext) SyntaxComma(i int) ISyntaxCommaContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxCommaContext)
}

func (s *ColumnListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterColumnList(s)
	}
}

func (s *ColumnListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitColumnList(s)
	}
}

func (p *CQLParser) ColumnList() (localctx IColumnListContext) {
	localctx = NewColumnListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, CQLParserRULE_columnList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1794)
		p.Column()
	}
	p.SetState(1800)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CQLParserCOMMA {
		{
			p.SetState(1795)
			p.SyntaxComma()
		}
		{
			p.SetState(1796)
			p.Column()
		}

		p.SetState(1802)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionListContext is an interface to support dynamic dispatch.
type IExpressionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllSyntaxComma() []ISyntaxCommaContext
	SyntaxComma(i int) ISyntaxCommaContext

	// IsExpressionListContext differentiates from other interfaces.
	IsExpressionListContext()
}

type ExpressionListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionListContext() *ExpressionListContext {
	var p = new(ExpressionListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_expressionList
	return p
}

func InitEmptyExpressionListContext(p *ExpressionListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_expressionList
}

func (*ExpressionListContext) IsExpressionListContext() {}

func NewExpressionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionListContext {
	var p = new(ExpressionListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_expressionList

	return p
}

func (s *ExpressionListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionListContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionListContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionListContext) AllSyntaxComma() []ISyntaxCommaContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			len++
		}
	}

	tst := make([]ISyntaxCommaContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISyntaxCommaContext); ok {
			tst[i] = t.(ISyntaxCommaContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionListContext) SyntaxComma(i int) ISyntaxCommaContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxCommaContext)
}

func (s *ExpressionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterExpressionList(s)
	}
}

func (s *ExpressionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitExpressionList(s)
	}
}

func (p *CQLParser) ExpressionList() (localctx IExpressionListContext) {
	localctx = NewExpressionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, CQLParserRULE_expressionList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1803)
		p.Expression()
	}
	p.SetState(1809)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CQLParserCOMMA {
		{
			p.SetState(1804)
			p.SyntaxComma()
		}
		{
			p.SetState(1805)
			p.Expression()
		}

		p.SetState(1811)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Constant() IConstantContext
	FunctionCall() IFunctionCallContext
	AssignmentMap() IAssignmentMapContext
	AssignmentSet() IAssignmentSetContext
	AssignmentList() IAssignmentListContext
	AssignmentTuple() IAssignmentTupleContext

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_expression
	return p
}

func InitEmptyExpressionContext(p *ExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_expression
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *ExpressionContext) FunctionCall() IFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *ExpressionContext) AssignmentMap() IAssignmentMapContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentMapContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentMapContext)
}

func (s *ExpressionContext) AssignmentSet() IAssignmentSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentSetContext)
}

func (s *ExpressionContext) AssignmentList() IAssignmentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentListContext)
}

func (s *ExpressionContext) AssignmentTuple() IAssignmentTupleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentTupleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentTupleContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitExpression(s)
	}
}

func (p *CQLParser) Expression() (localctx IExpressionContext) {
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, CQLParserRULE_expression)
	p.SetState(1818)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 145, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1812)
			p.Constant()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1813)
			p.FunctionCall()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1814)
			p.AssignmentMap()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1815)
			p.AssignmentSet()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1816)
			p.AssignmentList()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1817)
			p.AssignmentTuple()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelect_Context is an interface to support dynamic dispatch.
type ISelect_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwSelect() IKwSelectContext
	SelectElements() ISelectElementsContext
	FromSpec() IFromSpecContext
	DistinctSpec() IDistinctSpecContext
	KwJson() IKwJsonContext
	WhereSpec() IWhereSpecContext
	OrderSpec() IOrderSpecContext
	LimitSpec() ILimitSpecContext
	AllowFilteringSpec() IAllowFilteringSpecContext

	// IsSelect_Context differentiates from other interfaces.
	IsSelect_Context()
}

type Select_Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelect_Context() *Select_Context {
	var p = new(Select_Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_select_
	return p
}

func InitEmptySelect_Context(p *Select_Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_select_
}

func (*Select_Context) IsSelect_Context() {}

func NewSelect_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Select_Context {
	var p = new(Select_Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_select_

	return p
}

func (s *Select_Context) GetParser() antlr.Parser { return s.parser }

func (s *Select_Context) KwSelect() IKwSelectContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwSelectContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwSelectContext)
}

func (s *Select_Context) SelectElements() ISelectElementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectElementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectElementsContext)
}

func (s *Select_Context) FromSpec() IFromSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromSpecContext)
}

func (s *Select_Context) DistinctSpec() IDistinctSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDistinctSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDistinctSpecContext)
}

func (s *Select_Context) KwJson() IKwJsonContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwJsonContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwJsonContext)
}

func (s *Select_Context) WhereSpec() IWhereSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereSpecContext)
}

func (s *Select_Context) OrderSpec() IOrderSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderSpecContext)
}

func (s *Select_Context) LimitSpec() ILimitSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitSpecContext)
}

func (s *Select_Context) AllowFilteringSpec() IAllowFilteringSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAllowFilteringSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAllowFilteringSpecContext)
}

func (s *Select_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Select_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Select_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterSelect_(s)
	}
}

func (s *Select_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitSelect_(s)
	}
}

func (p *CQLParser) Select_() (localctx ISelect_Context) {
	localctx = NewSelect_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, CQLParserRULE_select_)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1820)
		p.KwSelect()
	}
	p.SetState(1822)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CQLParserK_DISTINCT {
		{
			p.SetState(1821)
			p.DistinctSpec()
		}

	}
	p.SetState(1825)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CQLParserK_JSON {
		{
			p.SetState(1824)
			p.KwJson()
		}

	}
	{
		p.SetState(1827)
		p.SelectElements()
	}
	{
		p.SetState(1828)
		p.FromSpec()
	}
	p.SetState(1830)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CQLParserK_WHERE {
		{
			p.SetState(1829)
			p.WhereSpec()
		}

	}
	p.SetState(1833)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CQLParserK_ORDER {
		{
			p.SetState(1832)
			p.OrderSpec()
		}

	}
	p.SetState(1836)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CQLParserK_LIMIT {
		{
			p.SetState(1835)
			p.LimitSpec()
		}

	}
	p.SetState(1839)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CQLParserK_ALLOW {
		{
			p.SetState(1838)
			p.AllowFilteringSpec()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAllowFilteringSpecContext is an interface to support dynamic dispatch.
type IAllowFilteringSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwAllow() IKwAllowContext
	KwFiltering() IKwFilteringContext

	// IsAllowFilteringSpecContext differentiates from other interfaces.
	IsAllowFilteringSpecContext()
}

type AllowFilteringSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAllowFilteringSpecContext() *AllowFilteringSpecContext {
	var p = new(AllowFilteringSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_allowFilteringSpec
	return p
}

func InitEmptyAllowFilteringSpecContext(p *AllowFilteringSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_allowFilteringSpec
}

func (*AllowFilteringSpecContext) IsAllowFilteringSpecContext() {}

func NewAllowFilteringSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AllowFilteringSpecContext {
	var p = new(AllowFilteringSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_allowFilteringSpec

	return p
}

func (s *AllowFilteringSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *AllowFilteringSpecContext) KwAllow() IKwAllowContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAllowContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAllowContext)
}

func (s *AllowFilteringSpecContext) KwFiltering() IKwFilteringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwFilteringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwFilteringContext)
}

func (s *AllowFilteringSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AllowFilteringSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AllowFilteringSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterAllowFilteringSpec(s)
	}
}

func (s *AllowFilteringSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitAllowFilteringSpec(s)
	}
}

func (p *CQLParser) AllowFilteringSpec() (localctx IAllowFilteringSpecContext) {
	localctx = NewAllowFilteringSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, CQLParserRULE_allowFilteringSpec)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1841)
		p.KwAllow()
	}
	{
		p.SetState(1842)
		p.KwFiltering()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILimitSpecContext is an interface to support dynamic dispatch.
type ILimitSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwLimit() IKwLimitContext
	DecimalLiteral() IDecimalLiteralContext

	// IsLimitSpecContext differentiates from other interfaces.
	IsLimitSpecContext()
}

type LimitSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLimitSpecContext() *LimitSpecContext {
	var p = new(LimitSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_limitSpec
	return p
}

func InitEmptyLimitSpecContext(p *LimitSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_limitSpec
}

func (*LimitSpecContext) IsLimitSpecContext() {}

func NewLimitSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LimitSpecContext {
	var p = new(LimitSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_limitSpec

	return p
}

func (s *LimitSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *LimitSpecContext) KwLimit() IKwLimitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwLimitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwLimitContext)
}

func (s *LimitSpecContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *LimitSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LimitSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LimitSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterLimitSpec(s)
	}
}

func (s *LimitSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitLimitSpec(s)
	}
}

func (p *CQLParser) LimitSpec() (localctx ILimitSpecContext) {
	localctx = NewLimitSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, CQLParserRULE_limitSpec)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1844)
		p.KwLimit()
	}
	{
		p.SetState(1845)
		p.DecimalLiteral()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFromSpecContext is an interface to support dynamic dispatch.
type IFromSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwFrom() IKwFromContext
	FromSpecElement() IFromSpecElementContext

	// IsFromSpecContext differentiates from other interfaces.
	IsFromSpecContext()
}

type FromSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFromSpecContext() *FromSpecContext {
	var p = new(FromSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_fromSpec
	return p
}

func InitEmptyFromSpecContext(p *FromSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_fromSpec
}

func (*FromSpecContext) IsFromSpecContext() {}

func NewFromSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FromSpecContext {
	var p = new(FromSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_fromSpec

	return p
}

func (s *FromSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *FromSpecContext) KwFrom() IKwFromContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwFromContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwFromContext)
}

func (s *FromSpecContext) FromSpecElement() IFromSpecElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromSpecElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromSpecElementContext)
}

func (s *FromSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FromSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FromSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterFromSpec(s)
	}
}

func (s *FromSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitFromSpec(s)
	}
}

func (p *CQLParser) FromSpec() (localctx IFromSpecContext) {
	localctx = NewFromSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, CQLParserRULE_fromSpec)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1847)
		p.KwFrom()
	}
	{
		p.SetState(1848)
		p.FromSpecElement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFromSpecElementContext is an interface to support dynamic dispatch.
type IFromSpecElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllOBJECT_NAME() []antlr.TerminalNode
	OBJECT_NAME(i int) antlr.TerminalNode
	DOT() antlr.TerminalNode

	// IsFromSpecElementContext differentiates from other interfaces.
	IsFromSpecElementContext()
}

type FromSpecElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFromSpecElementContext() *FromSpecElementContext {
	var p = new(FromSpecElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_fromSpecElement
	return p
}

func InitEmptyFromSpecElementContext(p *FromSpecElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_fromSpecElement
}

func (*FromSpecElementContext) IsFromSpecElementContext() {}

func NewFromSpecElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FromSpecElementContext {
	var p = new(FromSpecElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_fromSpecElement

	return p
}

func (s *FromSpecElementContext) GetParser() antlr.Parser { return s.parser }

func (s *FromSpecElementContext) AllOBJECT_NAME() []antlr.TerminalNode {
	return s.GetTokens(CQLParserOBJECT_NAME)
}

func (s *FromSpecElementContext) OBJECT_NAME(i int) antlr.TerminalNode {
	return s.GetToken(CQLParserOBJECT_NAME, i)
}

func (s *FromSpecElementContext) DOT() antlr.TerminalNode {
	return s.GetToken(CQLParserDOT, 0)
}

func (s *FromSpecElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FromSpecElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FromSpecElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterFromSpecElement(s)
	}
}

func (s *FromSpecElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitFromSpecElement(s)
	}
}

func (p *CQLParser) FromSpecElement() (localctx IFromSpecElementContext) {
	localctx = NewFromSpecElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, CQLParserRULE_fromSpecElement)
	p.SetState(1854)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 152, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1850)
			p.Match(CQLParserOBJECT_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1851)
			p.Match(CQLParserOBJECT_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1852)
			p.Match(CQLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1853)
			p.Match(CQLParserOBJECT_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOrderSpecContext is an interface to support dynamic dispatch.
type IOrderSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwOrder() IKwOrderContext
	KwBy() IKwByContext
	OrderSpecElement() IOrderSpecElementContext

	// IsOrderSpecContext differentiates from other interfaces.
	IsOrderSpecContext()
}

type OrderSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrderSpecContext() *OrderSpecContext {
	var p = new(OrderSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_orderSpec
	return p
}

func InitEmptyOrderSpecContext(p *OrderSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_orderSpec
}

func (*OrderSpecContext) IsOrderSpecContext() {}

func NewOrderSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrderSpecContext {
	var p = new(OrderSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_orderSpec

	return p
}

func (s *OrderSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *OrderSpecContext) KwOrder() IKwOrderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwOrderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwOrderContext)
}

func (s *OrderSpecContext) KwBy() IKwByContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwByContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwByContext)
}

func (s *OrderSpecContext) OrderSpecElement() IOrderSpecElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderSpecElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderSpecElementContext)
}

func (s *OrderSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrderSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrderSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterOrderSpec(s)
	}
}

func (s *OrderSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitOrderSpec(s)
	}
}

func (p *CQLParser) OrderSpec() (localctx IOrderSpecContext) {
	localctx = NewOrderSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, CQLParserRULE_orderSpec)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1856)
		p.KwOrder()
	}
	{
		p.SetState(1857)
		p.KwBy()
	}
	{
		p.SetState(1858)
		p.OrderSpecElement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOrderSpecElementContext is an interface to support dynamic dispatch.
type IOrderSpecElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OBJECT_NAME() antlr.TerminalNode
	KwAsc() IKwAscContext
	KwDesc() IKwDescContext

	// IsOrderSpecElementContext differentiates from other interfaces.
	IsOrderSpecElementContext()
}

type OrderSpecElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrderSpecElementContext() *OrderSpecElementContext {
	var p = new(OrderSpecElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_orderSpecElement
	return p
}

func InitEmptyOrderSpecElementContext(p *OrderSpecElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_orderSpecElement
}

func (*OrderSpecElementContext) IsOrderSpecElementContext() {}

func NewOrderSpecElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrderSpecElementContext {
	var p = new(OrderSpecElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_orderSpecElement

	return p
}

func (s *OrderSpecElementContext) GetParser() antlr.Parser { return s.parser }

func (s *OrderSpecElementContext) OBJECT_NAME() antlr.TerminalNode {
	return s.GetToken(CQLParserOBJECT_NAME, 0)
}

func (s *OrderSpecElementContext) KwAsc() IKwAscContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAscContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAscContext)
}

func (s *OrderSpecElementContext) KwDesc() IKwDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwDescContext)
}

func (s *OrderSpecElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrderSpecElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrderSpecElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterOrderSpecElement(s)
	}
}

func (s *OrderSpecElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitOrderSpecElement(s)
	}
}

func (p *CQLParser) OrderSpecElement() (localctx IOrderSpecElementContext) {
	localctx = NewOrderSpecElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, CQLParserRULE_orderSpecElement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1860)
		p.Match(CQLParserOBJECT_NAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1863)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case CQLParserK_ASC:
		{
			p.SetState(1861)
			p.KwAsc()
		}

	case CQLParserK_DESC:
		{
			p.SetState(1862)
			p.KwDesc()
		}

	case CQLParserEOF, CQLParserSEMI, CQLParserMINUSMINUS, CQLParserK_ALLOW, CQLParserK_LIMIT:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhereSpecContext is an interface to support dynamic dispatch.
type IWhereSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwWhere() IKwWhereContext
	RelationElements() IRelationElementsContext

	// IsWhereSpecContext differentiates from other interfaces.
	IsWhereSpecContext()
}

type WhereSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhereSpecContext() *WhereSpecContext {
	var p = new(WhereSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_whereSpec
	return p
}

func InitEmptyWhereSpecContext(p *WhereSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_whereSpec
}

func (*WhereSpecContext) IsWhereSpecContext() {}

func NewWhereSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhereSpecContext {
	var p = new(WhereSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_whereSpec

	return p
}

func (s *WhereSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *WhereSpecContext) KwWhere() IKwWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwWhereContext)
}

func (s *WhereSpecContext) RelationElements() IRelationElementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationElementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationElementsContext)
}

func (s *WhereSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhereSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhereSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterWhereSpec(s)
	}
}

func (s *WhereSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitWhereSpec(s)
	}
}

func (p *CQLParser) WhereSpec() (localctx IWhereSpecContext) {
	localctx = NewWhereSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, CQLParserRULE_whereSpec)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1865)
		p.KwWhere()
	}
	{
		p.SetState(1866)
		p.RelationElements()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDistinctSpecContext is an interface to support dynamic dispatch.
type IDistinctSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwDistinct() IKwDistinctContext

	// IsDistinctSpecContext differentiates from other interfaces.
	IsDistinctSpecContext()
}

type DistinctSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDistinctSpecContext() *DistinctSpecContext {
	var p = new(DistinctSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_distinctSpec
	return p
}

func InitEmptyDistinctSpecContext(p *DistinctSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_distinctSpec
}

func (*DistinctSpecContext) IsDistinctSpecContext() {}

func NewDistinctSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DistinctSpecContext {
	var p = new(DistinctSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_distinctSpec

	return p
}

func (s *DistinctSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *DistinctSpecContext) KwDistinct() IKwDistinctContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwDistinctContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwDistinctContext)
}

func (s *DistinctSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DistinctSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DistinctSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterDistinctSpec(s)
	}
}

func (s *DistinctSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitDistinctSpec(s)
	}
}

func (p *CQLParser) DistinctSpec() (localctx IDistinctSpecContext) {
	localctx = NewDistinctSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, CQLParserRULE_distinctSpec)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1868)
		p.KwDistinct()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectElementsContext is an interface to support dynamic dispatch.
type ISelectElementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetStar returns the star token.
	GetStar() antlr.Token

	// SetStar sets the star token.
	SetStar(antlr.Token)

	// Getter signatures
	AllSelectElement() []ISelectElementContext
	SelectElement(i int) ISelectElementContext
	STAR() antlr.TerminalNode
	AllSyntaxComma() []ISyntaxCommaContext
	SyntaxComma(i int) ISyntaxCommaContext

	// IsSelectElementsContext differentiates from other interfaces.
	IsSelectElementsContext()
}

type SelectElementsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	star   antlr.Token
}

func NewEmptySelectElementsContext() *SelectElementsContext {
	var p = new(SelectElementsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_selectElements
	return p
}

func InitEmptySelectElementsContext(p *SelectElementsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_selectElements
}

func (*SelectElementsContext) IsSelectElementsContext() {}

func NewSelectElementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectElementsContext {
	var p = new(SelectElementsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_selectElements

	return p
}

func (s *SelectElementsContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectElementsContext) GetStar() antlr.Token { return s.star }

func (s *SelectElementsContext) SetStar(v antlr.Token) { s.star = v }

func (s *SelectElementsContext) AllSelectElement() []ISelectElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelectElementContext); ok {
			len++
		}
	}

	tst := make([]ISelectElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelectElementContext); ok {
			tst[i] = t.(ISelectElementContext)
			i++
		}
	}

	return tst
}

func (s *SelectElementsContext) SelectElement(i int) ISelectElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectElementContext)
}

func (s *SelectElementsContext) STAR() antlr.TerminalNode {
	return s.GetToken(CQLParserSTAR, 0)
}

func (s *SelectElementsContext) AllSyntaxComma() []ISyntaxCommaContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			len++
		}
	}

	tst := make([]ISyntaxCommaContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISyntaxCommaContext); ok {
			tst[i] = t.(ISyntaxCommaContext)
			i++
		}
	}

	return tst
}

func (s *SelectElementsContext) SyntaxComma(i int) ISyntaxCommaContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxCommaContext)
}

func (s *SelectElementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectElementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectElementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterSelectElements(s)
	}
}

func (s *SelectElementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitSelectElements(s)
	}
}

func (p *CQLParser) SelectElements() (localctx ISelectElementsContext) {
	localctx = NewSelectElementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, CQLParserRULE_selectElements)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1872)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CQLParserSTAR:
		{
			p.SetState(1870)

			var _m = p.Match(CQLParserSTAR)

			localctx.(*SelectElementsContext).star = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case CQLParserK_UUID, CQLParserOBJECT_NAME:
		{
			p.SetState(1871)
			p.SelectElement()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(1879)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CQLParserCOMMA {
		{
			p.SetState(1874)
			p.SyntaxComma()
		}
		{
			p.SetState(1875)
			p.SelectElement()
		}

		p.SetState(1881)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectElementContext is an interface to support dynamic dispatch.
type ISelectElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllOBJECT_NAME() []antlr.TerminalNode
	OBJECT_NAME(i int) antlr.TerminalNode
	DOT() antlr.TerminalNode
	STAR() antlr.TerminalNode
	KwAs() IKwAsContext
	FunctionCall() IFunctionCallContext

	// IsSelectElementContext differentiates from other interfaces.
	IsSelectElementContext()
}

type SelectElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectElementContext() *SelectElementContext {
	var p = new(SelectElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_selectElement
	return p
}

func InitEmptySelectElementContext(p *SelectElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_selectElement
}

func (*SelectElementContext) IsSelectElementContext() {}

func NewSelectElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectElementContext {
	var p = new(SelectElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_selectElement

	return p
}

func (s *SelectElementContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectElementContext) AllOBJECT_NAME() []antlr.TerminalNode {
	return s.GetTokens(CQLParserOBJECT_NAME)
}

func (s *SelectElementContext) OBJECT_NAME(i int) antlr.TerminalNode {
	return s.GetToken(CQLParserOBJECT_NAME, i)
}

func (s *SelectElementContext) DOT() antlr.TerminalNode {
	return s.GetToken(CQLParserDOT, 0)
}

func (s *SelectElementContext) STAR() antlr.TerminalNode {
	return s.GetToken(CQLParserSTAR, 0)
}

func (s *SelectElementContext) KwAs() IKwAsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAsContext)
}

func (s *SelectElementContext) FunctionCall() IFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *SelectElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterSelectElement(s)
	}
}

func (s *SelectElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitSelectElement(s)
	}
}

func (p *CQLParser) SelectElement() (localctx ISelectElementContext) {
	localctx = NewSelectElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, CQLParserRULE_selectElement)
	var _la int

	p.SetState(1897)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 158, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1882)
			p.Match(CQLParserOBJECT_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1883)
			p.Match(CQLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1884)
			p.Match(CQLParserSTAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1885)
			p.Match(CQLParserOBJECT_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1889)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CQLParserK_AS {
			{
				p.SetState(1886)
				p.KwAs()
			}
			{
				p.SetState(1887)
				p.Match(CQLParserOBJECT_NAME)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1891)
			p.FunctionCall()
		}
		p.SetState(1895)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CQLParserK_AS {
			{
				p.SetState(1892)
				p.KwAs()
			}
			{
				p.SetState(1893)
				p.Match(CQLParserOBJECT_NAME)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelationElementsContext is an interface to support dynamic dispatch.
type IRelationElementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllRelationElement() []IRelationElementContext
	RelationElement(i int) IRelationElementContext
	AllKwAnd() []IKwAndContext
	KwAnd(i int) IKwAndContext

	// IsRelationElementsContext differentiates from other interfaces.
	IsRelationElementsContext()
}

type RelationElementsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationElementsContext() *RelationElementsContext {
	var p = new(RelationElementsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_relationElements
	return p
}

func InitEmptyRelationElementsContext(p *RelationElementsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_relationElements
}

func (*RelationElementsContext) IsRelationElementsContext() {}

func NewRelationElementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationElementsContext {
	var p = new(RelationElementsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_relationElements

	return p
}

func (s *RelationElementsContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationElementsContext) AllRelationElement() []IRelationElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRelationElementContext); ok {
			len++
		}
	}

	tst := make([]IRelationElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRelationElementContext); ok {
			tst[i] = t.(IRelationElementContext)
			i++
		}
	}

	return tst
}

func (s *RelationElementsContext) RelationElement(i int) IRelationElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationElementContext)
}

func (s *RelationElementsContext) AllKwAnd() []IKwAndContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IKwAndContext); ok {
			len++
		}
	}

	tst := make([]IKwAndContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IKwAndContext); ok {
			tst[i] = t.(IKwAndContext)
			i++
		}
	}

	return tst
}

func (s *RelationElementsContext) KwAnd(i int) IKwAndContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAndContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAndContext)
}

func (s *RelationElementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationElementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationElementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterRelationElements(s)
	}
}

func (s *RelationElementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitRelationElements(s)
	}
}

func (p *CQLParser) RelationElements() (localctx IRelationElementsContext) {
	localctx = NewRelationElementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, CQLParserRULE_relationElements)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1899)
		p.RelationElement()
	}

	p.SetState(1905)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CQLParserK_AND {
		{
			p.SetState(1900)
			p.KwAnd()
		}
		{
			p.SetState(1901)
			p.RelationElement()
		}

		p.SetState(1907)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelationElementContext is an interface to support dynamic dispatch.
type IRelationElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllOBJECT_NAME() []antlr.TerminalNode
	OBJECT_NAME(i int) antlr.TerminalNode
	Constant() IConstantContext
	OPERATOR_EQ() antlr.TerminalNode
	OPERATOR_LT() antlr.TerminalNode
	OPERATOR_GT() antlr.TerminalNode
	OPERATOR_LTE() antlr.TerminalNode
	OPERATOR_GTE() antlr.TerminalNode
	DOT() antlr.TerminalNode
	AllFunctionCall() []IFunctionCallContext
	FunctionCall(i int) IFunctionCallContext
	KwIn() IKwInContext
	AllLR_BRACKET() []antlr.TerminalNode
	LR_BRACKET(i int) antlr.TerminalNode
	AllRR_BRACKET() []antlr.TerminalNode
	RR_BRACKET(i int) antlr.TerminalNode
	FunctionArgs() IFunctionArgsContext
	AllAssignmentTuple() []IAssignmentTupleContext
	AssignmentTuple(i int) IAssignmentTupleContext
	AllSyntaxComma() []ISyntaxCommaContext
	SyntaxComma(i int) ISyntaxCommaContext
	RelalationContainsKey() IRelalationContainsKeyContext
	RelalationContains() IRelalationContainsContext

	// IsRelationElementContext differentiates from other interfaces.
	IsRelationElementContext()
}

type RelationElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationElementContext() *RelationElementContext {
	var p = new(RelationElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_relationElement
	return p
}

func InitEmptyRelationElementContext(p *RelationElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_relationElement
}

func (*RelationElementContext) IsRelationElementContext() {}

func NewRelationElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationElementContext {
	var p = new(RelationElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_relationElement

	return p
}

func (s *RelationElementContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationElementContext) AllOBJECT_NAME() []antlr.TerminalNode {
	return s.GetTokens(CQLParserOBJECT_NAME)
}

func (s *RelationElementContext) OBJECT_NAME(i int) antlr.TerminalNode {
	return s.GetToken(CQLParserOBJECT_NAME, i)
}

func (s *RelationElementContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *RelationElementContext) OPERATOR_EQ() antlr.TerminalNode {
	return s.GetToken(CQLParserOPERATOR_EQ, 0)
}

func (s *RelationElementContext) OPERATOR_LT() antlr.TerminalNode {
	return s.GetToken(CQLParserOPERATOR_LT, 0)
}

func (s *RelationElementContext) OPERATOR_GT() antlr.TerminalNode {
	return s.GetToken(CQLParserOPERATOR_GT, 0)
}

func (s *RelationElementContext) OPERATOR_LTE() antlr.TerminalNode {
	return s.GetToken(CQLParserOPERATOR_LTE, 0)
}

func (s *RelationElementContext) OPERATOR_GTE() antlr.TerminalNode {
	return s.GetToken(CQLParserOPERATOR_GTE, 0)
}

func (s *RelationElementContext) DOT() antlr.TerminalNode {
	return s.GetToken(CQLParserDOT, 0)
}

func (s *RelationElementContext) AllFunctionCall() []IFunctionCallContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFunctionCallContext); ok {
			len++
		}
	}

	tst := make([]IFunctionCallContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFunctionCallContext); ok {
			tst[i] = t.(IFunctionCallContext)
			i++
		}
	}

	return tst
}

func (s *RelationElementContext) FunctionCall(i int) IFunctionCallContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *RelationElementContext) KwIn() IKwInContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwInContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwInContext)
}

func (s *RelationElementContext) AllLR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(CQLParserLR_BRACKET)
}

func (s *RelationElementContext) LR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(CQLParserLR_BRACKET, i)
}

func (s *RelationElementContext) AllRR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(CQLParserRR_BRACKET)
}

func (s *RelationElementContext) RR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(CQLParserRR_BRACKET, i)
}

func (s *RelationElementContext) FunctionArgs() IFunctionArgsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionArgsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionArgsContext)
}

func (s *RelationElementContext) AllAssignmentTuple() []IAssignmentTupleContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAssignmentTupleContext); ok {
			len++
		}
	}

	tst := make([]IAssignmentTupleContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAssignmentTupleContext); ok {
			tst[i] = t.(IAssignmentTupleContext)
			i++
		}
	}

	return tst
}

func (s *RelationElementContext) AssignmentTuple(i int) IAssignmentTupleContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentTupleContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentTupleContext)
}

func (s *RelationElementContext) AllSyntaxComma() []ISyntaxCommaContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			len++
		}
	}

	tst := make([]ISyntaxCommaContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISyntaxCommaContext); ok {
			tst[i] = t.(ISyntaxCommaContext)
			i++
		}
	}

	return tst
}

func (s *RelationElementContext) SyntaxComma(i int) ISyntaxCommaContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxCommaContext)
}

func (s *RelationElementContext) RelalationContainsKey() IRelalationContainsKeyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelalationContainsKeyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelalationContainsKeyContext)
}

func (s *RelationElementContext) RelalationContains() IRelalationContainsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelalationContainsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelalationContainsContext)
}

func (s *RelationElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterRelationElement(s)
	}
}

func (s *RelationElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitRelationElement(s)
	}
}

func (p *CQLParser) RelationElement() (localctx IRelationElementContext) {
	localctx = NewRelationElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, CQLParserRULE_relationElement)
	var _la int

	p.SetState(1979)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 165, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1908)
			p.Match(CQLParserOBJECT_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1909)
			_la = p.GetTokenStream().LA(1)

			if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&16252928) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1910)
			p.Constant()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1911)
			p.Match(CQLParserOBJECT_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1912)
			p.Match(CQLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1913)
			p.Match(CQLParserOBJECT_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1914)
			_la = p.GetTokenStream().LA(1)

			if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&16252928) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1915)
			p.Constant()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1916)
			p.FunctionCall()
		}
		{
			p.SetState(1917)
			_la = p.GetTokenStream().LA(1)

			if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&16252928) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1918)
			p.Constant()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1920)
			p.FunctionCall()
		}
		{
			p.SetState(1921)
			_la = p.GetTokenStream().LA(1)

			if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&16252928) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1922)
			p.FunctionCall()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1924)
			p.Match(CQLParserOBJECT_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1925)
			p.KwIn()
		}
		{
			p.SetState(1926)
			p.Match(CQLParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1928)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CQLParserK_FALSE || _la == CQLParserK_NULL || ((int64((_la-126)) & ^0x3f) == 0 && ((int64(1)<<(_la-126))&61297773249537) != 0) {
			{
				p.SetState(1927)
				p.FunctionArgs()
			}

		}
		{
			p.SetState(1930)
			p.Match(CQLParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1932)
			p.Match(CQLParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1933)
			p.Match(CQLParserOBJECT_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1939)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == CQLParserCOMMA {
			{
				p.SetState(1934)
				p.SyntaxComma()
			}
			{
				p.SetState(1935)
				p.Match(CQLParserOBJECT_NAME)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1941)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1942)
			p.Match(CQLParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1943)
			p.KwIn()
		}
		{
			p.SetState(1944)
			p.Match(CQLParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1945)
			p.AssignmentTuple()
		}
		p.SetState(1951)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == CQLParserCOMMA {
			{
				p.SetState(1946)
				p.SyntaxComma()
			}
			{
				p.SetState(1947)
				p.AssignmentTuple()
			}

			p.SetState(1953)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1954)
			p.Match(CQLParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1956)
			p.Match(CQLParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1957)
			p.Match(CQLParserOBJECT_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1963)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == CQLParserCOMMA {
			{
				p.SetState(1958)
				p.SyntaxComma()
			}
			{
				p.SetState(1959)
				p.Match(CQLParserOBJECT_NAME)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(1965)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1966)
			p.Match(CQLParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1967)
			_la = p.GetTokenStream().LA(1)

			if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&16252928) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

		{
			p.SetState(1968)
			p.AssignmentTuple()
		}
		p.SetState(1974)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == CQLParserCOMMA {
			{
				p.SetState(1969)
				p.SyntaxComma()
			}
			{
				p.SetState(1970)
				p.AssignmentTuple()
			}

			p.SetState(1976)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1977)
			p.RelalationContainsKey()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1978)
			p.RelalationContains()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelalationContainsContext is an interface to support dynamic dispatch.
type IRelalationContainsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OBJECT_NAME() antlr.TerminalNode
	KwContains() IKwContainsContext
	Constant() IConstantContext

	// IsRelalationContainsContext differentiates from other interfaces.
	IsRelalationContainsContext()
}

type RelalationContainsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelalationContainsContext() *RelalationContainsContext {
	var p = new(RelalationContainsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_relalationContains
	return p
}

func InitEmptyRelalationContainsContext(p *RelalationContainsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_relalationContains
}

func (*RelalationContainsContext) IsRelalationContainsContext() {}

func NewRelalationContainsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelalationContainsContext {
	var p = new(RelalationContainsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_relalationContains

	return p
}

func (s *RelalationContainsContext) GetParser() antlr.Parser { return s.parser }

func (s *RelalationContainsContext) OBJECT_NAME() antlr.TerminalNode {
	return s.GetToken(CQLParserOBJECT_NAME, 0)
}

func (s *RelalationContainsContext) KwContains() IKwContainsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwContainsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwContainsContext)
}

func (s *RelalationContainsContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *RelalationContainsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelalationContainsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelalationContainsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterRelalationContains(s)
	}
}

func (s *RelalationContainsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitRelalationContains(s)
	}
}

func (p *CQLParser) RelalationContains() (localctx IRelalationContainsContext) {
	localctx = NewRelalationContainsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, CQLParserRULE_relalationContains)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1981)
		p.Match(CQLParserOBJECT_NAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1982)
		p.KwContains()
	}
	{
		p.SetState(1983)
		p.Constant()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelalationContainsKeyContext is an interface to support dynamic dispatch.
type IRelalationContainsKeyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OBJECT_NAME() antlr.TerminalNode
	Constant() IConstantContext
	KwContains() IKwContainsContext
	KwKey() IKwKeyContext

	// IsRelalationContainsKeyContext differentiates from other interfaces.
	IsRelalationContainsKeyContext()
}

type RelalationContainsKeyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelalationContainsKeyContext() *RelalationContainsKeyContext {
	var p = new(RelalationContainsKeyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_relalationContainsKey
	return p
}

func InitEmptyRelalationContainsKeyContext(p *RelalationContainsKeyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_relalationContainsKey
}

func (*RelalationContainsKeyContext) IsRelalationContainsKeyContext() {}

func NewRelalationContainsKeyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelalationContainsKeyContext {
	var p = new(RelalationContainsKeyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_relalationContainsKey

	return p
}

func (s *RelalationContainsKeyContext) GetParser() antlr.Parser { return s.parser }

func (s *RelalationContainsKeyContext) OBJECT_NAME() antlr.TerminalNode {
	return s.GetToken(CQLParserOBJECT_NAME, 0)
}

func (s *RelalationContainsKeyContext) Constant() IConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *RelalationContainsKeyContext) KwContains() IKwContainsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwContainsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwContainsContext)
}

func (s *RelalationContainsKeyContext) KwKey() IKwKeyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwKeyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwKeyContext)
}

func (s *RelalationContainsKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelalationContainsKeyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelalationContainsKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterRelalationContainsKey(s)
	}
}

func (s *RelalationContainsKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitRelalationContainsKey(s)
	}
}

func (p *CQLParser) RelalationContainsKey() (localctx IRelalationContainsKeyContext) {
	localctx = NewRelalationContainsKeyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, CQLParserRULE_relalationContainsKey)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1985)
		p.Match(CQLParserOBJECT_NAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

	{
		p.SetState(1986)
		p.KwContains()
	}
	{
		p.SetState(1987)
		p.KwKey()
	}

	{
		p.SetState(1989)
		p.Constant()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionCallContext is an interface to support dynamic dispatch.
type IFunctionCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OBJECT_NAME() antlr.TerminalNode
	LR_BRACKET() antlr.TerminalNode
	STAR() antlr.TerminalNode
	RR_BRACKET() antlr.TerminalNode
	FunctionArgs() IFunctionArgsContext
	K_UUID() antlr.TerminalNode

	// IsFunctionCallContext differentiates from other interfaces.
	IsFunctionCallContext()
}

type FunctionCallContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionCallContext() *FunctionCallContext {
	var p = new(FunctionCallContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_functionCall
	return p
}

func InitEmptyFunctionCallContext(p *FunctionCallContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_functionCall
}

func (*FunctionCallContext) IsFunctionCallContext() {}

func NewFunctionCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionCallContext {
	var p = new(FunctionCallContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_functionCall

	return p
}

func (s *FunctionCallContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionCallContext) OBJECT_NAME() antlr.TerminalNode {
	return s.GetToken(CQLParserOBJECT_NAME, 0)
}

func (s *FunctionCallContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(CQLParserLR_BRACKET, 0)
}

func (s *FunctionCallContext) STAR() antlr.TerminalNode {
	return s.GetToken(CQLParserSTAR, 0)
}

func (s *FunctionCallContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(CQLParserRR_BRACKET, 0)
}

func (s *FunctionCallContext) FunctionArgs() IFunctionArgsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionArgsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionArgsContext)
}

func (s *FunctionCallContext) K_UUID() antlr.TerminalNode {
	return s.GetToken(CQLParserK_UUID, 0)
}

func (s *FunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterFunctionCall(s)
	}
}

func (s *FunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitFunctionCall(s)
	}
}

func (p *CQLParser) FunctionCall() (localctx IFunctionCallContext) {
	localctx = NewFunctionCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, CQLParserRULE_functionCall)
	var _la int

	p.SetState(2004)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 167, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1991)
			p.Match(CQLParserOBJECT_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1992)
			p.Match(CQLParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1993)
			p.Match(CQLParserSTAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1994)
			p.Match(CQLParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1995)
			p.Match(CQLParserOBJECT_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1996)
			p.Match(CQLParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1998)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CQLParserK_FALSE || _la == CQLParserK_NULL || ((int64((_la-126)) & ^0x3f) == 0 && ((int64(1)<<(_la-126))&61297773249537) != 0) {
			{
				p.SetState(1997)
				p.FunctionArgs()
			}

		}
		{
			p.SetState(2000)
			p.Match(CQLParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2001)
			p.Match(CQLParserK_UUID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2002)
			p.Match(CQLParserLR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2003)
			p.Match(CQLParserRR_BRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionArgsContext is an interface to support dynamic dispatch.
type IFunctionArgsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllConstant() []IConstantContext
	Constant(i int) IConstantContext
	AllOBJECT_NAME() []antlr.TerminalNode
	OBJECT_NAME(i int) antlr.TerminalNode
	AllFunctionCall() []IFunctionCallContext
	FunctionCall(i int) IFunctionCallContext
	AllSyntaxComma() []ISyntaxCommaContext
	SyntaxComma(i int) ISyntaxCommaContext

	// IsFunctionArgsContext differentiates from other interfaces.
	IsFunctionArgsContext()
}

type FunctionArgsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionArgsContext() *FunctionArgsContext {
	var p = new(FunctionArgsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_functionArgs
	return p
}

func InitEmptyFunctionArgsContext(p *FunctionArgsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_functionArgs
}

func (*FunctionArgsContext) IsFunctionArgsContext() {}

func NewFunctionArgsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionArgsContext {
	var p = new(FunctionArgsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_functionArgs

	return p
}

func (s *FunctionArgsContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionArgsContext) AllConstant() []IConstantContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConstantContext); ok {
			len++
		}
	}

	tst := make([]IConstantContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConstantContext); ok {
			tst[i] = t.(IConstantContext)
			i++
		}
	}

	return tst
}

func (s *FunctionArgsContext) Constant(i int) IConstantContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *FunctionArgsContext) AllOBJECT_NAME() []antlr.TerminalNode {
	return s.GetTokens(CQLParserOBJECT_NAME)
}

func (s *FunctionArgsContext) OBJECT_NAME(i int) antlr.TerminalNode {
	return s.GetToken(CQLParserOBJECT_NAME, i)
}

func (s *FunctionArgsContext) AllFunctionCall() []IFunctionCallContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFunctionCallContext); ok {
			len++
		}
	}

	tst := make([]IFunctionCallContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFunctionCallContext); ok {
			tst[i] = t.(IFunctionCallContext)
			i++
		}
	}

	return tst
}

func (s *FunctionArgsContext) FunctionCall(i int) IFunctionCallContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *FunctionArgsContext) AllSyntaxComma() []ISyntaxCommaContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			len++
		}
	}

	tst := make([]ISyntaxCommaContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISyntaxCommaContext); ok {
			tst[i] = t.(ISyntaxCommaContext)
			i++
		}
	}

	return tst
}

func (s *FunctionArgsContext) SyntaxComma(i int) ISyntaxCommaContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxCommaContext)
}

func (s *FunctionArgsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionArgsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionArgsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterFunctionArgs(s)
	}
}

func (s *FunctionArgsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitFunctionArgs(s)
	}
}

func (p *CQLParser) FunctionArgs() (localctx IFunctionArgsContext) {
	localctx = NewFunctionArgsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, CQLParserRULE_functionArgs)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2009)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 168, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2006)
			p.Constant()
		}

	case 2:
		{
			p.SetState(2007)
			p.Match(CQLParserOBJECT_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		{
			p.SetState(2008)
			p.FunctionCall()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(2019)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CQLParserCOMMA {
		{
			p.SetState(2011)
			p.SyntaxComma()
		}
		p.SetState(2015)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 169, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(2012)
				p.Constant()
			}

		case 2:
			{
				p.SetState(2013)
				p.Match(CQLParserOBJECT_NAME)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 3:
			{
				p.SetState(2014)
				p.FunctionCall()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

		p.SetState(2021)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstantContext is an interface to support dynamic dispatch.
type IConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UUID() antlr.TerminalNode
	StringLiteral() IStringLiteralContext
	DecimalLiteral() IDecimalLiteralContext
	FloatLiteral() IFloatLiteralContext
	HexadecimalLiteral() IHexadecimalLiteralContext
	BooleanLiteral() IBooleanLiteralContext
	CodeBlock() ICodeBlockContext
	KwNull() IKwNullContext

	// IsConstantContext differentiates from other interfaces.
	IsConstantContext()
}

type ConstantContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstantContext() *ConstantContext {
	var p = new(ConstantContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_constant
	return p
}

func InitEmptyConstantContext(p *ConstantContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_constant
}

func (*ConstantContext) IsConstantContext() {}

func NewConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantContext {
	var p = new(ConstantContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_constant

	return p
}

func (s *ConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantContext) UUID() antlr.TerminalNode {
	return s.GetToken(CQLParserUUID, 0)
}

func (s *ConstantContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *ConstantContext) DecimalLiteral() IDecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *ConstantContext) FloatLiteral() IFloatLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFloatLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFloatLiteralContext)
}

func (s *ConstantContext) HexadecimalLiteral() IHexadecimalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHexadecimalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHexadecimalLiteralContext)
}

func (s *ConstantContext) BooleanLiteral() IBooleanLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanLiteralContext)
}

func (s *ConstantContext) CodeBlock() ICodeBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *ConstantContext) KwNull() IKwNullContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwNullContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwNullContext)
}

func (s *ConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterConstant(s)
	}
}

func (s *ConstantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitConstant(s)
	}
}

func (p *CQLParser) Constant() (localctx IConstantContext) {
	localctx = NewConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, CQLParserRULE_constant)
	p.SetState(2030)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 171, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2022)
			p.Match(CQLParserUUID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2023)
			p.StringLiteral()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2024)
			p.DecimalLiteral()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2025)
			p.FloatLiteral()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2026)
			p.HexadecimalLiteral()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2027)
			p.BooleanLiteral()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2028)
			p.CodeBlock()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2029)
			p.KwNull()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDecimalLiteralContext is an interface to support dynamic dispatch.
type IDecimalLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DECIMAL_LITERAL() antlr.TerminalNode

	// IsDecimalLiteralContext differentiates from other interfaces.
	IsDecimalLiteralContext()
}

type DecimalLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDecimalLiteralContext() *DecimalLiteralContext {
	var p = new(DecimalLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_decimalLiteral
	return p
}

func InitEmptyDecimalLiteralContext(p *DecimalLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_decimalLiteral
}

func (*DecimalLiteralContext) IsDecimalLiteralContext() {}

func NewDecimalLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecimalLiteralContext {
	var p = new(DecimalLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_decimalLiteral

	return p
}

func (s *DecimalLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *DecimalLiteralContext) DECIMAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(CQLParserDECIMAL_LITERAL, 0)
}

func (s *DecimalLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecimalLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DecimalLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterDecimalLiteral(s)
	}
}

func (s *DecimalLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitDecimalLiteral(s)
	}
}

func (p *CQLParser) DecimalLiteral() (localctx IDecimalLiteralContext) {
	localctx = NewDecimalLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 294, CQLParserRULE_decimalLiteral)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2032)
		p.Match(CQLParserDECIMAL_LITERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFloatLiteralContext is an interface to support dynamic dispatch.
type IFloatLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DECIMAL_LITERAL() antlr.TerminalNode
	FLOAT_LITERAL() antlr.TerminalNode

	// IsFloatLiteralContext differentiates from other interfaces.
	IsFloatLiteralContext()
}

type FloatLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFloatLiteralContext() *FloatLiteralContext {
	var p = new(FloatLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_floatLiteral
	return p
}

func InitEmptyFloatLiteralContext(p *FloatLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_floatLiteral
}

func (*FloatLiteralContext) IsFloatLiteralContext() {}

func NewFloatLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FloatLiteralContext {
	var p = new(FloatLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_floatLiteral

	return p
}

func (s *FloatLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *FloatLiteralContext) DECIMAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(CQLParserDECIMAL_LITERAL, 0)
}

func (s *FloatLiteralContext) FLOAT_LITERAL() antlr.TerminalNode {
	return s.GetToken(CQLParserFLOAT_LITERAL, 0)
}

func (s *FloatLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FloatLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FloatLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterFloatLiteral(s)
	}
}

func (s *FloatLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitFloatLiteral(s)
	}
}

func (p *CQLParser) FloatLiteral() (localctx IFloatLiteralContext) {
	localctx = NewFloatLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 296, CQLParserRULE_floatLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2034)
		_la = p.GetTokenStream().LA(1)

		if !(_la == CQLParserDECIMAL_LITERAL || _la == CQLParserFLOAT_LITERAL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringLiteralContext is an interface to support dynamic dispatch.
type IStringLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRING_LITERAL() antlr.TerminalNode

	// IsStringLiteralContext differentiates from other interfaces.
	IsStringLiteralContext()
}

type StringLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringLiteralContext() *StringLiteralContext {
	var p = new(StringLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_stringLiteral
	return p
}

func InitEmptyStringLiteralContext(p *StringLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_stringLiteral
}

func (*StringLiteralContext) IsStringLiteralContext() {}

func NewStringLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringLiteralContext {
	var p = new(StringLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_stringLiteral

	return p
}

func (s *StringLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *StringLiteralContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(CQLParserSTRING_LITERAL, 0)
}

func (s *StringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterStringLiteral(s)
	}
}

func (s *StringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitStringLiteral(s)
	}
}

func (p *CQLParser) StringLiteral() (localctx IStringLiteralContext) {
	localctx = NewStringLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 298, CQLParserRULE_stringLiteral)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2036)
		p.Match(CQLParserSTRING_LITERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBooleanLiteralContext is an interface to support dynamic dispatch.
type IBooleanLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_TRUE() antlr.TerminalNode
	K_FALSE() antlr.TerminalNode

	// IsBooleanLiteralContext differentiates from other interfaces.
	IsBooleanLiteralContext()
}

type BooleanLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanLiteralContext() *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_booleanLiteral
	return p
}

func InitEmptyBooleanLiteralContext(p *BooleanLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_booleanLiteral
}

func (*BooleanLiteralContext) IsBooleanLiteralContext() {}

func NewBooleanLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_booleanLiteral

	return p
}

func (s *BooleanLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanLiteralContext) K_TRUE() antlr.TerminalNode {
	return s.GetToken(CQLParserK_TRUE, 0)
}

func (s *BooleanLiteralContext) K_FALSE() antlr.TerminalNode {
	return s.GetToken(CQLParserK_FALSE, 0)
}

func (s *BooleanLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BooleanLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterBooleanLiteral(s)
	}
}

func (s *BooleanLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitBooleanLiteral(s)
	}
}

func (p *CQLParser) BooleanLiteral() (localctx IBooleanLiteralContext) {
	localctx = NewBooleanLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 300, CQLParserRULE_booleanLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2038)
		_la = p.GetTokenStream().LA(1)

		if !(_la == CQLParserK_FALSE || _la == CQLParserK_TRUE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHexadecimalLiteralContext is an interface to support dynamic dispatch.
type IHexadecimalLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HEXADECIMAL_LITERAL() antlr.TerminalNode

	// IsHexadecimalLiteralContext differentiates from other interfaces.
	IsHexadecimalLiteralContext()
}

type HexadecimalLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHexadecimalLiteralContext() *HexadecimalLiteralContext {
	var p = new(HexadecimalLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_hexadecimalLiteral
	return p
}

func InitEmptyHexadecimalLiteralContext(p *HexadecimalLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_hexadecimalLiteral
}

func (*HexadecimalLiteralContext) IsHexadecimalLiteralContext() {}

func NewHexadecimalLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HexadecimalLiteralContext {
	var p = new(HexadecimalLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_hexadecimalLiteral

	return p
}

func (s *HexadecimalLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *HexadecimalLiteralContext) HEXADECIMAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(CQLParserHEXADECIMAL_LITERAL, 0)
}

func (s *HexadecimalLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HexadecimalLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HexadecimalLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterHexadecimalLiteral(s)
	}
}

func (s *HexadecimalLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitHexadecimalLiteral(s)
	}
}

func (p *CQLParser) HexadecimalLiteral() (localctx IHexadecimalLiteralContext) {
	localctx = NewHexadecimalLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 302, CQLParserRULE_hexadecimalLiteral)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2040)
		p.Match(CQLParserHEXADECIMAL_LITERAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKeyspaceContext is an interface to support dynamic dispatch.
type IKeyspaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OBJECT_NAME() antlr.TerminalNode
	AllDQUOTE() []antlr.TerminalNode
	DQUOTE(i int) antlr.TerminalNode

	// IsKeyspaceContext differentiates from other interfaces.
	IsKeyspaceContext()
}

type KeyspaceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyspaceContext() *KeyspaceContext {
	var p = new(KeyspaceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_keyspace
	return p
}

func InitEmptyKeyspaceContext(p *KeyspaceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_keyspace
}

func (*KeyspaceContext) IsKeyspaceContext() {}

func NewKeyspaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeyspaceContext {
	var p = new(KeyspaceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_keyspace

	return p
}

func (s *KeyspaceContext) GetParser() antlr.Parser { return s.parser }

func (s *KeyspaceContext) OBJECT_NAME() antlr.TerminalNode {
	return s.GetToken(CQLParserOBJECT_NAME, 0)
}

func (s *KeyspaceContext) AllDQUOTE() []antlr.TerminalNode {
	return s.GetTokens(CQLParserDQUOTE)
}

func (s *KeyspaceContext) DQUOTE(i int) antlr.TerminalNode {
	return s.GetToken(CQLParserDQUOTE, i)
}

func (s *KeyspaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeyspaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeyspaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKeyspace(s)
	}
}

func (s *KeyspaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKeyspace(s)
	}
}

func (p *CQLParser) Keyspace() (localctx IKeyspaceContext) {
	localctx = NewKeyspaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 304, CQLParserRULE_keyspace)
	p.SetState(2046)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CQLParserOBJECT_NAME:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2042)
			p.Match(CQLParserOBJECT_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case CQLParserDQUOTE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2043)
			p.Match(CQLParserDQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2044)
			p.Match(CQLParserOBJECT_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2045)
			p.Match(CQLParserDQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableContext is an interface to support dynamic dispatch.
type ITableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OBJECT_NAME() antlr.TerminalNode
	AllDQUOTE() []antlr.TerminalNode
	DQUOTE(i int) antlr.TerminalNode

	// IsTableContext differentiates from other interfaces.
	IsTableContext()
}

type TableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableContext() *TableContext {
	var p = new(TableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_table
	return p
}

func InitEmptyTableContext(p *TableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_table
}

func (*TableContext) IsTableContext() {}

func NewTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableContext {
	var p = new(TableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_table

	return p
}

func (s *TableContext) GetParser() antlr.Parser { return s.parser }

func (s *TableContext) OBJECT_NAME() antlr.TerminalNode {
	return s.GetToken(CQLParserOBJECT_NAME, 0)
}

func (s *TableContext) AllDQUOTE() []antlr.TerminalNode {
	return s.GetTokens(CQLParserDQUOTE)
}

func (s *TableContext) DQUOTE(i int) antlr.TerminalNode {
	return s.GetToken(CQLParserDQUOTE, i)
}

func (s *TableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterTable(s)
	}
}

func (s *TableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitTable(s)
	}
}

func (p *CQLParser) Table() (localctx ITableContext) {
	localctx = NewTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 306, CQLParserRULE_table)
	p.SetState(2052)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CQLParserOBJECT_NAME:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2048)
			p.Match(CQLParserOBJECT_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case CQLParserDQUOTE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2049)
			p.Match(CQLParserDQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2050)
			p.Match(CQLParserOBJECT_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2051)
			p.Match(CQLParserDQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnContext is an interface to support dynamic dispatch.
type IColumnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OBJECT_NAME() antlr.TerminalNode
	AllDQUOTE() []antlr.TerminalNode
	DQUOTE(i int) antlr.TerminalNode

	// IsColumnContext differentiates from other interfaces.
	IsColumnContext()
}

type ColumnContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnContext() *ColumnContext {
	var p = new(ColumnContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_column
	return p
}

func InitEmptyColumnContext(p *ColumnContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_column
}

func (*ColumnContext) IsColumnContext() {}

func NewColumnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnContext {
	var p = new(ColumnContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_column

	return p
}

func (s *ColumnContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnContext) OBJECT_NAME() antlr.TerminalNode {
	return s.GetToken(CQLParserOBJECT_NAME, 0)
}

func (s *ColumnContext) AllDQUOTE() []antlr.TerminalNode {
	return s.GetTokens(CQLParserDQUOTE)
}

func (s *ColumnContext) DQUOTE(i int) antlr.TerminalNode {
	return s.GetToken(CQLParserDQUOTE, i)
}

func (s *ColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterColumn(s)
	}
}

func (s *ColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitColumn(s)
	}
}

func (p *CQLParser) Column() (localctx IColumnContext) {
	localctx = NewColumnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 308, CQLParserRULE_column)
	p.SetState(2058)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CQLParserOBJECT_NAME:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2054)
			p.Match(CQLParserOBJECT_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case CQLParserDQUOTE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2055)
			p.Match(CQLParserDQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2056)
			p.Match(CQLParserOBJECT_NAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2057)
			p.Match(CQLParserDQUOTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataTypeContext is an interface to support dynamic dispatch.
type IDataTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DataTypeName() IDataTypeNameContext
	DataTypeDefinition() IDataTypeDefinitionContext

	// IsDataTypeContext differentiates from other interfaces.
	IsDataTypeContext()
}

type DataTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataTypeContext() *DataTypeContext {
	var p = new(DataTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_dataType
	return p
}

func InitEmptyDataTypeContext(p *DataTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_dataType
}

func (*DataTypeContext) IsDataTypeContext() {}

func NewDataTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataTypeContext {
	var p = new(DataTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_dataType

	return p
}

func (s *DataTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *DataTypeContext) DataTypeName() IDataTypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeNameContext)
}

func (s *DataTypeContext) DataTypeDefinition() IDataTypeDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeDefinitionContext)
}

func (s *DataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterDataType(s)
	}
}

func (s *DataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitDataType(s)
	}
}

func (p *CQLParser) DataType() (localctx IDataTypeContext) {
	localctx = NewDataTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 310, CQLParserRULE_dataType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2060)
		p.DataTypeName()
	}
	p.SetState(2062)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CQLParserOPERATOR_LT {
		{
			p.SetState(2061)
			p.DataTypeDefinition()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataTypeNameContext is an interface to support dynamic dispatch.
type IDataTypeNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OBJECT_NAME() antlr.TerminalNode
	K_TIMESTAMP() antlr.TerminalNode
	K_SET() antlr.TerminalNode
	K_ASCII() antlr.TerminalNode
	K_BIGINT() antlr.TerminalNode
	K_BLOB() antlr.TerminalNode
	K_BOOLEAN() antlr.TerminalNode
	K_COUNTER() antlr.TerminalNode
	K_DATE() antlr.TerminalNode
	K_DECIMAL() antlr.TerminalNode
	K_DOUBLE() antlr.TerminalNode
	K_FLOAT() antlr.TerminalNode
	K_FROZEN() antlr.TerminalNode
	K_INET() antlr.TerminalNode
	K_INT() antlr.TerminalNode
	K_LIST() antlr.TerminalNode
	K_MAP() antlr.TerminalNode
	K_SMALLINT() antlr.TerminalNode
	K_TEXT() antlr.TerminalNode
	K_TIME() antlr.TerminalNode
	K_TIMEUUID() antlr.TerminalNode
	K_TINYINT() antlr.TerminalNode
	K_TUPLE() antlr.TerminalNode
	K_VARCHAR() antlr.TerminalNode
	K_VARINT() antlr.TerminalNode
	K_UUID() antlr.TerminalNode

	// IsDataTypeNameContext differentiates from other interfaces.
	IsDataTypeNameContext()
}

type DataTypeNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataTypeNameContext() *DataTypeNameContext {
	var p = new(DataTypeNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_dataTypeName
	return p
}

func InitEmptyDataTypeNameContext(p *DataTypeNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_dataTypeName
}

func (*DataTypeNameContext) IsDataTypeNameContext() {}

func NewDataTypeNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataTypeNameContext {
	var p = new(DataTypeNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_dataTypeName

	return p
}

func (s *DataTypeNameContext) GetParser() antlr.Parser { return s.parser }

func (s *DataTypeNameContext) OBJECT_NAME() antlr.TerminalNode {
	return s.GetToken(CQLParserOBJECT_NAME, 0)
}

func (s *DataTypeNameContext) K_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(CQLParserK_TIMESTAMP, 0)
}

func (s *DataTypeNameContext) K_SET() antlr.TerminalNode {
	return s.GetToken(CQLParserK_SET, 0)
}

func (s *DataTypeNameContext) K_ASCII() antlr.TerminalNode {
	return s.GetToken(CQLParserK_ASCII, 0)
}

func (s *DataTypeNameContext) K_BIGINT() antlr.TerminalNode {
	return s.GetToken(CQLParserK_BIGINT, 0)
}

func (s *DataTypeNameContext) K_BLOB() antlr.TerminalNode {
	return s.GetToken(CQLParserK_BLOB, 0)
}

func (s *DataTypeNameContext) K_BOOLEAN() antlr.TerminalNode {
	return s.GetToken(CQLParserK_BOOLEAN, 0)
}

func (s *DataTypeNameContext) K_COUNTER() antlr.TerminalNode {
	return s.GetToken(CQLParserK_COUNTER, 0)
}

func (s *DataTypeNameContext) K_DATE() antlr.TerminalNode {
	return s.GetToken(CQLParserK_DATE, 0)
}

func (s *DataTypeNameContext) K_DECIMAL() antlr.TerminalNode {
	return s.GetToken(CQLParserK_DECIMAL, 0)
}

func (s *DataTypeNameContext) K_DOUBLE() antlr.TerminalNode {
	return s.GetToken(CQLParserK_DOUBLE, 0)
}

func (s *DataTypeNameContext) K_FLOAT() antlr.TerminalNode {
	return s.GetToken(CQLParserK_FLOAT, 0)
}

func (s *DataTypeNameContext) K_FROZEN() antlr.TerminalNode {
	return s.GetToken(CQLParserK_FROZEN, 0)
}

func (s *DataTypeNameContext) K_INET() antlr.TerminalNode {
	return s.GetToken(CQLParserK_INET, 0)
}

func (s *DataTypeNameContext) K_INT() antlr.TerminalNode {
	return s.GetToken(CQLParserK_INT, 0)
}

func (s *DataTypeNameContext) K_LIST() antlr.TerminalNode {
	return s.GetToken(CQLParserK_LIST, 0)
}

func (s *DataTypeNameContext) K_MAP() antlr.TerminalNode {
	return s.GetToken(CQLParserK_MAP, 0)
}

func (s *DataTypeNameContext) K_SMALLINT() antlr.TerminalNode {
	return s.GetToken(CQLParserK_SMALLINT, 0)
}

func (s *DataTypeNameContext) K_TEXT() antlr.TerminalNode {
	return s.GetToken(CQLParserK_TEXT, 0)
}

func (s *DataTypeNameContext) K_TIME() antlr.TerminalNode {
	return s.GetToken(CQLParserK_TIME, 0)
}

func (s *DataTypeNameContext) K_TIMEUUID() antlr.TerminalNode {
	return s.GetToken(CQLParserK_TIMEUUID, 0)
}

func (s *DataTypeNameContext) K_TINYINT() antlr.TerminalNode {
	return s.GetToken(CQLParserK_TINYINT, 0)
}

func (s *DataTypeNameContext) K_TUPLE() antlr.TerminalNode {
	return s.GetToken(CQLParserK_TUPLE, 0)
}

func (s *DataTypeNameContext) K_VARCHAR() antlr.TerminalNode {
	return s.GetToken(CQLParserK_VARCHAR, 0)
}

func (s *DataTypeNameContext) K_VARINT() antlr.TerminalNode {
	return s.GetToken(CQLParserK_VARINT, 0)
}

func (s *DataTypeNameContext) K_UUID() antlr.TerminalNode {
	return s.GetToken(CQLParserK_UUID, 0)
}

func (s *DataTypeNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataTypeNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataTypeNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterDataTypeName(s)
	}
}

func (s *DataTypeNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitDataTypeName(s)
	}
}

func (p *CQLParser) DataTypeName() (localctx IDataTypeNameContext) {
	localctx = NewDataTypeNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 312, CQLParserRULE_dataTypeName)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2064)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-114)) & ^0x3f) == 0 && ((int64(1)<<(_la-114))&73183493680529665) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataTypeDefinitionContext is an interface to support dynamic dispatch.
type IDataTypeDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SyntaxBracketLa() ISyntaxBracketLaContext
	AllDataTypeName() []IDataTypeNameContext
	DataTypeName(i int) IDataTypeNameContext
	SyntaxBracketRa() ISyntaxBracketRaContext
	AllSyntaxComma() []ISyntaxCommaContext
	SyntaxComma(i int) ISyntaxCommaContext

	// IsDataTypeDefinitionContext differentiates from other interfaces.
	IsDataTypeDefinitionContext()
}

type DataTypeDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataTypeDefinitionContext() *DataTypeDefinitionContext {
	var p = new(DataTypeDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_dataTypeDefinition
	return p
}

func InitEmptyDataTypeDefinitionContext(p *DataTypeDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_dataTypeDefinition
}

func (*DataTypeDefinitionContext) IsDataTypeDefinitionContext() {}

func NewDataTypeDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataTypeDefinitionContext {
	var p = new(DataTypeDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_dataTypeDefinition

	return p
}

func (s *DataTypeDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *DataTypeDefinitionContext) SyntaxBracketLa() ISyntaxBracketLaContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketLaContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketLaContext)
}

func (s *DataTypeDefinitionContext) AllDataTypeName() []IDataTypeNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataTypeNameContext); ok {
			len++
		}
	}

	tst := make([]IDataTypeNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataTypeNameContext); ok {
			tst[i] = t.(IDataTypeNameContext)
			i++
		}
	}

	return tst
}

func (s *DataTypeDefinitionContext) DataTypeName(i int) IDataTypeNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeNameContext)
}

func (s *DataTypeDefinitionContext) SyntaxBracketRa() ISyntaxBracketRaContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxBracketRaContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxBracketRaContext)
}

func (s *DataTypeDefinitionContext) AllSyntaxComma() []ISyntaxCommaContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			len++
		}
	}

	tst := make([]ISyntaxCommaContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISyntaxCommaContext); ok {
			tst[i] = t.(ISyntaxCommaContext)
			i++
		}
	}

	return tst
}

func (s *DataTypeDefinitionContext) SyntaxComma(i int) ISyntaxCommaContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyntaxCommaContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyntaxCommaContext)
}

func (s *DataTypeDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataTypeDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataTypeDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterDataTypeDefinition(s)
	}
}

func (s *DataTypeDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitDataTypeDefinition(s)
	}
}

func (p *CQLParser) DataTypeDefinition() (localctx IDataTypeDefinitionContext) {
	localctx = NewDataTypeDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 314, CQLParserRULE_dataTypeDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2066)
		p.SyntaxBracketLa()
	}
	{
		p.SetState(2067)
		p.DataTypeName()
	}
	p.SetState(2073)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CQLParserCOMMA {
		{
			p.SetState(2068)
			p.SyntaxComma()
		}
		{
			p.SetState(2069)
			p.DataTypeName()
		}

		p.SetState(2075)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2076)
		p.SyntaxBracketRa()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOrderDirectionContext is an interface to support dynamic dispatch.
type IOrderDirectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KwAsc() IKwAscContext
	KwDesc() IKwDescContext

	// IsOrderDirectionContext differentiates from other interfaces.
	IsOrderDirectionContext()
}

type OrderDirectionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrderDirectionContext() *OrderDirectionContext {
	var p = new(OrderDirectionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_orderDirection
	return p
}

func InitEmptyOrderDirectionContext(p *OrderDirectionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_orderDirection
}

func (*OrderDirectionContext) IsOrderDirectionContext() {}

func NewOrderDirectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrderDirectionContext {
	var p = new(OrderDirectionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_orderDirection

	return p
}

func (s *OrderDirectionContext) GetParser() antlr.Parser { return s.parser }

func (s *OrderDirectionContext) KwAsc() IKwAscContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwAscContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwAscContext)
}

func (s *OrderDirectionContext) KwDesc() IKwDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKwDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKwDescContext)
}

func (s *OrderDirectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrderDirectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrderDirectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterOrderDirection(s)
	}
}

func (s *OrderDirectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitOrderDirection(s)
	}
}

func (p *CQLParser) OrderDirection() (localctx IOrderDirectionContext) {
	localctx = NewOrderDirectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 316, CQLParserRULE_orderDirection)
	p.SetState(2080)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CQLParserK_ASC:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2078)
			p.KwAsc()
		}

	case CQLParserK_DESC:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2079)
			p.KwDesc()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRoleContext is an interface to support dynamic dispatch.
type IRoleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OBJECT_NAME() antlr.TerminalNode

	// IsRoleContext differentiates from other interfaces.
	IsRoleContext()
}

type RoleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoleContext() *RoleContext {
	var p = new(RoleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_role
	return p
}

func InitEmptyRoleContext(p *RoleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_role
}

func (*RoleContext) IsRoleContext() {}

func NewRoleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoleContext {
	var p = new(RoleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_role

	return p
}

func (s *RoleContext) GetParser() antlr.Parser { return s.parser }

func (s *RoleContext) OBJECT_NAME() antlr.TerminalNode {
	return s.GetToken(CQLParserOBJECT_NAME, 0)
}

func (s *RoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RoleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterRole(s)
	}
}

func (s *RoleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitRole(s)
	}
}

func (p *CQLParser) Role() (localctx IRoleContext) {
	localctx = NewRoleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 318, CQLParserRULE_role)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2082)
		p.Match(CQLParserOBJECT_NAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITriggerContext is an interface to support dynamic dispatch.
type ITriggerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OBJECT_NAME() antlr.TerminalNode

	// IsTriggerContext differentiates from other interfaces.
	IsTriggerContext()
}

type TriggerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTriggerContext() *TriggerContext {
	var p = new(TriggerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_trigger
	return p
}

func InitEmptyTriggerContext(p *TriggerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_trigger
}

func (*TriggerContext) IsTriggerContext() {}

func NewTriggerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TriggerContext {
	var p = new(TriggerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_trigger

	return p
}

func (s *TriggerContext) GetParser() antlr.Parser { return s.parser }

func (s *TriggerContext) OBJECT_NAME() antlr.TerminalNode {
	return s.GetToken(CQLParserOBJECT_NAME, 0)
}

func (s *TriggerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TriggerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TriggerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterTrigger(s)
	}
}

func (s *TriggerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitTrigger(s)
	}
}

func (p *CQLParser) Trigger() (localctx ITriggerContext) {
	localctx = NewTriggerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 320, CQLParserRULE_trigger)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2084)
		p.Match(CQLParserOBJECT_NAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITriggerClassContext is an interface to support dynamic dispatch.
type ITriggerClassContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StringLiteral() IStringLiteralContext

	// IsTriggerClassContext differentiates from other interfaces.
	IsTriggerClassContext()
}

type TriggerClassContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTriggerClassContext() *TriggerClassContext {
	var p = new(TriggerClassContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_triggerClass
	return p
}

func InitEmptyTriggerClassContext(p *TriggerClassContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_triggerClass
}

func (*TriggerClassContext) IsTriggerClassContext() {}

func NewTriggerClassContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TriggerClassContext {
	var p = new(TriggerClassContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_triggerClass

	return p
}

func (s *TriggerClassContext) GetParser() antlr.Parser { return s.parser }

func (s *TriggerClassContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *TriggerClassContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TriggerClassContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TriggerClassContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterTriggerClass(s)
	}
}

func (s *TriggerClassContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitTriggerClass(s)
	}
}

func (p *CQLParser) TriggerClass() (localctx ITriggerClassContext) {
	localctx = NewTriggerClassContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 322, CQLParserRULE_triggerClass)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2086)
		p.StringLiteral()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMaterializedViewContext is an interface to support dynamic dispatch.
type IMaterializedViewContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OBJECT_NAME() antlr.TerminalNode

	// IsMaterializedViewContext differentiates from other interfaces.
	IsMaterializedViewContext()
}

type MaterializedViewContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMaterializedViewContext() *MaterializedViewContext {
	var p = new(MaterializedViewContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_materializedView
	return p
}

func InitEmptyMaterializedViewContext(p *MaterializedViewContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_materializedView
}

func (*MaterializedViewContext) IsMaterializedViewContext() {}

func NewMaterializedViewContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MaterializedViewContext {
	var p = new(MaterializedViewContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_materializedView

	return p
}

func (s *MaterializedViewContext) GetParser() antlr.Parser { return s.parser }

func (s *MaterializedViewContext) OBJECT_NAME() antlr.TerminalNode {
	return s.GetToken(CQLParserOBJECT_NAME, 0)
}

func (s *MaterializedViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MaterializedViewContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MaterializedViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterMaterializedView(s)
	}
}

func (s *MaterializedViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitMaterializedView(s)
	}
}

func (p *CQLParser) MaterializedView() (localctx IMaterializedViewContext) {
	localctx = NewMaterializedViewContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 324, CQLParserRULE_materializedView)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2088)
		p.Match(CQLParserOBJECT_NAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IType_Context is an interface to support dynamic dispatch.
type IType_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OBJECT_NAME() antlr.TerminalNode

	// IsType_Context differentiates from other interfaces.
	IsType_Context()
}

type Type_Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_Context() *Type_Context {
	var p = new(Type_Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_type_
	return p
}

func InitEmptyType_Context(p *Type_Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_type_
}

func (*Type_Context) IsType_Context() {}

func NewType_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_Context {
	var p = new(Type_Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_type_

	return p
}

func (s *Type_Context) GetParser() antlr.Parser { return s.parser }

func (s *Type_Context) OBJECT_NAME() antlr.TerminalNode {
	return s.GetToken(CQLParserOBJECT_NAME, 0)
}

func (s *Type_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterType_(s)
	}
}

func (s *Type_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitType_(s)
	}
}

func (p *CQLParser) Type_() (localctx IType_Context) {
	localctx = NewType_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 326, CQLParserRULE_type_)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2090)
		p.Match(CQLParserOBJECT_NAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAggregateContext is an interface to support dynamic dispatch.
type IAggregateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OBJECT_NAME() antlr.TerminalNode

	// IsAggregateContext differentiates from other interfaces.
	IsAggregateContext()
}

type AggregateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAggregateContext() *AggregateContext {
	var p = new(AggregateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_aggregate
	return p
}

func InitEmptyAggregateContext(p *AggregateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_aggregate
}

func (*AggregateContext) IsAggregateContext() {}

func NewAggregateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AggregateContext {
	var p = new(AggregateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_aggregate

	return p
}

func (s *AggregateContext) GetParser() antlr.Parser { return s.parser }

func (s *AggregateContext) OBJECT_NAME() antlr.TerminalNode {
	return s.GetToken(CQLParserOBJECT_NAME, 0)
}

func (s *AggregateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AggregateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AggregateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterAggregate(s)
	}
}

func (s *AggregateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitAggregate(s)
	}
}

func (p *CQLParser) Aggregate() (localctx IAggregateContext) {
	localctx = NewAggregateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 328, CQLParserRULE_aggregate)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2092)
		p.Match(CQLParserOBJECT_NAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunction_Context is an interface to support dynamic dispatch.
type IFunction_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OBJECT_NAME() antlr.TerminalNode

	// IsFunction_Context differentiates from other interfaces.
	IsFunction_Context()
}

type Function_Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_Context() *Function_Context {
	var p = new(Function_Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_function_
	return p
}

func InitEmptyFunction_Context(p *Function_Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_function_
}

func (*Function_Context) IsFunction_Context() {}

func NewFunction_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_Context {
	var p = new(Function_Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_function_

	return p
}

func (s *Function_Context) GetParser() antlr.Parser { return s.parser }

func (s *Function_Context) OBJECT_NAME() antlr.TerminalNode {
	return s.GetToken(CQLParserOBJECT_NAME, 0)
}

func (s *Function_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterFunction_(s)
	}
}

func (s *Function_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitFunction_(s)
	}
}

func (p *CQLParser) Function_() (localctx IFunction_Context) {
	localctx = NewFunction_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 330, CQLParserRULE_function_)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2094)
		p.Match(CQLParserOBJECT_NAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILanguageContext is an interface to support dynamic dispatch.
type ILanguageContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OBJECT_NAME() antlr.TerminalNode

	// IsLanguageContext differentiates from other interfaces.
	IsLanguageContext()
}

type LanguageContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLanguageContext() *LanguageContext {
	var p = new(LanguageContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_language
	return p
}

func InitEmptyLanguageContext(p *LanguageContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_language
}

func (*LanguageContext) IsLanguageContext() {}

func NewLanguageContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LanguageContext {
	var p = new(LanguageContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_language

	return p
}

func (s *LanguageContext) GetParser() antlr.Parser { return s.parser }

func (s *LanguageContext) OBJECT_NAME() antlr.TerminalNode {
	return s.GetToken(CQLParserOBJECT_NAME, 0)
}

func (s *LanguageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LanguageContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LanguageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterLanguage(s)
	}
}

func (s *LanguageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitLanguage(s)
	}
}

func (p *CQLParser) Language() (localctx ILanguageContext) {
	localctx = NewLanguageContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 332, CQLParserRULE_language)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2096)
		p.Match(CQLParserOBJECT_NAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUserContext is an interface to support dynamic dispatch.
type IUserContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OBJECT_NAME() antlr.TerminalNode

	// IsUserContext differentiates from other interfaces.
	IsUserContext()
}

type UserContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUserContext() *UserContext {
	var p = new(UserContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_user
	return p
}

func InitEmptyUserContext(p *UserContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_user
}

func (*UserContext) IsUserContext() {}

func NewUserContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserContext {
	var p = new(UserContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_user

	return p
}

func (s *UserContext) GetParser() antlr.Parser { return s.parser }

func (s *UserContext) OBJECT_NAME() antlr.TerminalNode {
	return s.GetToken(CQLParserOBJECT_NAME, 0)
}

func (s *UserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterUser(s)
	}
}

func (s *UserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitUser(s)
	}
}

func (p *CQLParser) User() (localctx IUserContext) {
	localctx = NewUserContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 334, CQLParserRULE_user)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2098)
		p.Match(CQLParserOBJECT_NAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPasswordContext is an interface to support dynamic dispatch.
type IPasswordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StringLiteral() IStringLiteralContext

	// IsPasswordContext differentiates from other interfaces.
	IsPasswordContext()
}

type PasswordContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPasswordContext() *PasswordContext {
	var p = new(PasswordContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_password
	return p
}

func InitEmptyPasswordContext(p *PasswordContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_password
}

func (*PasswordContext) IsPasswordContext() {}

func NewPasswordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PasswordContext {
	var p = new(PasswordContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_password

	return p
}

func (s *PasswordContext) GetParser() antlr.Parser { return s.parser }

func (s *PasswordContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *PasswordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PasswordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PasswordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterPassword(s)
	}
}

func (s *PasswordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitPassword(s)
	}
}

func (p *CQLParser) Password() (localctx IPasswordContext) {
	localctx = NewPasswordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 336, CQLParserRULE_password)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2100)
		p.StringLiteral()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHashKeyContext is an interface to support dynamic dispatch.
type IHashKeyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OBJECT_NAME() antlr.TerminalNode

	// IsHashKeyContext differentiates from other interfaces.
	IsHashKeyContext()
}

type HashKeyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHashKeyContext() *HashKeyContext {
	var p = new(HashKeyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_hashKey
	return p
}

func InitEmptyHashKeyContext(p *HashKeyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_hashKey
}

func (*HashKeyContext) IsHashKeyContext() {}

func NewHashKeyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HashKeyContext {
	var p = new(HashKeyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_hashKey

	return p
}

func (s *HashKeyContext) GetParser() antlr.Parser { return s.parser }

func (s *HashKeyContext) OBJECT_NAME() antlr.TerminalNode {
	return s.GetToken(CQLParserOBJECT_NAME, 0)
}

func (s *HashKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HashKeyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HashKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterHashKey(s)
	}
}

func (s *HashKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitHashKey(s)
	}
}

func (p *CQLParser) HashKey() (localctx IHashKeyContext) {
	localctx = NewHashKeyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 338, CQLParserRULE_hashKey)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2102)
		p.Match(CQLParserOBJECT_NAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParamContext is an interface to support dynamic dispatch.
type IParamContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ParamName() IParamNameContext
	DataType() IDataTypeContext

	// IsParamContext differentiates from other interfaces.
	IsParamContext()
}

type ParamContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParamContext() *ParamContext {
	var p = new(ParamContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_param
	return p
}

func InitEmptyParamContext(p *ParamContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_param
}

func (*ParamContext) IsParamContext() {}

func NewParamContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParamContext {
	var p = new(ParamContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_param

	return p
}

func (s *ParamContext) GetParser() antlr.Parser { return s.parser }

func (s *ParamContext) ParamName() IParamNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParamNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParamNameContext)
}

func (s *ParamContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *ParamContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParamContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParamContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterParam(s)
	}
}

func (s *ParamContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitParam(s)
	}
}

func (p *CQLParser) Param() (localctx IParamContext) {
	localctx = NewParamContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 340, CQLParserRULE_param)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2104)
		p.ParamName()
	}
	{
		p.SetState(2105)
		p.DataType()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParamNameContext is an interface to support dynamic dispatch.
type IParamNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OBJECT_NAME() antlr.TerminalNode
	K_INPUT() antlr.TerminalNode

	// IsParamNameContext differentiates from other interfaces.
	IsParamNameContext()
}

type ParamNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParamNameContext() *ParamNameContext {
	var p = new(ParamNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_paramName
	return p
}

func InitEmptyParamNameContext(p *ParamNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_paramName
}

func (*ParamNameContext) IsParamNameContext() {}

func NewParamNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParamNameContext {
	var p = new(ParamNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_paramName

	return p
}

func (s *ParamNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ParamNameContext) OBJECT_NAME() antlr.TerminalNode {
	return s.GetToken(CQLParserOBJECT_NAME, 0)
}

func (s *ParamNameContext) K_INPUT() antlr.TerminalNode {
	return s.GetToken(CQLParserK_INPUT, 0)
}

func (s *ParamNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParamNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParamNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterParamName(s)
	}
}

func (s *ParamNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitParamName(s)
	}
}

func (p *CQLParser) ParamName() (localctx IParamNameContext) {
	localctx = NewParamNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 342, CQLParserRULE_paramName)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2107)
		_la = p.GetTokenStream().LA(1)

		if !(_la == CQLParserK_INPUT || _la == CQLParserOBJECT_NAME) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwAddContext is an interface to support dynamic dispatch.
type IKwAddContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_ADD() antlr.TerminalNode

	// IsKwAddContext differentiates from other interfaces.
	IsKwAddContext()
}

type KwAddContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwAddContext() *KwAddContext {
	var p = new(KwAddContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwAdd
	return p
}

func InitEmptyKwAddContext(p *KwAddContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwAdd
}

func (*KwAddContext) IsKwAddContext() {}

func NewKwAddContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwAddContext {
	var p = new(KwAddContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwAdd

	return p
}

func (s *KwAddContext) GetParser() antlr.Parser { return s.parser }

func (s *KwAddContext) K_ADD() antlr.TerminalNode {
	return s.GetToken(CQLParserK_ADD, 0)
}

func (s *KwAddContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwAddContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwAddContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwAdd(s)
	}
}

func (s *KwAddContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwAdd(s)
	}
}

func (p *CQLParser) KwAdd() (localctx IKwAddContext) {
	localctx = NewKwAddContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 344, CQLParserRULE_kwAdd)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2109)
		p.Match(CQLParserK_ADD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwAggregateContext is an interface to support dynamic dispatch.
type IKwAggregateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_AGGREGATE() antlr.TerminalNode

	// IsKwAggregateContext differentiates from other interfaces.
	IsKwAggregateContext()
}

type KwAggregateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwAggregateContext() *KwAggregateContext {
	var p = new(KwAggregateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwAggregate
	return p
}

func InitEmptyKwAggregateContext(p *KwAggregateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwAggregate
}

func (*KwAggregateContext) IsKwAggregateContext() {}

func NewKwAggregateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwAggregateContext {
	var p = new(KwAggregateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwAggregate

	return p
}

func (s *KwAggregateContext) GetParser() antlr.Parser { return s.parser }

func (s *KwAggregateContext) K_AGGREGATE() antlr.TerminalNode {
	return s.GetToken(CQLParserK_AGGREGATE, 0)
}

func (s *KwAggregateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwAggregateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwAggregateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwAggregate(s)
	}
}

func (s *KwAggregateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwAggregate(s)
	}
}

func (p *CQLParser) KwAggregate() (localctx IKwAggregateContext) {
	localctx = NewKwAggregateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 346, CQLParserRULE_kwAggregate)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2111)
		p.Match(CQLParserK_AGGREGATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwAllContext is an interface to support dynamic dispatch.
type IKwAllContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_ALL() antlr.TerminalNode

	// IsKwAllContext differentiates from other interfaces.
	IsKwAllContext()
}

type KwAllContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwAllContext() *KwAllContext {
	var p = new(KwAllContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwAll
	return p
}

func InitEmptyKwAllContext(p *KwAllContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwAll
}

func (*KwAllContext) IsKwAllContext() {}

func NewKwAllContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwAllContext {
	var p = new(KwAllContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwAll

	return p
}

func (s *KwAllContext) GetParser() antlr.Parser { return s.parser }

func (s *KwAllContext) K_ALL() antlr.TerminalNode {
	return s.GetToken(CQLParserK_ALL, 0)
}

func (s *KwAllContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwAllContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwAllContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwAll(s)
	}
}

func (s *KwAllContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwAll(s)
	}
}

func (p *CQLParser) KwAll() (localctx IKwAllContext) {
	localctx = NewKwAllContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 348, CQLParserRULE_kwAll)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2113)
		p.Match(CQLParserK_ALL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwAllPermissionsContext is an interface to support dynamic dispatch.
type IKwAllPermissionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_ALL() antlr.TerminalNode
	K_PERMISSIONS() antlr.TerminalNode

	// IsKwAllPermissionsContext differentiates from other interfaces.
	IsKwAllPermissionsContext()
}

type KwAllPermissionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwAllPermissionsContext() *KwAllPermissionsContext {
	var p = new(KwAllPermissionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwAllPermissions
	return p
}

func InitEmptyKwAllPermissionsContext(p *KwAllPermissionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwAllPermissions
}

func (*KwAllPermissionsContext) IsKwAllPermissionsContext() {}

func NewKwAllPermissionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwAllPermissionsContext {
	var p = new(KwAllPermissionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwAllPermissions

	return p
}

func (s *KwAllPermissionsContext) GetParser() antlr.Parser { return s.parser }

func (s *KwAllPermissionsContext) K_ALL() antlr.TerminalNode {
	return s.GetToken(CQLParserK_ALL, 0)
}

func (s *KwAllPermissionsContext) K_PERMISSIONS() antlr.TerminalNode {
	return s.GetToken(CQLParserK_PERMISSIONS, 0)
}

func (s *KwAllPermissionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwAllPermissionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwAllPermissionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwAllPermissions(s)
	}
}

func (s *KwAllPermissionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwAllPermissions(s)
	}
}

func (p *CQLParser) KwAllPermissions() (localctx IKwAllPermissionsContext) {
	localctx = NewKwAllPermissionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 350, CQLParserRULE_kwAllPermissions)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2115)
		p.Match(CQLParserK_ALL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2116)
		p.Match(CQLParserK_PERMISSIONS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwAllowContext is an interface to support dynamic dispatch.
type IKwAllowContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_ALLOW() antlr.TerminalNode

	// IsKwAllowContext differentiates from other interfaces.
	IsKwAllowContext()
}

type KwAllowContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwAllowContext() *KwAllowContext {
	var p = new(KwAllowContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwAllow
	return p
}

func InitEmptyKwAllowContext(p *KwAllowContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwAllow
}

func (*KwAllowContext) IsKwAllowContext() {}

func NewKwAllowContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwAllowContext {
	var p = new(KwAllowContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwAllow

	return p
}

func (s *KwAllowContext) GetParser() antlr.Parser { return s.parser }

func (s *KwAllowContext) K_ALLOW() antlr.TerminalNode {
	return s.GetToken(CQLParserK_ALLOW, 0)
}

func (s *KwAllowContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwAllowContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwAllowContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwAllow(s)
	}
}

func (s *KwAllowContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwAllow(s)
	}
}

func (p *CQLParser) KwAllow() (localctx IKwAllowContext) {
	localctx = NewKwAllowContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 352, CQLParserRULE_kwAllow)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2118)
		p.Match(CQLParserK_ALLOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwAlterContext is an interface to support dynamic dispatch.
type IKwAlterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_ALTER() antlr.TerminalNode

	// IsKwAlterContext differentiates from other interfaces.
	IsKwAlterContext()
}

type KwAlterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwAlterContext() *KwAlterContext {
	var p = new(KwAlterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwAlter
	return p
}

func InitEmptyKwAlterContext(p *KwAlterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwAlter
}

func (*KwAlterContext) IsKwAlterContext() {}

func NewKwAlterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwAlterContext {
	var p = new(KwAlterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwAlter

	return p
}

func (s *KwAlterContext) GetParser() antlr.Parser { return s.parser }

func (s *KwAlterContext) K_ALTER() antlr.TerminalNode {
	return s.GetToken(CQLParserK_ALTER, 0)
}

func (s *KwAlterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwAlterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwAlterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwAlter(s)
	}
}

func (s *KwAlterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwAlter(s)
	}
}

func (p *CQLParser) KwAlter() (localctx IKwAlterContext) {
	localctx = NewKwAlterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 354, CQLParserRULE_kwAlter)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2120)
		p.Match(CQLParserK_ALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwAndContext is an interface to support dynamic dispatch.
type IKwAndContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_AND() antlr.TerminalNode

	// IsKwAndContext differentiates from other interfaces.
	IsKwAndContext()
}

type KwAndContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwAndContext() *KwAndContext {
	var p = new(KwAndContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwAnd
	return p
}

func InitEmptyKwAndContext(p *KwAndContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwAnd
}

func (*KwAndContext) IsKwAndContext() {}

func NewKwAndContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwAndContext {
	var p = new(KwAndContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwAnd

	return p
}

func (s *KwAndContext) GetParser() antlr.Parser { return s.parser }

func (s *KwAndContext) K_AND() antlr.TerminalNode {
	return s.GetToken(CQLParserK_AND, 0)
}

func (s *KwAndContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwAndContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwAndContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwAnd(s)
	}
}

func (s *KwAndContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwAnd(s)
	}
}

func (p *CQLParser) KwAnd() (localctx IKwAndContext) {
	localctx = NewKwAndContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 356, CQLParserRULE_kwAnd)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2122)
		p.Match(CQLParserK_AND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwApplyContext is an interface to support dynamic dispatch.
type IKwApplyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_APPLY() antlr.TerminalNode

	// IsKwApplyContext differentiates from other interfaces.
	IsKwApplyContext()
}

type KwApplyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwApplyContext() *KwApplyContext {
	var p = new(KwApplyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwApply
	return p
}

func InitEmptyKwApplyContext(p *KwApplyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwApply
}

func (*KwApplyContext) IsKwApplyContext() {}

func NewKwApplyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwApplyContext {
	var p = new(KwApplyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwApply

	return p
}

func (s *KwApplyContext) GetParser() antlr.Parser { return s.parser }

func (s *KwApplyContext) K_APPLY() antlr.TerminalNode {
	return s.GetToken(CQLParserK_APPLY, 0)
}

func (s *KwApplyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwApplyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwApplyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwApply(s)
	}
}

func (s *KwApplyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwApply(s)
	}
}

func (p *CQLParser) KwApply() (localctx IKwApplyContext) {
	localctx = NewKwApplyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 358, CQLParserRULE_kwApply)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2124)
		p.Match(CQLParserK_APPLY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwAsContext is an interface to support dynamic dispatch.
type IKwAsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_AS() antlr.TerminalNode

	// IsKwAsContext differentiates from other interfaces.
	IsKwAsContext()
}

type KwAsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwAsContext() *KwAsContext {
	var p = new(KwAsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwAs
	return p
}

func InitEmptyKwAsContext(p *KwAsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwAs
}

func (*KwAsContext) IsKwAsContext() {}

func NewKwAsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwAsContext {
	var p = new(KwAsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwAs

	return p
}

func (s *KwAsContext) GetParser() antlr.Parser { return s.parser }

func (s *KwAsContext) K_AS() antlr.TerminalNode {
	return s.GetToken(CQLParserK_AS, 0)
}

func (s *KwAsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwAsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwAsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwAs(s)
	}
}

func (s *KwAsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwAs(s)
	}
}

func (p *CQLParser) KwAs() (localctx IKwAsContext) {
	localctx = NewKwAsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 360, CQLParserRULE_kwAs)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2126)
		p.Match(CQLParserK_AS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwAscContext is an interface to support dynamic dispatch.
type IKwAscContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_ASC() antlr.TerminalNode

	// IsKwAscContext differentiates from other interfaces.
	IsKwAscContext()
}

type KwAscContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwAscContext() *KwAscContext {
	var p = new(KwAscContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwAsc
	return p
}

func InitEmptyKwAscContext(p *KwAscContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwAsc
}

func (*KwAscContext) IsKwAscContext() {}

func NewKwAscContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwAscContext {
	var p = new(KwAscContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwAsc

	return p
}

func (s *KwAscContext) GetParser() antlr.Parser { return s.parser }

func (s *KwAscContext) K_ASC() antlr.TerminalNode {
	return s.GetToken(CQLParserK_ASC, 0)
}

func (s *KwAscContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwAscContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwAscContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwAsc(s)
	}
}

func (s *KwAscContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwAsc(s)
	}
}

func (p *CQLParser) KwAsc() (localctx IKwAscContext) {
	localctx = NewKwAscContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 362, CQLParserRULE_kwAsc)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2128)
		p.Match(CQLParserK_ASC)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwAuthorizeContext is an interface to support dynamic dispatch.
type IKwAuthorizeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_AUTHORIZE() antlr.TerminalNode

	// IsKwAuthorizeContext differentiates from other interfaces.
	IsKwAuthorizeContext()
}

type KwAuthorizeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwAuthorizeContext() *KwAuthorizeContext {
	var p = new(KwAuthorizeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwAuthorize
	return p
}

func InitEmptyKwAuthorizeContext(p *KwAuthorizeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwAuthorize
}

func (*KwAuthorizeContext) IsKwAuthorizeContext() {}

func NewKwAuthorizeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwAuthorizeContext {
	var p = new(KwAuthorizeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwAuthorize

	return p
}

func (s *KwAuthorizeContext) GetParser() antlr.Parser { return s.parser }

func (s *KwAuthorizeContext) K_AUTHORIZE() antlr.TerminalNode {
	return s.GetToken(CQLParserK_AUTHORIZE, 0)
}

func (s *KwAuthorizeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwAuthorizeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwAuthorizeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwAuthorize(s)
	}
}

func (s *KwAuthorizeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwAuthorize(s)
	}
}

func (p *CQLParser) KwAuthorize() (localctx IKwAuthorizeContext) {
	localctx = NewKwAuthorizeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 364, CQLParserRULE_kwAuthorize)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2130)
		p.Match(CQLParserK_AUTHORIZE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwBatchContext is an interface to support dynamic dispatch.
type IKwBatchContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_BATCH() antlr.TerminalNode

	// IsKwBatchContext differentiates from other interfaces.
	IsKwBatchContext()
}

type KwBatchContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwBatchContext() *KwBatchContext {
	var p = new(KwBatchContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwBatch
	return p
}

func InitEmptyKwBatchContext(p *KwBatchContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwBatch
}

func (*KwBatchContext) IsKwBatchContext() {}

func NewKwBatchContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwBatchContext {
	var p = new(KwBatchContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwBatch

	return p
}

func (s *KwBatchContext) GetParser() antlr.Parser { return s.parser }

func (s *KwBatchContext) K_BATCH() antlr.TerminalNode {
	return s.GetToken(CQLParserK_BATCH, 0)
}

func (s *KwBatchContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwBatchContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwBatchContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwBatch(s)
	}
}

func (s *KwBatchContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwBatch(s)
	}
}

func (p *CQLParser) KwBatch() (localctx IKwBatchContext) {
	localctx = NewKwBatchContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 366, CQLParserRULE_kwBatch)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2132)
		p.Match(CQLParserK_BATCH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwBeginContext is an interface to support dynamic dispatch.
type IKwBeginContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_BEGIN() antlr.TerminalNode

	// IsKwBeginContext differentiates from other interfaces.
	IsKwBeginContext()
}

type KwBeginContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwBeginContext() *KwBeginContext {
	var p = new(KwBeginContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwBegin
	return p
}

func InitEmptyKwBeginContext(p *KwBeginContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwBegin
}

func (*KwBeginContext) IsKwBeginContext() {}

func NewKwBeginContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwBeginContext {
	var p = new(KwBeginContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwBegin

	return p
}

func (s *KwBeginContext) GetParser() antlr.Parser { return s.parser }

func (s *KwBeginContext) K_BEGIN() antlr.TerminalNode {
	return s.GetToken(CQLParserK_BEGIN, 0)
}

func (s *KwBeginContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwBeginContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwBeginContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwBegin(s)
	}
}

func (s *KwBeginContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwBegin(s)
	}
}

func (p *CQLParser) KwBegin() (localctx IKwBeginContext) {
	localctx = NewKwBeginContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 368, CQLParserRULE_kwBegin)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2134)
		p.Match(CQLParserK_BEGIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwByContext is an interface to support dynamic dispatch.
type IKwByContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_BY() antlr.TerminalNode

	// IsKwByContext differentiates from other interfaces.
	IsKwByContext()
}

type KwByContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwByContext() *KwByContext {
	var p = new(KwByContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwBy
	return p
}

func InitEmptyKwByContext(p *KwByContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwBy
}

func (*KwByContext) IsKwByContext() {}

func NewKwByContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwByContext {
	var p = new(KwByContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwBy

	return p
}

func (s *KwByContext) GetParser() antlr.Parser { return s.parser }

func (s *KwByContext) K_BY() antlr.TerminalNode {
	return s.GetToken(CQLParserK_BY, 0)
}

func (s *KwByContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwByContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwByContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwBy(s)
	}
}

func (s *KwByContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwBy(s)
	}
}

func (p *CQLParser) KwBy() (localctx IKwByContext) {
	localctx = NewKwByContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 370, CQLParserRULE_kwBy)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2136)
		p.Match(CQLParserK_BY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwCalledContext is an interface to support dynamic dispatch.
type IKwCalledContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_CALLED() antlr.TerminalNode

	// IsKwCalledContext differentiates from other interfaces.
	IsKwCalledContext()
}

type KwCalledContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwCalledContext() *KwCalledContext {
	var p = new(KwCalledContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwCalled
	return p
}

func InitEmptyKwCalledContext(p *KwCalledContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwCalled
}

func (*KwCalledContext) IsKwCalledContext() {}

func NewKwCalledContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwCalledContext {
	var p = new(KwCalledContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwCalled

	return p
}

func (s *KwCalledContext) GetParser() antlr.Parser { return s.parser }

func (s *KwCalledContext) K_CALLED() antlr.TerminalNode {
	return s.GetToken(CQLParserK_CALLED, 0)
}

func (s *KwCalledContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwCalledContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwCalledContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwCalled(s)
	}
}

func (s *KwCalledContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwCalled(s)
	}
}

func (p *CQLParser) KwCalled() (localctx IKwCalledContext) {
	localctx = NewKwCalledContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 372, CQLParserRULE_kwCalled)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2138)
		p.Match(CQLParserK_CALLED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwClusteringContext is an interface to support dynamic dispatch.
type IKwClusteringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_CLUSTERING() antlr.TerminalNode

	// IsKwClusteringContext differentiates from other interfaces.
	IsKwClusteringContext()
}

type KwClusteringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwClusteringContext() *KwClusteringContext {
	var p = new(KwClusteringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwClustering
	return p
}

func InitEmptyKwClusteringContext(p *KwClusteringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwClustering
}

func (*KwClusteringContext) IsKwClusteringContext() {}

func NewKwClusteringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwClusteringContext {
	var p = new(KwClusteringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwClustering

	return p
}

func (s *KwClusteringContext) GetParser() antlr.Parser { return s.parser }

func (s *KwClusteringContext) K_CLUSTERING() antlr.TerminalNode {
	return s.GetToken(CQLParserK_CLUSTERING, 0)
}

func (s *KwClusteringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwClusteringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwClusteringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwClustering(s)
	}
}

func (s *KwClusteringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwClustering(s)
	}
}

func (p *CQLParser) KwClustering() (localctx IKwClusteringContext) {
	localctx = NewKwClusteringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 374, CQLParserRULE_kwClustering)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2140)
		p.Match(CQLParserK_CLUSTERING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwCompactContext is an interface to support dynamic dispatch.
type IKwCompactContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_COMPACT() antlr.TerminalNode

	// IsKwCompactContext differentiates from other interfaces.
	IsKwCompactContext()
}

type KwCompactContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwCompactContext() *KwCompactContext {
	var p = new(KwCompactContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwCompact
	return p
}

func InitEmptyKwCompactContext(p *KwCompactContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwCompact
}

func (*KwCompactContext) IsKwCompactContext() {}

func NewKwCompactContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwCompactContext {
	var p = new(KwCompactContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwCompact

	return p
}

func (s *KwCompactContext) GetParser() antlr.Parser { return s.parser }

func (s *KwCompactContext) K_COMPACT() antlr.TerminalNode {
	return s.GetToken(CQLParserK_COMPACT, 0)
}

func (s *KwCompactContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwCompactContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwCompactContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwCompact(s)
	}
}

func (s *KwCompactContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwCompact(s)
	}
}

func (p *CQLParser) KwCompact() (localctx IKwCompactContext) {
	localctx = NewKwCompactContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 376, CQLParserRULE_kwCompact)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2142)
		p.Match(CQLParserK_COMPACT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwContainsContext is an interface to support dynamic dispatch.
type IKwContainsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_CONTAINS() antlr.TerminalNode

	// IsKwContainsContext differentiates from other interfaces.
	IsKwContainsContext()
}

type KwContainsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwContainsContext() *KwContainsContext {
	var p = new(KwContainsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwContains
	return p
}

func InitEmptyKwContainsContext(p *KwContainsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwContains
}

func (*KwContainsContext) IsKwContainsContext() {}

func NewKwContainsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwContainsContext {
	var p = new(KwContainsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwContains

	return p
}

func (s *KwContainsContext) GetParser() antlr.Parser { return s.parser }

func (s *KwContainsContext) K_CONTAINS() antlr.TerminalNode {
	return s.GetToken(CQLParserK_CONTAINS, 0)
}

func (s *KwContainsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwContainsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwContainsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwContains(s)
	}
}

func (s *KwContainsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwContains(s)
	}
}

func (p *CQLParser) KwContains() (localctx IKwContainsContext) {
	localctx = NewKwContainsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 378, CQLParserRULE_kwContains)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2144)
		p.Match(CQLParserK_CONTAINS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwCreateContext is an interface to support dynamic dispatch.
type IKwCreateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_CREATE() antlr.TerminalNode

	// IsKwCreateContext differentiates from other interfaces.
	IsKwCreateContext()
}

type KwCreateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwCreateContext() *KwCreateContext {
	var p = new(KwCreateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwCreate
	return p
}

func InitEmptyKwCreateContext(p *KwCreateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwCreate
}

func (*KwCreateContext) IsKwCreateContext() {}

func NewKwCreateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwCreateContext {
	var p = new(KwCreateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwCreate

	return p
}

func (s *KwCreateContext) GetParser() antlr.Parser { return s.parser }

func (s *KwCreateContext) K_CREATE() antlr.TerminalNode {
	return s.GetToken(CQLParserK_CREATE, 0)
}

func (s *KwCreateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwCreateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwCreateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwCreate(s)
	}
}

func (s *KwCreateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwCreate(s)
	}
}

func (p *CQLParser) KwCreate() (localctx IKwCreateContext) {
	localctx = NewKwCreateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 380, CQLParserRULE_kwCreate)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2146)
		p.Match(CQLParserK_CREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwDeleteContext is an interface to support dynamic dispatch.
type IKwDeleteContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_DELETE() antlr.TerminalNode

	// IsKwDeleteContext differentiates from other interfaces.
	IsKwDeleteContext()
}

type KwDeleteContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwDeleteContext() *KwDeleteContext {
	var p = new(KwDeleteContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwDelete
	return p
}

func InitEmptyKwDeleteContext(p *KwDeleteContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwDelete
}

func (*KwDeleteContext) IsKwDeleteContext() {}

func NewKwDeleteContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwDeleteContext {
	var p = new(KwDeleteContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwDelete

	return p
}

func (s *KwDeleteContext) GetParser() antlr.Parser { return s.parser }

func (s *KwDeleteContext) K_DELETE() antlr.TerminalNode {
	return s.GetToken(CQLParserK_DELETE, 0)
}

func (s *KwDeleteContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwDeleteContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwDeleteContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwDelete(s)
	}
}

func (s *KwDeleteContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwDelete(s)
	}
}

func (p *CQLParser) KwDelete() (localctx IKwDeleteContext) {
	localctx = NewKwDeleteContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 382, CQLParserRULE_kwDelete)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2148)
		p.Match(CQLParserK_DELETE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwDescContext is an interface to support dynamic dispatch.
type IKwDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_DESC() antlr.TerminalNode

	// IsKwDescContext differentiates from other interfaces.
	IsKwDescContext()
}

type KwDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwDescContext() *KwDescContext {
	var p = new(KwDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwDesc
	return p
}

func InitEmptyKwDescContext(p *KwDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwDesc
}

func (*KwDescContext) IsKwDescContext() {}

func NewKwDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwDescContext {
	var p = new(KwDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwDesc

	return p
}

func (s *KwDescContext) GetParser() antlr.Parser { return s.parser }

func (s *KwDescContext) K_DESC() antlr.TerminalNode {
	return s.GetToken(CQLParserK_DESC, 0)
}

func (s *KwDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwDesc(s)
	}
}

func (s *KwDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwDesc(s)
	}
}

func (p *CQLParser) KwDesc() (localctx IKwDescContext) {
	localctx = NewKwDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 384, CQLParserRULE_kwDesc)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2150)
		p.Match(CQLParserK_DESC)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwDescibeContext is an interface to support dynamic dispatch.
type IKwDescibeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_DESCRIBE() antlr.TerminalNode

	// IsKwDescibeContext differentiates from other interfaces.
	IsKwDescibeContext()
}

type KwDescibeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwDescibeContext() *KwDescibeContext {
	var p = new(KwDescibeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwDescibe
	return p
}

func InitEmptyKwDescibeContext(p *KwDescibeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwDescibe
}

func (*KwDescibeContext) IsKwDescibeContext() {}

func NewKwDescibeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwDescibeContext {
	var p = new(KwDescibeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwDescibe

	return p
}

func (s *KwDescibeContext) GetParser() antlr.Parser { return s.parser }

func (s *KwDescibeContext) K_DESCRIBE() antlr.TerminalNode {
	return s.GetToken(CQLParserK_DESCRIBE, 0)
}

func (s *KwDescibeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwDescibeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwDescibeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwDescibe(s)
	}
}

func (s *KwDescibeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwDescibe(s)
	}
}

func (p *CQLParser) KwDescibe() (localctx IKwDescibeContext) {
	localctx = NewKwDescibeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 386, CQLParserRULE_kwDescibe)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2152)
		p.Match(CQLParserK_DESCRIBE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwDistinctContext is an interface to support dynamic dispatch.
type IKwDistinctContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_DISTINCT() antlr.TerminalNode

	// IsKwDistinctContext differentiates from other interfaces.
	IsKwDistinctContext()
}

type KwDistinctContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwDistinctContext() *KwDistinctContext {
	var p = new(KwDistinctContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwDistinct
	return p
}

func InitEmptyKwDistinctContext(p *KwDistinctContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwDistinct
}

func (*KwDistinctContext) IsKwDistinctContext() {}

func NewKwDistinctContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwDistinctContext {
	var p = new(KwDistinctContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwDistinct

	return p
}

func (s *KwDistinctContext) GetParser() antlr.Parser { return s.parser }

func (s *KwDistinctContext) K_DISTINCT() antlr.TerminalNode {
	return s.GetToken(CQLParserK_DISTINCT, 0)
}

func (s *KwDistinctContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwDistinctContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwDistinctContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwDistinct(s)
	}
}

func (s *KwDistinctContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwDistinct(s)
	}
}

func (p *CQLParser) KwDistinct() (localctx IKwDistinctContext) {
	localctx = NewKwDistinctContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 388, CQLParserRULE_kwDistinct)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2154)
		p.Match(CQLParserK_DISTINCT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwDropContext is an interface to support dynamic dispatch.
type IKwDropContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_DROP() antlr.TerminalNode

	// IsKwDropContext differentiates from other interfaces.
	IsKwDropContext()
}

type KwDropContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwDropContext() *KwDropContext {
	var p = new(KwDropContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwDrop
	return p
}

func InitEmptyKwDropContext(p *KwDropContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwDrop
}

func (*KwDropContext) IsKwDropContext() {}

func NewKwDropContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwDropContext {
	var p = new(KwDropContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwDrop

	return p
}

func (s *KwDropContext) GetParser() antlr.Parser { return s.parser }

func (s *KwDropContext) K_DROP() antlr.TerminalNode {
	return s.GetToken(CQLParserK_DROP, 0)
}

func (s *KwDropContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwDropContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwDropContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwDrop(s)
	}
}

func (s *KwDropContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwDrop(s)
	}
}

func (p *CQLParser) KwDrop() (localctx IKwDropContext) {
	localctx = NewKwDropContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 390, CQLParserRULE_kwDrop)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2156)
		p.Match(CQLParserK_DROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwDurableWritesContext is an interface to support dynamic dispatch.
type IKwDurableWritesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_DURABLE_WRITES() antlr.TerminalNode

	// IsKwDurableWritesContext differentiates from other interfaces.
	IsKwDurableWritesContext()
}

type KwDurableWritesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwDurableWritesContext() *KwDurableWritesContext {
	var p = new(KwDurableWritesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwDurableWrites
	return p
}

func InitEmptyKwDurableWritesContext(p *KwDurableWritesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwDurableWrites
}

func (*KwDurableWritesContext) IsKwDurableWritesContext() {}

func NewKwDurableWritesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwDurableWritesContext {
	var p = new(KwDurableWritesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwDurableWrites

	return p
}

func (s *KwDurableWritesContext) GetParser() antlr.Parser { return s.parser }

func (s *KwDurableWritesContext) K_DURABLE_WRITES() antlr.TerminalNode {
	return s.GetToken(CQLParserK_DURABLE_WRITES, 0)
}

func (s *KwDurableWritesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwDurableWritesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwDurableWritesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwDurableWrites(s)
	}
}

func (s *KwDurableWritesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwDurableWrites(s)
	}
}

func (p *CQLParser) KwDurableWrites() (localctx IKwDurableWritesContext) {
	localctx = NewKwDurableWritesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 392, CQLParserRULE_kwDurableWrites)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2158)
		p.Match(CQLParserK_DURABLE_WRITES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwEntriesContext is an interface to support dynamic dispatch.
type IKwEntriesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_ENTRIES() antlr.TerminalNode

	// IsKwEntriesContext differentiates from other interfaces.
	IsKwEntriesContext()
}

type KwEntriesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwEntriesContext() *KwEntriesContext {
	var p = new(KwEntriesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwEntries
	return p
}

func InitEmptyKwEntriesContext(p *KwEntriesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwEntries
}

func (*KwEntriesContext) IsKwEntriesContext() {}

func NewKwEntriesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwEntriesContext {
	var p = new(KwEntriesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwEntries

	return p
}

func (s *KwEntriesContext) GetParser() antlr.Parser { return s.parser }

func (s *KwEntriesContext) K_ENTRIES() antlr.TerminalNode {
	return s.GetToken(CQLParserK_ENTRIES, 0)
}

func (s *KwEntriesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwEntriesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwEntriesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwEntries(s)
	}
}

func (s *KwEntriesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwEntries(s)
	}
}

func (p *CQLParser) KwEntries() (localctx IKwEntriesContext) {
	localctx = NewKwEntriesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 394, CQLParserRULE_kwEntries)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2160)
		p.Match(CQLParserK_ENTRIES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwExecuteContext is an interface to support dynamic dispatch.
type IKwExecuteContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_EXECUTE() antlr.TerminalNode

	// IsKwExecuteContext differentiates from other interfaces.
	IsKwExecuteContext()
}

type KwExecuteContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwExecuteContext() *KwExecuteContext {
	var p = new(KwExecuteContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwExecute
	return p
}

func InitEmptyKwExecuteContext(p *KwExecuteContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwExecute
}

func (*KwExecuteContext) IsKwExecuteContext() {}

func NewKwExecuteContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwExecuteContext {
	var p = new(KwExecuteContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwExecute

	return p
}

func (s *KwExecuteContext) GetParser() antlr.Parser { return s.parser }

func (s *KwExecuteContext) K_EXECUTE() antlr.TerminalNode {
	return s.GetToken(CQLParserK_EXECUTE, 0)
}

func (s *KwExecuteContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwExecuteContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwExecuteContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwExecute(s)
	}
}

func (s *KwExecuteContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwExecute(s)
	}
}

func (p *CQLParser) KwExecute() (localctx IKwExecuteContext) {
	localctx = NewKwExecuteContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 396, CQLParserRULE_kwExecute)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2162)
		p.Match(CQLParserK_EXECUTE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwExistsContext is an interface to support dynamic dispatch.
type IKwExistsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_EXISTS() antlr.TerminalNode

	// IsKwExistsContext differentiates from other interfaces.
	IsKwExistsContext()
}

type KwExistsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwExistsContext() *KwExistsContext {
	var p = new(KwExistsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwExists
	return p
}

func InitEmptyKwExistsContext(p *KwExistsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwExists
}

func (*KwExistsContext) IsKwExistsContext() {}

func NewKwExistsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwExistsContext {
	var p = new(KwExistsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwExists

	return p
}

func (s *KwExistsContext) GetParser() antlr.Parser { return s.parser }

func (s *KwExistsContext) K_EXISTS() antlr.TerminalNode {
	return s.GetToken(CQLParserK_EXISTS, 0)
}

func (s *KwExistsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwExistsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwExistsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwExists(s)
	}
}

func (s *KwExistsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwExists(s)
	}
}

func (p *CQLParser) KwExists() (localctx IKwExistsContext) {
	localctx = NewKwExistsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 398, CQLParserRULE_kwExists)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2164)
		p.Match(CQLParserK_EXISTS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwFilteringContext is an interface to support dynamic dispatch.
type IKwFilteringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_FILTERING() antlr.TerminalNode

	// IsKwFilteringContext differentiates from other interfaces.
	IsKwFilteringContext()
}

type KwFilteringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwFilteringContext() *KwFilteringContext {
	var p = new(KwFilteringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwFiltering
	return p
}

func InitEmptyKwFilteringContext(p *KwFilteringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwFiltering
}

func (*KwFilteringContext) IsKwFilteringContext() {}

func NewKwFilteringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwFilteringContext {
	var p = new(KwFilteringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwFiltering

	return p
}

func (s *KwFilteringContext) GetParser() antlr.Parser { return s.parser }

func (s *KwFilteringContext) K_FILTERING() antlr.TerminalNode {
	return s.GetToken(CQLParserK_FILTERING, 0)
}

func (s *KwFilteringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwFilteringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwFilteringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwFiltering(s)
	}
}

func (s *KwFilteringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwFiltering(s)
	}
}

func (p *CQLParser) KwFiltering() (localctx IKwFilteringContext) {
	localctx = NewKwFilteringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 400, CQLParserRULE_kwFiltering)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2166)
		p.Match(CQLParserK_FILTERING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwFinalfuncContext is an interface to support dynamic dispatch.
type IKwFinalfuncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_FINALFUNC() antlr.TerminalNode

	// IsKwFinalfuncContext differentiates from other interfaces.
	IsKwFinalfuncContext()
}

type KwFinalfuncContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwFinalfuncContext() *KwFinalfuncContext {
	var p = new(KwFinalfuncContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwFinalfunc
	return p
}

func InitEmptyKwFinalfuncContext(p *KwFinalfuncContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwFinalfunc
}

func (*KwFinalfuncContext) IsKwFinalfuncContext() {}

func NewKwFinalfuncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwFinalfuncContext {
	var p = new(KwFinalfuncContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwFinalfunc

	return p
}

func (s *KwFinalfuncContext) GetParser() antlr.Parser { return s.parser }

func (s *KwFinalfuncContext) K_FINALFUNC() antlr.TerminalNode {
	return s.GetToken(CQLParserK_FINALFUNC, 0)
}

func (s *KwFinalfuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwFinalfuncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwFinalfuncContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwFinalfunc(s)
	}
}

func (s *KwFinalfuncContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwFinalfunc(s)
	}
}

func (p *CQLParser) KwFinalfunc() (localctx IKwFinalfuncContext) {
	localctx = NewKwFinalfuncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 402, CQLParserRULE_kwFinalfunc)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2168)
		p.Match(CQLParserK_FINALFUNC)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwFromContext is an interface to support dynamic dispatch.
type IKwFromContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_FROM() antlr.TerminalNode

	// IsKwFromContext differentiates from other interfaces.
	IsKwFromContext()
}

type KwFromContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwFromContext() *KwFromContext {
	var p = new(KwFromContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwFrom
	return p
}

func InitEmptyKwFromContext(p *KwFromContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwFrom
}

func (*KwFromContext) IsKwFromContext() {}

func NewKwFromContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwFromContext {
	var p = new(KwFromContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwFrom

	return p
}

func (s *KwFromContext) GetParser() antlr.Parser { return s.parser }

func (s *KwFromContext) K_FROM() antlr.TerminalNode {
	return s.GetToken(CQLParserK_FROM, 0)
}

func (s *KwFromContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwFromContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwFromContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwFrom(s)
	}
}

func (s *KwFromContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwFrom(s)
	}
}

func (p *CQLParser) KwFrom() (localctx IKwFromContext) {
	localctx = NewKwFromContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 404, CQLParserRULE_kwFrom)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2170)
		p.Match(CQLParserK_FROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwFullContext is an interface to support dynamic dispatch.
type IKwFullContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_FULL() antlr.TerminalNode

	// IsKwFullContext differentiates from other interfaces.
	IsKwFullContext()
}

type KwFullContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwFullContext() *KwFullContext {
	var p = new(KwFullContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwFull
	return p
}

func InitEmptyKwFullContext(p *KwFullContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwFull
}

func (*KwFullContext) IsKwFullContext() {}

func NewKwFullContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwFullContext {
	var p = new(KwFullContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwFull

	return p
}

func (s *KwFullContext) GetParser() antlr.Parser { return s.parser }

func (s *KwFullContext) K_FULL() antlr.TerminalNode {
	return s.GetToken(CQLParserK_FULL, 0)
}

func (s *KwFullContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwFullContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwFullContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwFull(s)
	}
}

func (s *KwFullContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwFull(s)
	}
}

func (p *CQLParser) KwFull() (localctx IKwFullContext) {
	localctx = NewKwFullContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 406, CQLParserRULE_kwFull)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2172)
		p.Match(CQLParserK_FULL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwFunctionContext is an interface to support dynamic dispatch.
type IKwFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_FUNCTION() antlr.TerminalNode

	// IsKwFunctionContext differentiates from other interfaces.
	IsKwFunctionContext()
}

type KwFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwFunctionContext() *KwFunctionContext {
	var p = new(KwFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwFunction
	return p
}

func InitEmptyKwFunctionContext(p *KwFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwFunction
}

func (*KwFunctionContext) IsKwFunctionContext() {}

func NewKwFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwFunctionContext {
	var p = new(KwFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwFunction

	return p
}

func (s *KwFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *KwFunctionContext) K_FUNCTION() antlr.TerminalNode {
	return s.GetToken(CQLParserK_FUNCTION, 0)
}

func (s *KwFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwFunction(s)
	}
}

func (s *KwFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwFunction(s)
	}
}

func (p *CQLParser) KwFunction() (localctx IKwFunctionContext) {
	localctx = NewKwFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 408, CQLParserRULE_kwFunction)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2174)
		p.Match(CQLParserK_FUNCTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwFunctionsContext is an interface to support dynamic dispatch.
type IKwFunctionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_FUNCTIONS() antlr.TerminalNode

	// IsKwFunctionsContext differentiates from other interfaces.
	IsKwFunctionsContext()
}

type KwFunctionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwFunctionsContext() *KwFunctionsContext {
	var p = new(KwFunctionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwFunctions
	return p
}

func InitEmptyKwFunctionsContext(p *KwFunctionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwFunctions
}

func (*KwFunctionsContext) IsKwFunctionsContext() {}

func NewKwFunctionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwFunctionsContext {
	var p = new(KwFunctionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwFunctions

	return p
}

func (s *KwFunctionsContext) GetParser() antlr.Parser { return s.parser }

func (s *KwFunctionsContext) K_FUNCTIONS() antlr.TerminalNode {
	return s.GetToken(CQLParserK_FUNCTIONS, 0)
}

func (s *KwFunctionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwFunctionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwFunctionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwFunctions(s)
	}
}

func (s *KwFunctionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwFunctions(s)
	}
}

func (p *CQLParser) KwFunctions() (localctx IKwFunctionsContext) {
	localctx = NewKwFunctionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 410, CQLParserRULE_kwFunctions)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2176)
		p.Match(CQLParserK_FUNCTIONS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwGrantContext is an interface to support dynamic dispatch.
type IKwGrantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_GRANT() antlr.TerminalNode

	// IsKwGrantContext differentiates from other interfaces.
	IsKwGrantContext()
}

type KwGrantContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwGrantContext() *KwGrantContext {
	var p = new(KwGrantContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwGrant
	return p
}

func InitEmptyKwGrantContext(p *KwGrantContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwGrant
}

func (*KwGrantContext) IsKwGrantContext() {}

func NewKwGrantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwGrantContext {
	var p = new(KwGrantContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwGrant

	return p
}

func (s *KwGrantContext) GetParser() antlr.Parser { return s.parser }

func (s *KwGrantContext) K_GRANT() antlr.TerminalNode {
	return s.GetToken(CQLParserK_GRANT, 0)
}

func (s *KwGrantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwGrantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwGrantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwGrant(s)
	}
}

func (s *KwGrantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwGrant(s)
	}
}

func (p *CQLParser) KwGrant() (localctx IKwGrantContext) {
	localctx = NewKwGrantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 412, CQLParserRULE_kwGrant)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2178)
		p.Match(CQLParserK_GRANT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwIfContext is an interface to support dynamic dispatch.
type IKwIfContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_IF() antlr.TerminalNode

	// IsKwIfContext differentiates from other interfaces.
	IsKwIfContext()
}

type KwIfContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwIfContext() *KwIfContext {
	var p = new(KwIfContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwIf
	return p
}

func InitEmptyKwIfContext(p *KwIfContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwIf
}

func (*KwIfContext) IsKwIfContext() {}

func NewKwIfContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwIfContext {
	var p = new(KwIfContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwIf

	return p
}

func (s *KwIfContext) GetParser() antlr.Parser { return s.parser }

func (s *KwIfContext) K_IF() antlr.TerminalNode {
	return s.GetToken(CQLParserK_IF, 0)
}

func (s *KwIfContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwIfContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwIfContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwIf(s)
	}
}

func (s *KwIfContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwIf(s)
	}
}

func (p *CQLParser) KwIf() (localctx IKwIfContext) {
	localctx = NewKwIfContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 414, CQLParserRULE_kwIf)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2180)
		p.Match(CQLParserK_IF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwInContext is an interface to support dynamic dispatch.
type IKwInContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_IN() antlr.TerminalNode

	// IsKwInContext differentiates from other interfaces.
	IsKwInContext()
}

type KwInContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwInContext() *KwInContext {
	var p = new(KwInContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwIn
	return p
}

func InitEmptyKwInContext(p *KwInContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwIn
}

func (*KwInContext) IsKwInContext() {}

func NewKwInContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwInContext {
	var p = new(KwInContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwIn

	return p
}

func (s *KwInContext) GetParser() antlr.Parser { return s.parser }

func (s *KwInContext) K_IN() antlr.TerminalNode {
	return s.GetToken(CQLParserK_IN, 0)
}

func (s *KwInContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwInContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwInContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwIn(s)
	}
}

func (s *KwInContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwIn(s)
	}
}

func (p *CQLParser) KwIn() (localctx IKwInContext) {
	localctx = NewKwInContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 416, CQLParserRULE_kwIn)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2182)
		p.Match(CQLParserK_IN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwIndexContext is an interface to support dynamic dispatch.
type IKwIndexContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_INDEX() antlr.TerminalNode

	// IsKwIndexContext differentiates from other interfaces.
	IsKwIndexContext()
}

type KwIndexContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwIndexContext() *KwIndexContext {
	var p = new(KwIndexContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwIndex
	return p
}

func InitEmptyKwIndexContext(p *KwIndexContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwIndex
}

func (*KwIndexContext) IsKwIndexContext() {}

func NewKwIndexContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwIndexContext {
	var p = new(KwIndexContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwIndex

	return p
}

func (s *KwIndexContext) GetParser() antlr.Parser { return s.parser }

func (s *KwIndexContext) K_INDEX() antlr.TerminalNode {
	return s.GetToken(CQLParserK_INDEX, 0)
}

func (s *KwIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwIndexContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwIndex(s)
	}
}

func (s *KwIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwIndex(s)
	}
}

func (p *CQLParser) KwIndex() (localctx IKwIndexContext) {
	localctx = NewKwIndexContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 418, CQLParserRULE_kwIndex)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2184)
		p.Match(CQLParserK_INDEX)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwInitcondContext is an interface to support dynamic dispatch.
type IKwInitcondContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_INITCOND() antlr.TerminalNode

	// IsKwInitcondContext differentiates from other interfaces.
	IsKwInitcondContext()
}

type KwInitcondContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwInitcondContext() *KwInitcondContext {
	var p = new(KwInitcondContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwInitcond
	return p
}

func InitEmptyKwInitcondContext(p *KwInitcondContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwInitcond
}

func (*KwInitcondContext) IsKwInitcondContext() {}

func NewKwInitcondContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwInitcondContext {
	var p = new(KwInitcondContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwInitcond

	return p
}

func (s *KwInitcondContext) GetParser() antlr.Parser { return s.parser }

func (s *KwInitcondContext) K_INITCOND() antlr.TerminalNode {
	return s.GetToken(CQLParserK_INITCOND, 0)
}

func (s *KwInitcondContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwInitcondContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwInitcondContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwInitcond(s)
	}
}

func (s *KwInitcondContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwInitcond(s)
	}
}

func (p *CQLParser) KwInitcond() (localctx IKwInitcondContext) {
	localctx = NewKwInitcondContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 420, CQLParserRULE_kwInitcond)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2186)
		p.Match(CQLParserK_INITCOND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwInputContext is an interface to support dynamic dispatch.
type IKwInputContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_INPUT() antlr.TerminalNode

	// IsKwInputContext differentiates from other interfaces.
	IsKwInputContext()
}

type KwInputContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwInputContext() *KwInputContext {
	var p = new(KwInputContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwInput
	return p
}

func InitEmptyKwInputContext(p *KwInputContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwInput
}

func (*KwInputContext) IsKwInputContext() {}

func NewKwInputContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwInputContext {
	var p = new(KwInputContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwInput

	return p
}

func (s *KwInputContext) GetParser() antlr.Parser { return s.parser }

func (s *KwInputContext) K_INPUT() antlr.TerminalNode {
	return s.GetToken(CQLParserK_INPUT, 0)
}

func (s *KwInputContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwInputContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwInputContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwInput(s)
	}
}

func (s *KwInputContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwInput(s)
	}
}

func (p *CQLParser) KwInput() (localctx IKwInputContext) {
	localctx = NewKwInputContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 422, CQLParserRULE_kwInput)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2188)
		p.Match(CQLParserK_INPUT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwInsertContext is an interface to support dynamic dispatch.
type IKwInsertContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_INSERT() antlr.TerminalNode

	// IsKwInsertContext differentiates from other interfaces.
	IsKwInsertContext()
}

type KwInsertContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwInsertContext() *KwInsertContext {
	var p = new(KwInsertContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwInsert
	return p
}

func InitEmptyKwInsertContext(p *KwInsertContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwInsert
}

func (*KwInsertContext) IsKwInsertContext() {}

func NewKwInsertContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwInsertContext {
	var p = new(KwInsertContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwInsert

	return p
}

func (s *KwInsertContext) GetParser() antlr.Parser { return s.parser }

func (s *KwInsertContext) K_INSERT() antlr.TerminalNode {
	return s.GetToken(CQLParserK_INSERT, 0)
}

func (s *KwInsertContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwInsertContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwInsertContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwInsert(s)
	}
}

func (s *KwInsertContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwInsert(s)
	}
}

func (p *CQLParser) KwInsert() (localctx IKwInsertContext) {
	localctx = NewKwInsertContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 424, CQLParserRULE_kwInsert)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2190)
		p.Match(CQLParserK_INSERT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwIntoContext is an interface to support dynamic dispatch.
type IKwIntoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_INTO() antlr.TerminalNode

	// IsKwIntoContext differentiates from other interfaces.
	IsKwIntoContext()
}

type KwIntoContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwIntoContext() *KwIntoContext {
	var p = new(KwIntoContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwInto
	return p
}

func InitEmptyKwIntoContext(p *KwIntoContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwInto
}

func (*KwIntoContext) IsKwIntoContext() {}

func NewKwIntoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwIntoContext {
	var p = new(KwIntoContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwInto

	return p
}

func (s *KwIntoContext) GetParser() antlr.Parser { return s.parser }

func (s *KwIntoContext) K_INTO() antlr.TerminalNode {
	return s.GetToken(CQLParserK_INTO, 0)
}

func (s *KwIntoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwIntoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwIntoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwInto(s)
	}
}

func (s *KwIntoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwInto(s)
	}
}

func (p *CQLParser) KwInto() (localctx IKwIntoContext) {
	localctx = NewKwIntoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 426, CQLParserRULE_kwInto)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2192)
		p.Match(CQLParserK_INTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwIsContext is an interface to support dynamic dispatch.
type IKwIsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_IS() antlr.TerminalNode

	// IsKwIsContext differentiates from other interfaces.
	IsKwIsContext()
}

type KwIsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwIsContext() *KwIsContext {
	var p = new(KwIsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwIs
	return p
}

func InitEmptyKwIsContext(p *KwIsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwIs
}

func (*KwIsContext) IsKwIsContext() {}

func NewKwIsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwIsContext {
	var p = new(KwIsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwIs

	return p
}

func (s *KwIsContext) GetParser() antlr.Parser { return s.parser }

func (s *KwIsContext) K_IS() antlr.TerminalNode {
	return s.GetToken(CQLParserK_IS, 0)
}

func (s *KwIsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwIsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwIsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwIs(s)
	}
}

func (s *KwIsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwIs(s)
	}
}

func (p *CQLParser) KwIs() (localctx IKwIsContext) {
	localctx = NewKwIsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 428, CQLParserRULE_kwIs)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2194)
		p.Match(CQLParserK_IS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwJsonContext is an interface to support dynamic dispatch.
type IKwJsonContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_JSON() antlr.TerminalNode

	// IsKwJsonContext differentiates from other interfaces.
	IsKwJsonContext()
}

type KwJsonContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwJsonContext() *KwJsonContext {
	var p = new(KwJsonContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwJson
	return p
}

func InitEmptyKwJsonContext(p *KwJsonContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwJson
}

func (*KwJsonContext) IsKwJsonContext() {}

func NewKwJsonContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwJsonContext {
	var p = new(KwJsonContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwJson

	return p
}

func (s *KwJsonContext) GetParser() antlr.Parser { return s.parser }

func (s *KwJsonContext) K_JSON() antlr.TerminalNode {
	return s.GetToken(CQLParserK_JSON, 0)
}

func (s *KwJsonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwJsonContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwJsonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwJson(s)
	}
}

func (s *KwJsonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwJson(s)
	}
}

func (p *CQLParser) KwJson() (localctx IKwJsonContext) {
	localctx = NewKwJsonContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 430, CQLParserRULE_kwJson)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2196)
		p.Match(CQLParserK_JSON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwKeyContext is an interface to support dynamic dispatch.
type IKwKeyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_KEY() antlr.TerminalNode

	// IsKwKeyContext differentiates from other interfaces.
	IsKwKeyContext()
}

type KwKeyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwKeyContext() *KwKeyContext {
	var p = new(KwKeyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwKey
	return p
}

func InitEmptyKwKeyContext(p *KwKeyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwKey
}

func (*KwKeyContext) IsKwKeyContext() {}

func NewKwKeyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwKeyContext {
	var p = new(KwKeyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwKey

	return p
}

func (s *KwKeyContext) GetParser() antlr.Parser { return s.parser }

func (s *KwKeyContext) K_KEY() antlr.TerminalNode {
	return s.GetToken(CQLParserK_KEY, 0)
}

func (s *KwKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwKeyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwKey(s)
	}
}

func (s *KwKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwKey(s)
	}
}

func (p *CQLParser) KwKey() (localctx IKwKeyContext) {
	localctx = NewKwKeyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 432, CQLParserRULE_kwKey)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2198)
		p.Match(CQLParserK_KEY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwKeysContext is an interface to support dynamic dispatch.
type IKwKeysContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_KEYS() antlr.TerminalNode

	// IsKwKeysContext differentiates from other interfaces.
	IsKwKeysContext()
}

type KwKeysContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwKeysContext() *KwKeysContext {
	var p = new(KwKeysContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwKeys
	return p
}

func InitEmptyKwKeysContext(p *KwKeysContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwKeys
}

func (*KwKeysContext) IsKwKeysContext() {}

func NewKwKeysContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwKeysContext {
	var p = new(KwKeysContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwKeys

	return p
}

func (s *KwKeysContext) GetParser() antlr.Parser { return s.parser }

func (s *KwKeysContext) K_KEYS() antlr.TerminalNode {
	return s.GetToken(CQLParserK_KEYS, 0)
}

func (s *KwKeysContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwKeysContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwKeysContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwKeys(s)
	}
}

func (s *KwKeysContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwKeys(s)
	}
}

func (p *CQLParser) KwKeys() (localctx IKwKeysContext) {
	localctx = NewKwKeysContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 434, CQLParserRULE_kwKeys)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2200)
		p.Match(CQLParserK_KEYS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwKeyspaceContext is an interface to support dynamic dispatch.
type IKwKeyspaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_KEYSPACE() antlr.TerminalNode

	// IsKwKeyspaceContext differentiates from other interfaces.
	IsKwKeyspaceContext()
}

type KwKeyspaceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwKeyspaceContext() *KwKeyspaceContext {
	var p = new(KwKeyspaceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwKeyspace
	return p
}

func InitEmptyKwKeyspaceContext(p *KwKeyspaceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwKeyspace
}

func (*KwKeyspaceContext) IsKwKeyspaceContext() {}

func NewKwKeyspaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwKeyspaceContext {
	var p = new(KwKeyspaceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwKeyspace

	return p
}

func (s *KwKeyspaceContext) GetParser() antlr.Parser { return s.parser }

func (s *KwKeyspaceContext) K_KEYSPACE() antlr.TerminalNode {
	return s.GetToken(CQLParserK_KEYSPACE, 0)
}

func (s *KwKeyspaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwKeyspaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwKeyspaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwKeyspace(s)
	}
}

func (s *KwKeyspaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwKeyspace(s)
	}
}

func (p *CQLParser) KwKeyspace() (localctx IKwKeyspaceContext) {
	localctx = NewKwKeyspaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 436, CQLParserRULE_kwKeyspace)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2202)
		p.Match(CQLParserK_KEYSPACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwKeyspacesContext is an interface to support dynamic dispatch.
type IKwKeyspacesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_KEYSPACES() antlr.TerminalNode

	// IsKwKeyspacesContext differentiates from other interfaces.
	IsKwKeyspacesContext()
}

type KwKeyspacesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwKeyspacesContext() *KwKeyspacesContext {
	var p = new(KwKeyspacesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwKeyspaces
	return p
}

func InitEmptyKwKeyspacesContext(p *KwKeyspacesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwKeyspaces
}

func (*KwKeyspacesContext) IsKwKeyspacesContext() {}

func NewKwKeyspacesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwKeyspacesContext {
	var p = new(KwKeyspacesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwKeyspaces

	return p
}

func (s *KwKeyspacesContext) GetParser() antlr.Parser { return s.parser }

func (s *KwKeyspacesContext) K_KEYSPACES() antlr.TerminalNode {
	return s.GetToken(CQLParserK_KEYSPACES, 0)
}

func (s *KwKeyspacesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwKeyspacesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwKeyspacesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwKeyspaces(s)
	}
}

func (s *KwKeyspacesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwKeyspaces(s)
	}
}

func (p *CQLParser) KwKeyspaces() (localctx IKwKeyspacesContext) {
	localctx = NewKwKeyspacesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 438, CQLParserRULE_kwKeyspaces)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2204)
		p.Match(CQLParserK_KEYSPACES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwLanguageContext is an interface to support dynamic dispatch.
type IKwLanguageContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_LANGUAGE() antlr.TerminalNode

	// IsKwLanguageContext differentiates from other interfaces.
	IsKwLanguageContext()
}

type KwLanguageContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwLanguageContext() *KwLanguageContext {
	var p = new(KwLanguageContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwLanguage
	return p
}

func InitEmptyKwLanguageContext(p *KwLanguageContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwLanguage
}

func (*KwLanguageContext) IsKwLanguageContext() {}

func NewKwLanguageContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwLanguageContext {
	var p = new(KwLanguageContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwLanguage

	return p
}

func (s *KwLanguageContext) GetParser() antlr.Parser { return s.parser }

func (s *KwLanguageContext) K_LANGUAGE() antlr.TerminalNode {
	return s.GetToken(CQLParserK_LANGUAGE, 0)
}

func (s *KwLanguageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwLanguageContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwLanguageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwLanguage(s)
	}
}

func (s *KwLanguageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwLanguage(s)
	}
}

func (p *CQLParser) KwLanguage() (localctx IKwLanguageContext) {
	localctx = NewKwLanguageContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 440, CQLParserRULE_kwLanguage)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2206)
		p.Match(CQLParserK_LANGUAGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwLimitContext is an interface to support dynamic dispatch.
type IKwLimitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_LIMIT() antlr.TerminalNode

	// IsKwLimitContext differentiates from other interfaces.
	IsKwLimitContext()
}

type KwLimitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwLimitContext() *KwLimitContext {
	var p = new(KwLimitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwLimit
	return p
}

func InitEmptyKwLimitContext(p *KwLimitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwLimit
}

func (*KwLimitContext) IsKwLimitContext() {}

func NewKwLimitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwLimitContext {
	var p = new(KwLimitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwLimit

	return p
}

func (s *KwLimitContext) GetParser() antlr.Parser { return s.parser }

func (s *KwLimitContext) K_LIMIT() antlr.TerminalNode {
	return s.GetToken(CQLParserK_LIMIT, 0)
}

func (s *KwLimitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwLimitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwLimitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwLimit(s)
	}
}

func (s *KwLimitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwLimit(s)
	}
}

func (p *CQLParser) KwLimit() (localctx IKwLimitContext) {
	localctx = NewKwLimitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 442, CQLParserRULE_kwLimit)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2208)
		p.Match(CQLParserK_LIMIT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwListContext is an interface to support dynamic dispatch.
type IKwListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_LIST() antlr.TerminalNode

	// IsKwListContext differentiates from other interfaces.
	IsKwListContext()
}

type KwListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwListContext() *KwListContext {
	var p = new(KwListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwList
	return p
}

func InitEmptyKwListContext(p *KwListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwList
}

func (*KwListContext) IsKwListContext() {}

func NewKwListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwListContext {
	var p = new(KwListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwList

	return p
}

func (s *KwListContext) GetParser() antlr.Parser { return s.parser }

func (s *KwListContext) K_LIST() antlr.TerminalNode {
	return s.GetToken(CQLParserK_LIST, 0)
}

func (s *KwListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwList(s)
	}
}

func (s *KwListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwList(s)
	}
}

func (p *CQLParser) KwList() (localctx IKwListContext) {
	localctx = NewKwListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 444, CQLParserRULE_kwList)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2210)
		p.Match(CQLParserK_LIST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwLoggedContext is an interface to support dynamic dispatch.
type IKwLoggedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_LOGGED() antlr.TerminalNode

	// IsKwLoggedContext differentiates from other interfaces.
	IsKwLoggedContext()
}

type KwLoggedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwLoggedContext() *KwLoggedContext {
	var p = new(KwLoggedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwLogged
	return p
}

func InitEmptyKwLoggedContext(p *KwLoggedContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwLogged
}

func (*KwLoggedContext) IsKwLoggedContext() {}

func NewKwLoggedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwLoggedContext {
	var p = new(KwLoggedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwLogged

	return p
}

func (s *KwLoggedContext) GetParser() antlr.Parser { return s.parser }

func (s *KwLoggedContext) K_LOGGED() antlr.TerminalNode {
	return s.GetToken(CQLParserK_LOGGED, 0)
}

func (s *KwLoggedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwLoggedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwLoggedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwLogged(s)
	}
}

func (s *KwLoggedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwLogged(s)
	}
}

func (p *CQLParser) KwLogged() (localctx IKwLoggedContext) {
	localctx = NewKwLoggedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 446, CQLParserRULE_kwLogged)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2212)
		p.Match(CQLParserK_LOGGED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwLoginContext is an interface to support dynamic dispatch.
type IKwLoginContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_LOGIN() antlr.TerminalNode

	// IsKwLoginContext differentiates from other interfaces.
	IsKwLoginContext()
}

type KwLoginContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwLoginContext() *KwLoginContext {
	var p = new(KwLoginContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwLogin
	return p
}

func InitEmptyKwLoginContext(p *KwLoginContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwLogin
}

func (*KwLoginContext) IsKwLoginContext() {}

func NewKwLoginContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwLoginContext {
	var p = new(KwLoginContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwLogin

	return p
}

func (s *KwLoginContext) GetParser() antlr.Parser { return s.parser }

func (s *KwLoginContext) K_LOGIN() antlr.TerminalNode {
	return s.GetToken(CQLParserK_LOGIN, 0)
}

func (s *KwLoginContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwLoginContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwLoginContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwLogin(s)
	}
}

func (s *KwLoginContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwLogin(s)
	}
}

func (p *CQLParser) KwLogin() (localctx IKwLoginContext) {
	localctx = NewKwLoginContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 448, CQLParserRULE_kwLogin)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2214)
		p.Match(CQLParserK_LOGIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwMaterializedContext is an interface to support dynamic dispatch.
type IKwMaterializedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_MATERIALIZED() antlr.TerminalNode

	// IsKwMaterializedContext differentiates from other interfaces.
	IsKwMaterializedContext()
}

type KwMaterializedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwMaterializedContext() *KwMaterializedContext {
	var p = new(KwMaterializedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwMaterialized
	return p
}

func InitEmptyKwMaterializedContext(p *KwMaterializedContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwMaterialized
}

func (*KwMaterializedContext) IsKwMaterializedContext() {}

func NewKwMaterializedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwMaterializedContext {
	var p = new(KwMaterializedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwMaterialized

	return p
}

func (s *KwMaterializedContext) GetParser() antlr.Parser { return s.parser }

func (s *KwMaterializedContext) K_MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(CQLParserK_MATERIALIZED, 0)
}

func (s *KwMaterializedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwMaterializedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwMaterializedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwMaterialized(s)
	}
}

func (s *KwMaterializedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwMaterialized(s)
	}
}

func (p *CQLParser) KwMaterialized() (localctx IKwMaterializedContext) {
	localctx = NewKwMaterializedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 450, CQLParserRULE_kwMaterialized)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2216)
		p.Match(CQLParserK_MATERIALIZED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwModifyContext is an interface to support dynamic dispatch.
type IKwModifyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_MODIFY() antlr.TerminalNode

	// IsKwModifyContext differentiates from other interfaces.
	IsKwModifyContext()
}

type KwModifyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwModifyContext() *KwModifyContext {
	var p = new(KwModifyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwModify
	return p
}

func InitEmptyKwModifyContext(p *KwModifyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwModify
}

func (*KwModifyContext) IsKwModifyContext() {}

func NewKwModifyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwModifyContext {
	var p = new(KwModifyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwModify

	return p
}

func (s *KwModifyContext) GetParser() antlr.Parser { return s.parser }

func (s *KwModifyContext) K_MODIFY() antlr.TerminalNode {
	return s.GetToken(CQLParserK_MODIFY, 0)
}

func (s *KwModifyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwModifyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwModifyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwModify(s)
	}
}

func (s *KwModifyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwModify(s)
	}
}

func (p *CQLParser) KwModify() (localctx IKwModifyContext) {
	localctx = NewKwModifyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 452, CQLParserRULE_kwModify)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2218)
		p.Match(CQLParserK_MODIFY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwNosuperuserContext is an interface to support dynamic dispatch.
type IKwNosuperuserContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_NOSUPERUSER() antlr.TerminalNode

	// IsKwNosuperuserContext differentiates from other interfaces.
	IsKwNosuperuserContext()
}

type KwNosuperuserContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwNosuperuserContext() *KwNosuperuserContext {
	var p = new(KwNosuperuserContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwNosuperuser
	return p
}

func InitEmptyKwNosuperuserContext(p *KwNosuperuserContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwNosuperuser
}

func (*KwNosuperuserContext) IsKwNosuperuserContext() {}

func NewKwNosuperuserContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwNosuperuserContext {
	var p = new(KwNosuperuserContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwNosuperuser

	return p
}

func (s *KwNosuperuserContext) GetParser() antlr.Parser { return s.parser }

func (s *KwNosuperuserContext) K_NOSUPERUSER() antlr.TerminalNode {
	return s.GetToken(CQLParserK_NOSUPERUSER, 0)
}

func (s *KwNosuperuserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwNosuperuserContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwNosuperuserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwNosuperuser(s)
	}
}

func (s *KwNosuperuserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwNosuperuser(s)
	}
}

func (p *CQLParser) KwNosuperuser() (localctx IKwNosuperuserContext) {
	localctx = NewKwNosuperuserContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 454, CQLParserRULE_kwNosuperuser)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2220)
		p.Match(CQLParserK_NOSUPERUSER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwNorecursiveContext is an interface to support dynamic dispatch.
type IKwNorecursiveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_NORECURSIVE() antlr.TerminalNode

	// IsKwNorecursiveContext differentiates from other interfaces.
	IsKwNorecursiveContext()
}

type KwNorecursiveContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwNorecursiveContext() *KwNorecursiveContext {
	var p = new(KwNorecursiveContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwNorecursive
	return p
}

func InitEmptyKwNorecursiveContext(p *KwNorecursiveContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwNorecursive
}

func (*KwNorecursiveContext) IsKwNorecursiveContext() {}

func NewKwNorecursiveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwNorecursiveContext {
	var p = new(KwNorecursiveContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwNorecursive

	return p
}

func (s *KwNorecursiveContext) GetParser() antlr.Parser { return s.parser }

func (s *KwNorecursiveContext) K_NORECURSIVE() antlr.TerminalNode {
	return s.GetToken(CQLParserK_NORECURSIVE, 0)
}

func (s *KwNorecursiveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwNorecursiveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwNorecursiveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwNorecursive(s)
	}
}

func (s *KwNorecursiveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwNorecursive(s)
	}
}

func (p *CQLParser) KwNorecursive() (localctx IKwNorecursiveContext) {
	localctx = NewKwNorecursiveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 456, CQLParserRULE_kwNorecursive)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2222)
		p.Match(CQLParserK_NORECURSIVE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwNotContext is an interface to support dynamic dispatch.
type IKwNotContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_NOT() antlr.TerminalNode

	// IsKwNotContext differentiates from other interfaces.
	IsKwNotContext()
}

type KwNotContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwNotContext() *KwNotContext {
	var p = new(KwNotContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwNot
	return p
}

func InitEmptyKwNotContext(p *KwNotContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwNot
}

func (*KwNotContext) IsKwNotContext() {}

func NewKwNotContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwNotContext {
	var p = new(KwNotContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwNot

	return p
}

func (s *KwNotContext) GetParser() antlr.Parser { return s.parser }

func (s *KwNotContext) K_NOT() antlr.TerminalNode {
	return s.GetToken(CQLParserK_NOT, 0)
}

func (s *KwNotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwNotContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwNotContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwNot(s)
	}
}

func (s *KwNotContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwNot(s)
	}
}

func (p *CQLParser) KwNot() (localctx IKwNotContext) {
	localctx = NewKwNotContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 458, CQLParserRULE_kwNot)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2224)
		p.Match(CQLParserK_NOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwNullContext is an interface to support dynamic dispatch.
type IKwNullContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_NULL() antlr.TerminalNode

	// IsKwNullContext differentiates from other interfaces.
	IsKwNullContext()
}

type KwNullContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwNullContext() *KwNullContext {
	var p = new(KwNullContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwNull
	return p
}

func InitEmptyKwNullContext(p *KwNullContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwNull
}

func (*KwNullContext) IsKwNullContext() {}

func NewKwNullContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwNullContext {
	var p = new(KwNullContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwNull

	return p
}

func (s *KwNullContext) GetParser() antlr.Parser { return s.parser }

func (s *KwNullContext) K_NULL() antlr.TerminalNode {
	return s.GetToken(CQLParserK_NULL, 0)
}

func (s *KwNullContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwNullContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwNullContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwNull(s)
	}
}

func (s *KwNullContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwNull(s)
	}
}

func (p *CQLParser) KwNull() (localctx IKwNullContext) {
	localctx = NewKwNullContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 460, CQLParserRULE_kwNull)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2226)
		p.Match(CQLParserK_NULL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwOfContext is an interface to support dynamic dispatch.
type IKwOfContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_OF() antlr.TerminalNode

	// IsKwOfContext differentiates from other interfaces.
	IsKwOfContext()
}

type KwOfContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwOfContext() *KwOfContext {
	var p = new(KwOfContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwOf
	return p
}

func InitEmptyKwOfContext(p *KwOfContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwOf
}

func (*KwOfContext) IsKwOfContext() {}

func NewKwOfContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwOfContext {
	var p = new(KwOfContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwOf

	return p
}

func (s *KwOfContext) GetParser() antlr.Parser { return s.parser }

func (s *KwOfContext) K_OF() antlr.TerminalNode {
	return s.GetToken(CQLParserK_OF, 0)
}

func (s *KwOfContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwOfContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwOfContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwOf(s)
	}
}

func (s *KwOfContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwOf(s)
	}
}

func (p *CQLParser) KwOf() (localctx IKwOfContext) {
	localctx = NewKwOfContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 462, CQLParserRULE_kwOf)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2228)
		p.Match(CQLParserK_OF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwOnContext is an interface to support dynamic dispatch.
type IKwOnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_ON() antlr.TerminalNode

	// IsKwOnContext differentiates from other interfaces.
	IsKwOnContext()
}

type KwOnContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwOnContext() *KwOnContext {
	var p = new(KwOnContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwOn
	return p
}

func InitEmptyKwOnContext(p *KwOnContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwOn
}

func (*KwOnContext) IsKwOnContext() {}

func NewKwOnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwOnContext {
	var p = new(KwOnContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwOn

	return p
}

func (s *KwOnContext) GetParser() antlr.Parser { return s.parser }

func (s *KwOnContext) K_ON() antlr.TerminalNode {
	return s.GetToken(CQLParserK_ON, 0)
}

func (s *KwOnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwOnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwOnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwOn(s)
	}
}

func (s *KwOnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwOn(s)
	}
}

func (p *CQLParser) KwOn() (localctx IKwOnContext) {
	localctx = NewKwOnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 464, CQLParserRULE_kwOn)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2230)
		p.Match(CQLParserK_ON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwOptionsContext is an interface to support dynamic dispatch.
type IKwOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_OPTIONS() antlr.TerminalNode

	// IsKwOptionsContext differentiates from other interfaces.
	IsKwOptionsContext()
}

type KwOptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwOptionsContext() *KwOptionsContext {
	var p = new(KwOptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwOptions
	return p
}

func InitEmptyKwOptionsContext(p *KwOptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwOptions
}

func (*KwOptionsContext) IsKwOptionsContext() {}

func NewKwOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwOptionsContext {
	var p = new(KwOptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwOptions

	return p
}

func (s *KwOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *KwOptionsContext) K_OPTIONS() antlr.TerminalNode {
	return s.GetToken(CQLParserK_OPTIONS, 0)
}

func (s *KwOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwOptions(s)
	}
}

func (s *KwOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwOptions(s)
	}
}

func (p *CQLParser) KwOptions() (localctx IKwOptionsContext) {
	localctx = NewKwOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 466, CQLParserRULE_kwOptions)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2232)
		p.Match(CQLParserK_OPTIONS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwOrContext is an interface to support dynamic dispatch.
type IKwOrContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_OR() antlr.TerminalNode

	// IsKwOrContext differentiates from other interfaces.
	IsKwOrContext()
}

type KwOrContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwOrContext() *KwOrContext {
	var p = new(KwOrContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwOr
	return p
}

func InitEmptyKwOrContext(p *KwOrContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwOr
}

func (*KwOrContext) IsKwOrContext() {}

func NewKwOrContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwOrContext {
	var p = new(KwOrContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwOr

	return p
}

func (s *KwOrContext) GetParser() antlr.Parser { return s.parser }

func (s *KwOrContext) K_OR() antlr.TerminalNode {
	return s.GetToken(CQLParserK_OR, 0)
}

func (s *KwOrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwOrContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwOrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwOr(s)
	}
}

func (s *KwOrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwOr(s)
	}
}

func (p *CQLParser) KwOr() (localctx IKwOrContext) {
	localctx = NewKwOrContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 468, CQLParserRULE_kwOr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2234)
		p.Match(CQLParserK_OR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwOrderContext is an interface to support dynamic dispatch.
type IKwOrderContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_ORDER() antlr.TerminalNode

	// IsKwOrderContext differentiates from other interfaces.
	IsKwOrderContext()
}

type KwOrderContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwOrderContext() *KwOrderContext {
	var p = new(KwOrderContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwOrder
	return p
}

func InitEmptyKwOrderContext(p *KwOrderContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwOrder
}

func (*KwOrderContext) IsKwOrderContext() {}

func NewKwOrderContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwOrderContext {
	var p = new(KwOrderContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwOrder

	return p
}

func (s *KwOrderContext) GetParser() antlr.Parser { return s.parser }

func (s *KwOrderContext) K_ORDER() antlr.TerminalNode {
	return s.GetToken(CQLParserK_ORDER, 0)
}

func (s *KwOrderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwOrderContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwOrderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwOrder(s)
	}
}

func (s *KwOrderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwOrder(s)
	}
}

func (p *CQLParser) KwOrder() (localctx IKwOrderContext) {
	localctx = NewKwOrderContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 470, CQLParserRULE_kwOrder)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2236)
		p.Match(CQLParserK_ORDER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwPasswordContext is an interface to support dynamic dispatch.
type IKwPasswordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_PASSWORD() antlr.TerminalNode

	// IsKwPasswordContext differentiates from other interfaces.
	IsKwPasswordContext()
}

type KwPasswordContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwPasswordContext() *KwPasswordContext {
	var p = new(KwPasswordContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwPassword
	return p
}

func InitEmptyKwPasswordContext(p *KwPasswordContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwPassword
}

func (*KwPasswordContext) IsKwPasswordContext() {}

func NewKwPasswordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwPasswordContext {
	var p = new(KwPasswordContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwPassword

	return p
}

func (s *KwPasswordContext) GetParser() antlr.Parser { return s.parser }

func (s *KwPasswordContext) K_PASSWORD() antlr.TerminalNode {
	return s.GetToken(CQLParserK_PASSWORD, 0)
}

func (s *KwPasswordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwPasswordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwPasswordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwPassword(s)
	}
}

func (s *KwPasswordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwPassword(s)
	}
}

func (p *CQLParser) KwPassword() (localctx IKwPasswordContext) {
	localctx = NewKwPasswordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 472, CQLParserRULE_kwPassword)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2238)
		p.Match(CQLParserK_PASSWORD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwPrimaryContext is an interface to support dynamic dispatch.
type IKwPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_PRIMARY() antlr.TerminalNode

	// IsKwPrimaryContext differentiates from other interfaces.
	IsKwPrimaryContext()
}

type KwPrimaryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwPrimaryContext() *KwPrimaryContext {
	var p = new(KwPrimaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwPrimary
	return p
}

func InitEmptyKwPrimaryContext(p *KwPrimaryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwPrimary
}

func (*KwPrimaryContext) IsKwPrimaryContext() {}

func NewKwPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwPrimaryContext {
	var p = new(KwPrimaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwPrimary

	return p
}

func (s *KwPrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *KwPrimaryContext) K_PRIMARY() antlr.TerminalNode {
	return s.GetToken(CQLParserK_PRIMARY, 0)
}

func (s *KwPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwPrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwPrimaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwPrimary(s)
	}
}

func (s *KwPrimaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwPrimary(s)
	}
}

func (p *CQLParser) KwPrimary() (localctx IKwPrimaryContext) {
	localctx = NewKwPrimaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 474, CQLParserRULE_kwPrimary)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2240)
		p.Match(CQLParserK_PRIMARY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwRenameContext is an interface to support dynamic dispatch.
type IKwRenameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_RENAME() antlr.TerminalNode

	// IsKwRenameContext differentiates from other interfaces.
	IsKwRenameContext()
}

type KwRenameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwRenameContext() *KwRenameContext {
	var p = new(KwRenameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwRename
	return p
}

func InitEmptyKwRenameContext(p *KwRenameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwRename
}

func (*KwRenameContext) IsKwRenameContext() {}

func NewKwRenameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwRenameContext {
	var p = new(KwRenameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwRename

	return p
}

func (s *KwRenameContext) GetParser() antlr.Parser { return s.parser }

func (s *KwRenameContext) K_RENAME() antlr.TerminalNode {
	return s.GetToken(CQLParserK_RENAME, 0)
}

func (s *KwRenameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwRenameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwRenameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwRename(s)
	}
}

func (s *KwRenameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwRename(s)
	}
}

func (p *CQLParser) KwRename() (localctx IKwRenameContext) {
	localctx = NewKwRenameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 476, CQLParserRULE_kwRename)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2242)
		p.Match(CQLParserK_RENAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwReplaceContext is an interface to support dynamic dispatch.
type IKwReplaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_REPLACE() antlr.TerminalNode

	// IsKwReplaceContext differentiates from other interfaces.
	IsKwReplaceContext()
}

type KwReplaceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwReplaceContext() *KwReplaceContext {
	var p = new(KwReplaceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwReplace
	return p
}

func InitEmptyKwReplaceContext(p *KwReplaceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwReplace
}

func (*KwReplaceContext) IsKwReplaceContext() {}

func NewKwReplaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwReplaceContext {
	var p = new(KwReplaceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwReplace

	return p
}

func (s *KwReplaceContext) GetParser() antlr.Parser { return s.parser }

func (s *KwReplaceContext) K_REPLACE() antlr.TerminalNode {
	return s.GetToken(CQLParserK_REPLACE, 0)
}

func (s *KwReplaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwReplaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwReplaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwReplace(s)
	}
}

func (s *KwReplaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwReplace(s)
	}
}

func (p *CQLParser) KwReplace() (localctx IKwReplaceContext) {
	localctx = NewKwReplaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 478, CQLParserRULE_kwReplace)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2244)
		p.Match(CQLParserK_REPLACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwReplicationContext is an interface to support dynamic dispatch.
type IKwReplicationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_REPLICATION() antlr.TerminalNode

	// IsKwReplicationContext differentiates from other interfaces.
	IsKwReplicationContext()
}

type KwReplicationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwReplicationContext() *KwReplicationContext {
	var p = new(KwReplicationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwReplication
	return p
}

func InitEmptyKwReplicationContext(p *KwReplicationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwReplication
}

func (*KwReplicationContext) IsKwReplicationContext() {}

func NewKwReplicationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwReplicationContext {
	var p = new(KwReplicationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwReplication

	return p
}

func (s *KwReplicationContext) GetParser() antlr.Parser { return s.parser }

func (s *KwReplicationContext) K_REPLICATION() antlr.TerminalNode {
	return s.GetToken(CQLParserK_REPLICATION, 0)
}

func (s *KwReplicationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwReplicationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwReplicationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwReplication(s)
	}
}

func (s *KwReplicationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwReplication(s)
	}
}

func (p *CQLParser) KwReplication() (localctx IKwReplicationContext) {
	localctx = NewKwReplicationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 480, CQLParserRULE_kwReplication)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2246)
		p.Match(CQLParserK_REPLICATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwReturnsContext is an interface to support dynamic dispatch.
type IKwReturnsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_RETURNS() antlr.TerminalNode

	// IsKwReturnsContext differentiates from other interfaces.
	IsKwReturnsContext()
}

type KwReturnsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwReturnsContext() *KwReturnsContext {
	var p = new(KwReturnsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwReturns
	return p
}

func InitEmptyKwReturnsContext(p *KwReturnsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwReturns
}

func (*KwReturnsContext) IsKwReturnsContext() {}

func NewKwReturnsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwReturnsContext {
	var p = new(KwReturnsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwReturns

	return p
}

func (s *KwReturnsContext) GetParser() antlr.Parser { return s.parser }

func (s *KwReturnsContext) K_RETURNS() antlr.TerminalNode {
	return s.GetToken(CQLParserK_RETURNS, 0)
}

func (s *KwReturnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwReturnsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwReturnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwReturns(s)
	}
}

func (s *KwReturnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwReturns(s)
	}
}

func (p *CQLParser) KwReturns() (localctx IKwReturnsContext) {
	localctx = NewKwReturnsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 482, CQLParserRULE_kwReturns)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2248)
		p.Match(CQLParserK_RETURNS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwRoleContext is an interface to support dynamic dispatch.
type IKwRoleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_ROLE() antlr.TerminalNode

	// IsKwRoleContext differentiates from other interfaces.
	IsKwRoleContext()
}

type KwRoleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwRoleContext() *KwRoleContext {
	var p = new(KwRoleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwRole
	return p
}

func InitEmptyKwRoleContext(p *KwRoleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwRole
}

func (*KwRoleContext) IsKwRoleContext() {}

func NewKwRoleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwRoleContext {
	var p = new(KwRoleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwRole

	return p
}

func (s *KwRoleContext) GetParser() antlr.Parser { return s.parser }

func (s *KwRoleContext) K_ROLE() antlr.TerminalNode {
	return s.GetToken(CQLParserK_ROLE, 0)
}

func (s *KwRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwRoleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwRoleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwRole(s)
	}
}

func (s *KwRoleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwRole(s)
	}
}

func (p *CQLParser) KwRole() (localctx IKwRoleContext) {
	localctx = NewKwRoleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 484, CQLParserRULE_kwRole)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2250)
		p.Match(CQLParserK_ROLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwRolesContext is an interface to support dynamic dispatch.
type IKwRolesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_ROLES() antlr.TerminalNode

	// IsKwRolesContext differentiates from other interfaces.
	IsKwRolesContext()
}

type KwRolesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwRolesContext() *KwRolesContext {
	var p = new(KwRolesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwRoles
	return p
}

func InitEmptyKwRolesContext(p *KwRolesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwRoles
}

func (*KwRolesContext) IsKwRolesContext() {}

func NewKwRolesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwRolesContext {
	var p = new(KwRolesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwRoles

	return p
}

func (s *KwRolesContext) GetParser() antlr.Parser { return s.parser }

func (s *KwRolesContext) K_ROLES() antlr.TerminalNode {
	return s.GetToken(CQLParserK_ROLES, 0)
}

func (s *KwRolesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwRolesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwRolesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwRoles(s)
	}
}

func (s *KwRolesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwRoles(s)
	}
}

func (p *CQLParser) KwRoles() (localctx IKwRolesContext) {
	localctx = NewKwRolesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 486, CQLParserRULE_kwRoles)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2252)
		p.Match(CQLParserK_ROLES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwSelectContext is an interface to support dynamic dispatch.
type IKwSelectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_SELECT() antlr.TerminalNode

	// IsKwSelectContext differentiates from other interfaces.
	IsKwSelectContext()
}

type KwSelectContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwSelectContext() *KwSelectContext {
	var p = new(KwSelectContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwSelect
	return p
}

func InitEmptyKwSelectContext(p *KwSelectContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwSelect
}

func (*KwSelectContext) IsKwSelectContext() {}

func NewKwSelectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwSelectContext {
	var p = new(KwSelectContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwSelect

	return p
}

func (s *KwSelectContext) GetParser() antlr.Parser { return s.parser }

func (s *KwSelectContext) K_SELECT() antlr.TerminalNode {
	return s.GetToken(CQLParserK_SELECT, 0)
}

func (s *KwSelectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwSelectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwSelectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwSelect(s)
	}
}

func (s *KwSelectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwSelect(s)
	}
}

func (p *CQLParser) KwSelect() (localctx IKwSelectContext) {
	localctx = NewKwSelectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 488, CQLParserRULE_kwSelect)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2254)
		p.Match(CQLParserK_SELECT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwSetContext is an interface to support dynamic dispatch.
type IKwSetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_SET() antlr.TerminalNode

	// IsKwSetContext differentiates from other interfaces.
	IsKwSetContext()
}

type KwSetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwSetContext() *KwSetContext {
	var p = new(KwSetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwSet
	return p
}

func InitEmptyKwSetContext(p *KwSetContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwSet
}

func (*KwSetContext) IsKwSetContext() {}

func NewKwSetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwSetContext {
	var p = new(KwSetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwSet

	return p
}

func (s *KwSetContext) GetParser() antlr.Parser { return s.parser }

func (s *KwSetContext) K_SET() antlr.TerminalNode {
	return s.GetToken(CQLParserK_SET, 0)
}

func (s *KwSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwSetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwSet(s)
	}
}

func (s *KwSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwSet(s)
	}
}

func (p *CQLParser) KwSet() (localctx IKwSetContext) {
	localctx = NewKwSetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 490, CQLParserRULE_kwSet)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2256)
		p.Match(CQLParserK_SET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwSfuncContext is an interface to support dynamic dispatch.
type IKwSfuncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_SFUNC() antlr.TerminalNode

	// IsKwSfuncContext differentiates from other interfaces.
	IsKwSfuncContext()
}

type KwSfuncContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwSfuncContext() *KwSfuncContext {
	var p = new(KwSfuncContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwSfunc
	return p
}

func InitEmptyKwSfuncContext(p *KwSfuncContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwSfunc
}

func (*KwSfuncContext) IsKwSfuncContext() {}

func NewKwSfuncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwSfuncContext {
	var p = new(KwSfuncContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwSfunc

	return p
}

func (s *KwSfuncContext) GetParser() antlr.Parser { return s.parser }

func (s *KwSfuncContext) K_SFUNC() antlr.TerminalNode {
	return s.GetToken(CQLParserK_SFUNC, 0)
}

func (s *KwSfuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwSfuncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwSfuncContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwSfunc(s)
	}
}

func (s *KwSfuncContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwSfunc(s)
	}
}

func (p *CQLParser) KwSfunc() (localctx IKwSfuncContext) {
	localctx = NewKwSfuncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 492, CQLParserRULE_kwSfunc)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2258)
		p.Match(CQLParserK_SFUNC)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwStorageContext is an interface to support dynamic dispatch.
type IKwStorageContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_STORAGE() antlr.TerminalNode

	// IsKwStorageContext differentiates from other interfaces.
	IsKwStorageContext()
}

type KwStorageContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwStorageContext() *KwStorageContext {
	var p = new(KwStorageContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwStorage
	return p
}

func InitEmptyKwStorageContext(p *KwStorageContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwStorage
}

func (*KwStorageContext) IsKwStorageContext() {}

func NewKwStorageContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwStorageContext {
	var p = new(KwStorageContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwStorage

	return p
}

func (s *KwStorageContext) GetParser() antlr.Parser { return s.parser }

func (s *KwStorageContext) K_STORAGE() antlr.TerminalNode {
	return s.GetToken(CQLParserK_STORAGE, 0)
}

func (s *KwStorageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwStorageContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwStorageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwStorage(s)
	}
}

func (s *KwStorageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwStorage(s)
	}
}

func (p *CQLParser) KwStorage() (localctx IKwStorageContext) {
	localctx = NewKwStorageContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 494, CQLParserRULE_kwStorage)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2260)
		p.Match(CQLParserK_STORAGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwStypeContext is an interface to support dynamic dispatch.
type IKwStypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_STYPE() antlr.TerminalNode

	// IsKwStypeContext differentiates from other interfaces.
	IsKwStypeContext()
}

type KwStypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwStypeContext() *KwStypeContext {
	var p = new(KwStypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwStype
	return p
}

func InitEmptyKwStypeContext(p *KwStypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwStype
}

func (*KwStypeContext) IsKwStypeContext() {}

func NewKwStypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwStypeContext {
	var p = new(KwStypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwStype

	return p
}

func (s *KwStypeContext) GetParser() antlr.Parser { return s.parser }

func (s *KwStypeContext) K_STYPE() antlr.TerminalNode {
	return s.GetToken(CQLParserK_STYPE, 0)
}

func (s *KwStypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwStypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwStypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwStype(s)
	}
}

func (s *KwStypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwStype(s)
	}
}

func (p *CQLParser) KwStype() (localctx IKwStypeContext) {
	localctx = NewKwStypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 496, CQLParserRULE_kwStype)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2262)
		p.Match(CQLParserK_STYPE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwSuperuserContext is an interface to support dynamic dispatch.
type IKwSuperuserContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_SUPERUSER() antlr.TerminalNode

	// IsKwSuperuserContext differentiates from other interfaces.
	IsKwSuperuserContext()
}

type KwSuperuserContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwSuperuserContext() *KwSuperuserContext {
	var p = new(KwSuperuserContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwSuperuser
	return p
}

func InitEmptyKwSuperuserContext(p *KwSuperuserContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwSuperuser
}

func (*KwSuperuserContext) IsKwSuperuserContext() {}

func NewKwSuperuserContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwSuperuserContext {
	var p = new(KwSuperuserContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwSuperuser

	return p
}

func (s *KwSuperuserContext) GetParser() antlr.Parser { return s.parser }

func (s *KwSuperuserContext) K_SUPERUSER() antlr.TerminalNode {
	return s.GetToken(CQLParserK_SUPERUSER, 0)
}

func (s *KwSuperuserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwSuperuserContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwSuperuserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwSuperuser(s)
	}
}

func (s *KwSuperuserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwSuperuser(s)
	}
}

func (p *CQLParser) KwSuperuser() (localctx IKwSuperuserContext) {
	localctx = NewKwSuperuserContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 498, CQLParserRULE_kwSuperuser)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2264)
		p.Match(CQLParserK_SUPERUSER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwTableContext is an interface to support dynamic dispatch.
type IKwTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_TABLE() antlr.TerminalNode

	// IsKwTableContext differentiates from other interfaces.
	IsKwTableContext()
}

type KwTableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwTableContext() *KwTableContext {
	var p = new(KwTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwTable
	return p
}

func InitEmptyKwTableContext(p *KwTableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwTable
}

func (*KwTableContext) IsKwTableContext() {}

func NewKwTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwTableContext {
	var p = new(KwTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwTable

	return p
}

func (s *KwTableContext) GetParser() antlr.Parser { return s.parser }

func (s *KwTableContext) K_TABLE() antlr.TerminalNode {
	return s.GetToken(CQLParserK_TABLE, 0)
}

func (s *KwTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwTable(s)
	}
}

func (s *KwTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwTable(s)
	}
}

func (p *CQLParser) KwTable() (localctx IKwTableContext) {
	localctx = NewKwTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 500, CQLParserRULE_kwTable)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2266)
		p.Match(CQLParserK_TABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwTimestampContext is an interface to support dynamic dispatch.
type IKwTimestampContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_TIMESTAMP() antlr.TerminalNode

	// IsKwTimestampContext differentiates from other interfaces.
	IsKwTimestampContext()
}

type KwTimestampContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwTimestampContext() *KwTimestampContext {
	var p = new(KwTimestampContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwTimestamp
	return p
}

func InitEmptyKwTimestampContext(p *KwTimestampContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwTimestamp
}

func (*KwTimestampContext) IsKwTimestampContext() {}

func NewKwTimestampContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwTimestampContext {
	var p = new(KwTimestampContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwTimestamp

	return p
}

func (s *KwTimestampContext) GetParser() antlr.Parser { return s.parser }

func (s *KwTimestampContext) K_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(CQLParserK_TIMESTAMP, 0)
}

func (s *KwTimestampContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwTimestampContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwTimestampContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwTimestamp(s)
	}
}

func (s *KwTimestampContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwTimestamp(s)
	}
}

func (p *CQLParser) KwTimestamp() (localctx IKwTimestampContext) {
	localctx = NewKwTimestampContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 502, CQLParserRULE_kwTimestamp)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2268)
		p.Match(CQLParserK_TIMESTAMP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwToContext is an interface to support dynamic dispatch.
type IKwToContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_TO() antlr.TerminalNode

	// IsKwToContext differentiates from other interfaces.
	IsKwToContext()
}

type KwToContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwToContext() *KwToContext {
	var p = new(KwToContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwTo
	return p
}

func InitEmptyKwToContext(p *KwToContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwTo
}

func (*KwToContext) IsKwToContext() {}

func NewKwToContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwToContext {
	var p = new(KwToContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwTo

	return p
}

func (s *KwToContext) GetParser() antlr.Parser { return s.parser }

func (s *KwToContext) K_TO() antlr.TerminalNode {
	return s.GetToken(CQLParserK_TO, 0)
}

func (s *KwToContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwToContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwToContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwTo(s)
	}
}

func (s *KwToContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwTo(s)
	}
}

func (p *CQLParser) KwTo() (localctx IKwToContext) {
	localctx = NewKwToContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 504, CQLParserRULE_kwTo)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2270)
		p.Match(CQLParserK_TO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwTriggerContext is an interface to support dynamic dispatch.
type IKwTriggerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_TRIGGER() antlr.TerminalNode

	// IsKwTriggerContext differentiates from other interfaces.
	IsKwTriggerContext()
}

type KwTriggerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwTriggerContext() *KwTriggerContext {
	var p = new(KwTriggerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwTrigger
	return p
}

func InitEmptyKwTriggerContext(p *KwTriggerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwTrigger
}

func (*KwTriggerContext) IsKwTriggerContext() {}

func NewKwTriggerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwTriggerContext {
	var p = new(KwTriggerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwTrigger

	return p
}

func (s *KwTriggerContext) GetParser() antlr.Parser { return s.parser }

func (s *KwTriggerContext) K_TRIGGER() antlr.TerminalNode {
	return s.GetToken(CQLParserK_TRIGGER, 0)
}

func (s *KwTriggerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwTriggerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwTriggerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwTrigger(s)
	}
}

func (s *KwTriggerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwTrigger(s)
	}
}

func (p *CQLParser) KwTrigger() (localctx IKwTriggerContext) {
	localctx = NewKwTriggerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 506, CQLParserRULE_kwTrigger)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2272)
		p.Match(CQLParserK_TRIGGER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwTruncateContext is an interface to support dynamic dispatch.
type IKwTruncateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_TRUNCATE() antlr.TerminalNode

	// IsKwTruncateContext differentiates from other interfaces.
	IsKwTruncateContext()
}

type KwTruncateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwTruncateContext() *KwTruncateContext {
	var p = new(KwTruncateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwTruncate
	return p
}

func InitEmptyKwTruncateContext(p *KwTruncateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwTruncate
}

func (*KwTruncateContext) IsKwTruncateContext() {}

func NewKwTruncateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwTruncateContext {
	var p = new(KwTruncateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwTruncate

	return p
}

func (s *KwTruncateContext) GetParser() antlr.Parser { return s.parser }

func (s *KwTruncateContext) K_TRUNCATE() antlr.TerminalNode {
	return s.GetToken(CQLParserK_TRUNCATE, 0)
}

func (s *KwTruncateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwTruncateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwTruncateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwTruncate(s)
	}
}

func (s *KwTruncateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwTruncate(s)
	}
}

func (p *CQLParser) KwTruncate() (localctx IKwTruncateContext) {
	localctx = NewKwTruncateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 508, CQLParserRULE_kwTruncate)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2274)
		p.Match(CQLParserK_TRUNCATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwTtlContext is an interface to support dynamic dispatch.
type IKwTtlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_TTL() antlr.TerminalNode

	// IsKwTtlContext differentiates from other interfaces.
	IsKwTtlContext()
}

type KwTtlContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwTtlContext() *KwTtlContext {
	var p = new(KwTtlContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwTtl
	return p
}

func InitEmptyKwTtlContext(p *KwTtlContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwTtl
}

func (*KwTtlContext) IsKwTtlContext() {}

func NewKwTtlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwTtlContext {
	var p = new(KwTtlContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwTtl

	return p
}

func (s *KwTtlContext) GetParser() antlr.Parser { return s.parser }

func (s *KwTtlContext) K_TTL() antlr.TerminalNode {
	return s.GetToken(CQLParserK_TTL, 0)
}

func (s *KwTtlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwTtlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwTtlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwTtl(s)
	}
}

func (s *KwTtlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwTtl(s)
	}
}

func (p *CQLParser) KwTtl() (localctx IKwTtlContext) {
	localctx = NewKwTtlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 510, CQLParserRULE_kwTtl)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2276)
		p.Match(CQLParserK_TTL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwTypeContext is an interface to support dynamic dispatch.
type IKwTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_TYPE() antlr.TerminalNode

	// IsKwTypeContext differentiates from other interfaces.
	IsKwTypeContext()
}

type KwTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwTypeContext() *KwTypeContext {
	var p = new(KwTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwType
	return p
}

func InitEmptyKwTypeContext(p *KwTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwType
}

func (*KwTypeContext) IsKwTypeContext() {}

func NewKwTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwTypeContext {
	var p = new(KwTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwType

	return p
}

func (s *KwTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *KwTypeContext) K_TYPE() antlr.TerminalNode {
	return s.GetToken(CQLParserK_TYPE, 0)
}

func (s *KwTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwType(s)
	}
}

func (s *KwTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwType(s)
	}
}

func (p *CQLParser) KwType() (localctx IKwTypeContext) {
	localctx = NewKwTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 512, CQLParserRULE_kwType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2278)
		p.Match(CQLParserK_TYPE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwUnloggedContext is an interface to support dynamic dispatch.
type IKwUnloggedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_UNLOGGED() antlr.TerminalNode

	// IsKwUnloggedContext differentiates from other interfaces.
	IsKwUnloggedContext()
}

type KwUnloggedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwUnloggedContext() *KwUnloggedContext {
	var p = new(KwUnloggedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwUnlogged
	return p
}

func InitEmptyKwUnloggedContext(p *KwUnloggedContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwUnlogged
}

func (*KwUnloggedContext) IsKwUnloggedContext() {}

func NewKwUnloggedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwUnloggedContext {
	var p = new(KwUnloggedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwUnlogged

	return p
}

func (s *KwUnloggedContext) GetParser() antlr.Parser { return s.parser }

func (s *KwUnloggedContext) K_UNLOGGED() antlr.TerminalNode {
	return s.GetToken(CQLParserK_UNLOGGED, 0)
}

func (s *KwUnloggedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwUnloggedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwUnloggedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwUnlogged(s)
	}
}

func (s *KwUnloggedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwUnlogged(s)
	}
}

func (p *CQLParser) KwUnlogged() (localctx IKwUnloggedContext) {
	localctx = NewKwUnloggedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 514, CQLParserRULE_kwUnlogged)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2280)
		p.Match(CQLParserK_UNLOGGED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwUpdateContext is an interface to support dynamic dispatch.
type IKwUpdateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_UPDATE() antlr.TerminalNode

	// IsKwUpdateContext differentiates from other interfaces.
	IsKwUpdateContext()
}

type KwUpdateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwUpdateContext() *KwUpdateContext {
	var p = new(KwUpdateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwUpdate
	return p
}

func InitEmptyKwUpdateContext(p *KwUpdateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwUpdate
}

func (*KwUpdateContext) IsKwUpdateContext() {}

func NewKwUpdateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwUpdateContext {
	var p = new(KwUpdateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwUpdate

	return p
}

func (s *KwUpdateContext) GetParser() antlr.Parser { return s.parser }

func (s *KwUpdateContext) K_UPDATE() antlr.TerminalNode {
	return s.GetToken(CQLParserK_UPDATE, 0)
}

func (s *KwUpdateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwUpdateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwUpdateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwUpdate(s)
	}
}

func (s *KwUpdateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwUpdate(s)
	}
}

func (p *CQLParser) KwUpdate() (localctx IKwUpdateContext) {
	localctx = NewKwUpdateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 516, CQLParserRULE_kwUpdate)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2282)
		p.Match(CQLParserK_UPDATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwUseContext is an interface to support dynamic dispatch.
type IKwUseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_USE() antlr.TerminalNode

	// IsKwUseContext differentiates from other interfaces.
	IsKwUseContext()
}

type KwUseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwUseContext() *KwUseContext {
	var p = new(KwUseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwUse
	return p
}

func InitEmptyKwUseContext(p *KwUseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwUse
}

func (*KwUseContext) IsKwUseContext() {}

func NewKwUseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwUseContext {
	var p = new(KwUseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwUse

	return p
}

func (s *KwUseContext) GetParser() antlr.Parser { return s.parser }

func (s *KwUseContext) K_USE() antlr.TerminalNode {
	return s.GetToken(CQLParserK_USE, 0)
}

func (s *KwUseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwUseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwUseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwUse(s)
	}
}

func (s *KwUseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwUse(s)
	}
}

func (p *CQLParser) KwUse() (localctx IKwUseContext) {
	localctx = NewKwUseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 518, CQLParserRULE_kwUse)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2284)
		p.Match(CQLParserK_USE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwUserContext is an interface to support dynamic dispatch.
type IKwUserContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_USER() antlr.TerminalNode

	// IsKwUserContext differentiates from other interfaces.
	IsKwUserContext()
}

type KwUserContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwUserContext() *KwUserContext {
	var p = new(KwUserContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwUser
	return p
}

func InitEmptyKwUserContext(p *KwUserContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwUser
}

func (*KwUserContext) IsKwUserContext() {}

func NewKwUserContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwUserContext {
	var p = new(KwUserContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwUser

	return p
}

func (s *KwUserContext) GetParser() antlr.Parser { return s.parser }

func (s *KwUserContext) K_USER() antlr.TerminalNode {
	return s.GetToken(CQLParserK_USER, 0)
}

func (s *KwUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwUserContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwUser(s)
	}
}

func (s *KwUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwUser(s)
	}
}

func (p *CQLParser) KwUser() (localctx IKwUserContext) {
	localctx = NewKwUserContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 520, CQLParserRULE_kwUser)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2286)
		p.Match(CQLParserK_USER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwUsingContext is an interface to support dynamic dispatch.
type IKwUsingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_USING() antlr.TerminalNode

	// IsKwUsingContext differentiates from other interfaces.
	IsKwUsingContext()
}

type KwUsingContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwUsingContext() *KwUsingContext {
	var p = new(KwUsingContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwUsing
	return p
}

func InitEmptyKwUsingContext(p *KwUsingContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwUsing
}

func (*KwUsingContext) IsKwUsingContext() {}

func NewKwUsingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwUsingContext {
	var p = new(KwUsingContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwUsing

	return p
}

func (s *KwUsingContext) GetParser() antlr.Parser { return s.parser }

func (s *KwUsingContext) K_USING() antlr.TerminalNode {
	return s.GetToken(CQLParserK_USING, 0)
}

func (s *KwUsingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwUsingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwUsingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwUsing(s)
	}
}

func (s *KwUsingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwUsing(s)
	}
}

func (p *CQLParser) KwUsing() (localctx IKwUsingContext) {
	localctx = NewKwUsingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 522, CQLParserRULE_kwUsing)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2288)
		p.Match(CQLParserK_USING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwValuesContext is an interface to support dynamic dispatch.
type IKwValuesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_VALUES() antlr.TerminalNode

	// IsKwValuesContext differentiates from other interfaces.
	IsKwValuesContext()
}

type KwValuesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwValuesContext() *KwValuesContext {
	var p = new(KwValuesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwValues
	return p
}

func InitEmptyKwValuesContext(p *KwValuesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwValues
}

func (*KwValuesContext) IsKwValuesContext() {}

func NewKwValuesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwValuesContext {
	var p = new(KwValuesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwValues

	return p
}

func (s *KwValuesContext) GetParser() antlr.Parser { return s.parser }

func (s *KwValuesContext) K_VALUES() antlr.TerminalNode {
	return s.GetToken(CQLParserK_VALUES, 0)
}

func (s *KwValuesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwValuesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwValuesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwValues(s)
	}
}

func (s *KwValuesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwValues(s)
	}
}

func (p *CQLParser) KwValues() (localctx IKwValuesContext) {
	localctx = NewKwValuesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 524, CQLParserRULE_kwValues)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2290)
		p.Match(CQLParserK_VALUES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwViewContext is an interface to support dynamic dispatch.
type IKwViewContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_VIEW() antlr.TerminalNode

	// IsKwViewContext differentiates from other interfaces.
	IsKwViewContext()
}

type KwViewContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwViewContext() *KwViewContext {
	var p = new(KwViewContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwView
	return p
}

func InitEmptyKwViewContext(p *KwViewContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwView
}

func (*KwViewContext) IsKwViewContext() {}

func NewKwViewContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwViewContext {
	var p = new(KwViewContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwView

	return p
}

func (s *KwViewContext) GetParser() antlr.Parser { return s.parser }

func (s *KwViewContext) K_VIEW() antlr.TerminalNode {
	return s.GetToken(CQLParserK_VIEW, 0)
}

func (s *KwViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwViewContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwView(s)
	}
}

func (s *KwViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwView(s)
	}
}

func (p *CQLParser) KwView() (localctx IKwViewContext) {
	localctx = NewKwViewContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 526, CQLParserRULE_kwView)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2292)
		p.Match(CQLParserK_VIEW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwWhereContext is an interface to support dynamic dispatch.
type IKwWhereContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_WHERE() antlr.TerminalNode

	// IsKwWhereContext differentiates from other interfaces.
	IsKwWhereContext()
}

type KwWhereContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwWhereContext() *KwWhereContext {
	var p = new(KwWhereContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwWhere
	return p
}

func InitEmptyKwWhereContext(p *KwWhereContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwWhere
}

func (*KwWhereContext) IsKwWhereContext() {}

func NewKwWhereContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwWhereContext {
	var p = new(KwWhereContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwWhere

	return p
}

func (s *KwWhereContext) GetParser() antlr.Parser { return s.parser }

func (s *KwWhereContext) K_WHERE() antlr.TerminalNode {
	return s.GetToken(CQLParserK_WHERE, 0)
}

func (s *KwWhereContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwWhereContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwWhereContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwWhere(s)
	}
}

func (s *KwWhereContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwWhere(s)
	}
}

func (p *CQLParser) KwWhere() (localctx IKwWhereContext) {
	localctx = NewKwWhereContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 528, CQLParserRULE_kwWhere)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2294)
		p.Match(CQLParserK_WHERE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwWithContext is an interface to support dynamic dispatch.
type IKwWithContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_WITH() antlr.TerminalNode

	// IsKwWithContext differentiates from other interfaces.
	IsKwWithContext()
}

type KwWithContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwWithContext() *KwWithContext {
	var p = new(KwWithContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwWith
	return p
}

func InitEmptyKwWithContext(p *KwWithContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwWith
}

func (*KwWithContext) IsKwWithContext() {}

func NewKwWithContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwWithContext {
	var p = new(KwWithContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwWith

	return p
}

func (s *KwWithContext) GetParser() antlr.Parser { return s.parser }

func (s *KwWithContext) K_WITH() antlr.TerminalNode {
	return s.GetToken(CQLParserK_WITH, 0)
}

func (s *KwWithContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwWithContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwWithContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwWith(s)
	}
}

func (s *KwWithContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwWith(s)
	}
}

func (p *CQLParser) KwWith() (localctx IKwWithContext) {
	localctx = NewKwWithContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 530, CQLParserRULE_kwWith)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2296)
		p.Match(CQLParserK_WITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKwRevokeContext is an interface to support dynamic dispatch.
type IKwRevokeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	K_REVOKE() antlr.TerminalNode

	// IsKwRevokeContext differentiates from other interfaces.
	IsKwRevokeContext()
}

type KwRevokeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKwRevokeContext() *KwRevokeContext {
	var p = new(KwRevokeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwRevoke
	return p
}

func InitEmptyKwRevokeContext(p *KwRevokeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_kwRevoke
}

func (*KwRevokeContext) IsKwRevokeContext() {}

func NewKwRevokeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KwRevokeContext {
	var p = new(KwRevokeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_kwRevoke

	return p
}

func (s *KwRevokeContext) GetParser() antlr.Parser { return s.parser }

func (s *KwRevokeContext) K_REVOKE() antlr.TerminalNode {
	return s.GetToken(CQLParserK_REVOKE, 0)
}

func (s *KwRevokeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KwRevokeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KwRevokeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterKwRevoke(s)
	}
}

func (s *KwRevokeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitKwRevoke(s)
	}
}

func (p *CQLParser) KwRevoke() (localctx IKwRevokeContext) {
	localctx = NewKwRevokeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 532, CQLParserRULE_kwRevoke)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2298)
		p.Match(CQLParserK_REVOKE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISyntaxBracketLrContext is an interface to support dynamic dispatch.
type ISyntaxBracketLrContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LR_BRACKET() antlr.TerminalNode

	// IsSyntaxBracketLrContext differentiates from other interfaces.
	IsSyntaxBracketLrContext()
}

type SyntaxBracketLrContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySyntaxBracketLrContext() *SyntaxBracketLrContext {
	var p = new(SyntaxBracketLrContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_syntaxBracketLr
	return p
}

func InitEmptySyntaxBracketLrContext(p *SyntaxBracketLrContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_syntaxBracketLr
}

func (*SyntaxBracketLrContext) IsSyntaxBracketLrContext() {}

func NewSyntaxBracketLrContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SyntaxBracketLrContext {
	var p = new(SyntaxBracketLrContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_syntaxBracketLr

	return p
}

func (s *SyntaxBracketLrContext) GetParser() antlr.Parser { return s.parser }

func (s *SyntaxBracketLrContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(CQLParserLR_BRACKET, 0)
}

func (s *SyntaxBracketLrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SyntaxBracketLrContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SyntaxBracketLrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterSyntaxBracketLr(s)
	}
}

func (s *SyntaxBracketLrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitSyntaxBracketLr(s)
	}
}

func (p *CQLParser) SyntaxBracketLr() (localctx ISyntaxBracketLrContext) {
	localctx = NewSyntaxBracketLrContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 534, CQLParserRULE_syntaxBracketLr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2300)
		p.Match(CQLParserLR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISyntaxBracketRrContext is an interface to support dynamic dispatch.
type ISyntaxBracketRrContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RR_BRACKET() antlr.TerminalNode

	// IsSyntaxBracketRrContext differentiates from other interfaces.
	IsSyntaxBracketRrContext()
}

type SyntaxBracketRrContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySyntaxBracketRrContext() *SyntaxBracketRrContext {
	var p = new(SyntaxBracketRrContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_syntaxBracketRr
	return p
}

func InitEmptySyntaxBracketRrContext(p *SyntaxBracketRrContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_syntaxBracketRr
}

func (*SyntaxBracketRrContext) IsSyntaxBracketRrContext() {}

func NewSyntaxBracketRrContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SyntaxBracketRrContext {
	var p = new(SyntaxBracketRrContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_syntaxBracketRr

	return p
}

func (s *SyntaxBracketRrContext) GetParser() antlr.Parser { return s.parser }

func (s *SyntaxBracketRrContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(CQLParserRR_BRACKET, 0)
}

func (s *SyntaxBracketRrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SyntaxBracketRrContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SyntaxBracketRrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterSyntaxBracketRr(s)
	}
}

func (s *SyntaxBracketRrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitSyntaxBracketRr(s)
	}
}

func (p *CQLParser) SyntaxBracketRr() (localctx ISyntaxBracketRrContext) {
	localctx = NewSyntaxBracketRrContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 536, CQLParserRULE_syntaxBracketRr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2302)
		p.Match(CQLParserRR_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISyntaxBracketLcContext is an interface to support dynamic dispatch.
type ISyntaxBracketLcContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LC_BRACKET() antlr.TerminalNode

	// IsSyntaxBracketLcContext differentiates from other interfaces.
	IsSyntaxBracketLcContext()
}

type SyntaxBracketLcContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySyntaxBracketLcContext() *SyntaxBracketLcContext {
	var p = new(SyntaxBracketLcContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_syntaxBracketLc
	return p
}

func InitEmptySyntaxBracketLcContext(p *SyntaxBracketLcContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_syntaxBracketLc
}

func (*SyntaxBracketLcContext) IsSyntaxBracketLcContext() {}

func NewSyntaxBracketLcContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SyntaxBracketLcContext {
	var p = new(SyntaxBracketLcContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_syntaxBracketLc

	return p
}

func (s *SyntaxBracketLcContext) GetParser() antlr.Parser { return s.parser }

func (s *SyntaxBracketLcContext) LC_BRACKET() antlr.TerminalNode {
	return s.GetToken(CQLParserLC_BRACKET, 0)
}

func (s *SyntaxBracketLcContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SyntaxBracketLcContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SyntaxBracketLcContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterSyntaxBracketLc(s)
	}
}

func (s *SyntaxBracketLcContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitSyntaxBracketLc(s)
	}
}

func (p *CQLParser) SyntaxBracketLc() (localctx ISyntaxBracketLcContext) {
	localctx = NewSyntaxBracketLcContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 538, CQLParserRULE_syntaxBracketLc)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2304)
		p.Match(CQLParserLC_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISyntaxBracketRcContext is an interface to support dynamic dispatch.
type ISyntaxBracketRcContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RC_BRACKET() antlr.TerminalNode

	// IsSyntaxBracketRcContext differentiates from other interfaces.
	IsSyntaxBracketRcContext()
}

type SyntaxBracketRcContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySyntaxBracketRcContext() *SyntaxBracketRcContext {
	var p = new(SyntaxBracketRcContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_syntaxBracketRc
	return p
}

func InitEmptySyntaxBracketRcContext(p *SyntaxBracketRcContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_syntaxBracketRc
}

func (*SyntaxBracketRcContext) IsSyntaxBracketRcContext() {}

func NewSyntaxBracketRcContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SyntaxBracketRcContext {
	var p = new(SyntaxBracketRcContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_syntaxBracketRc

	return p
}

func (s *SyntaxBracketRcContext) GetParser() antlr.Parser { return s.parser }

func (s *SyntaxBracketRcContext) RC_BRACKET() antlr.TerminalNode {
	return s.GetToken(CQLParserRC_BRACKET, 0)
}

func (s *SyntaxBracketRcContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SyntaxBracketRcContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SyntaxBracketRcContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterSyntaxBracketRc(s)
	}
}

func (s *SyntaxBracketRcContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitSyntaxBracketRc(s)
	}
}

func (p *CQLParser) SyntaxBracketRc() (localctx ISyntaxBracketRcContext) {
	localctx = NewSyntaxBracketRcContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 540, CQLParserRULE_syntaxBracketRc)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2306)
		p.Match(CQLParserRC_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISyntaxBracketLaContext is an interface to support dynamic dispatch.
type ISyntaxBracketLaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPERATOR_LT() antlr.TerminalNode

	// IsSyntaxBracketLaContext differentiates from other interfaces.
	IsSyntaxBracketLaContext()
}

type SyntaxBracketLaContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySyntaxBracketLaContext() *SyntaxBracketLaContext {
	var p = new(SyntaxBracketLaContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_syntaxBracketLa
	return p
}

func InitEmptySyntaxBracketLaContext(p *SyntaxBracketLaContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_syntaxBracketLa
}

func (*SyntaxBracketLaContext) IsSyntaxBracketLaContext() {}

func NewSyntaxBracketLaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SyntaxBracketLaContext {
	var p = new(SyntaxBracketLaContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_syntaxBracketLa

	return p
}

func (s *SyntaxBracketLaContext) GetParser() antlr.Parser { return s.parser }

func (s *SyntaxBracketLaContext) OPERATOR_LT() antlr.TerminalNode {
	return s.GetToken(CQLParserOPERATOR_LT, 0)
}

func (s *SyntaxBracketLaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SyntaxBracketLaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SyntaxBracketLaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterSyntaxBracketLa(s)
	}
}

func (s *SyntaxBracketLaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitSyntaxBracketLa(s)
	}
}

func (p *CQLParser) SyntaxBracketLa() (localctx ISyntaxBracketLaContext) {
	localctx = NewSyntaxBracketLaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 542, CQLParserRULE_syntaxBracketLa)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2308)
		p.Match(CQLParserOPERATOR_LT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISyntaxBracketRaContext is an interface to support dynamic dispatch.
type ISyntaxBracketRaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPERATOR_GT() antlr.TerminalNode

	// IsSyntaxBracketRaContext differentiates from other interfaces.
	IsSyntaxBracketRaContext()
}

type SyntaxBracketRaContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySyntaxBracketRaContext() *SyntaxBracketRaContext {
	var p = new(SyntaxBracketRaContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_syntaxBracketRa
	return p
}

func InitEmptySyntaxBracketRaContext(p *SyntaxBracketRaContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_syntaxBracketRa
}

func (*SyntaxBracketRaContext) IsSyntaxBracketRaContext() {}

func NewSyntaxBracketRaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SyntaxBracketRaContext {
	var p = new(SyntaxBracketRaContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_syntaxBracketRa

	return p
}

func (s *SyntaxBracketRaContext) GetParser() antlr.Parser { return s.parser }

func (s *SyntaxBracketRaContext) OPERATOR_GT() antlr.TerminalNode {
	return s.GetToken(CQLParserOPERATOR_GT, 0)
}

func (s *SyntaxBracketRaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SyntaxBracketRaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SyntaxBracketRaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterSyntaxBracketRa(s)
	}
}

func (s *SyntaxBracketRaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitSyntaxBracketRa(s)
	}
}

func (p *CQLParser) SyntaxBracketRa() (localctx ISyntaxBracketRaContext) {
	localctx = NewSyntaxBracketRaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 544, CQLParserRULE_syntaxBracketRa)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2310)
		p.Match(CQLParserOPERATOR_GT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISyntaxBracketLsContext is an interface to support dynamic dispatch.
type ISyntaxBracketLsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LS_BRACKET() antlr.TerminalNode

	// IsSyntaxBracketLsContext differentiates from other interfaces.
	IsSyntaxBracketLsContext()
}

type SyntaxBracketLsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySyntaxBracketLsContext() *SyntaxBracketLsContext {
	var p = new(SyntaxBracketLsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_syntaxBracketLs
	return p
}

func InitEmptySyntaxBracketLsContext(p *SyntaxBracketLsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_syntaxBracketLs
}

func (*SyntaxBracketLsContext) IsSyntaxBracketLsContext() {}

func NewSyntaxBracketLsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SyntaxBracketLsContext {
	var p = new(SyntaxBracketLsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_syntaxBracketLs

	return p
}

func (s *SyntaxBracketLsContext) GetParser() antlr.Parser { return s.parser }

func (s *SyntaxBracketLsContext) LS_BRACKET() antlr.TerminalNode {
	return s.GetToken(CQLParserLS_BRACKET, 0)
}

func (s *SyntaxBracketLsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SyntaxBracketLsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SyntaxBracketLsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterSyntaxBracketLs(s)
	}
}

func (s *SyntaxBracketLsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitSyntaxBracketLs(s)
	}
}

func (p *CQLParser) SyntaxBracketLs() (localctx ISyntaxBracketLsContext) {
	localctx = NewSyntaxBracketLsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 546, CQLParserRULE_syntaxBracketLs)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2312)
		p.Match(CQLParserLS_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISyntaxBracketRsContext is an interface to support dynamic dispatch.
type ISyntaxBracketRsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RS_BRACKET() antlr.TerminalNode

	// IsSyntaxBracketRsContext differentiates from other interfaces.
	IsSyntaxBracketRsContext()
}

type SyntaxBracketRsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySyntaxBracketRsContext() *SyntaxBracketRsContext {
	var p = new(SyntaxBracketRsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_syntaxBracketRs
	return p
}

func InitEmptySyntaxBracketRsContext(p *SyntaxBracketRsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_syntaxBracketRs
}

func (*SyntaxBracketRsContext) IsSyntaxBracketRsContext() {}

func NewSyntaxBracketRsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SyntaxBracketRsContext {
	var p = new(SyntaxBracketRsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_syntaxBracketRs

	return p
}

func (s *SyntaxBracketRsContext) GetParser() antlr.Parser { return s.parser }

func (s *SyntaxBracketRsContext) RS_BRACKET() antlr.TerminalNode {
	return s.GetToken(CQLParserRS_BRACKET, 0)
}

func (s *SyntaxBracketRsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SyntaxBracketRsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SyntaxBracketRsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterSyntaxBracketRs(s)
	}
}

func (s *SyntaxBracketRsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitSyntaxBracketRs(s)
	}
}

func (p *CQLParser) SyntaxBracketRs() (localctx ISyntaxBracketRsContext) {
	localctx = NewSyntaxBracketRsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 548, CQLParserRULE_syntaxBracketRs)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2314)
		p.Match(CQLParserRS_BRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISyntaxCommaContext is an interface to support dynamic dispatch.
type ISyntaxCommaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COMMA() antlr.TerminalNode

	// IsSyntaxCommaContext differentiates from other interfaces.
	IsSyntaxCommaContext()
}

type SyntaxCommaContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySyntaxCommaContext() *SyntaxCommaContext {
	var p = new(SyntaxCommaContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_syntaxComma
	return p
}

func InitEmptySyntaxCommaContext(p *SyntaxCommaContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_syntaxComma
}

func (*SyntaxCommaContext) IsSyntaxCommaContext() {}

func NewSyntaxCommaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SyntaxCommaContext {
	var p = new(SyntaxCommaContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_syntaxComma

	return p
}

func (s *SyntaxCommaContext) GetParser() antlr.Parser { return s.parser }

func (s *SyntaxCommaContext) COMMA() antlr.TerminalNode {
	return s.GetToken(CQLParserCOMMA, 0)
}

func (s *SyntaxCommaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SyntaxCommaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SyntaxCommaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterSyntaxComma(s)
	}
}

func (s *SyntaxCommaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitSyntaxComma(s)
	}
}

func (p *CQLParser) SyntaxComma() (localctx ISyntaxCommaContext) {
	localctx = NewSyntaxCommaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 550, CQLParserRULE_syntaxComma)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2316)
		p.Match(CQLParserCOMMA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISyntaxColonContext is an interface to support dynamic dispatch.
type ISyntaxColonContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COLON() antlr.TerminalNode

	// IsSyntaxColonContext differentiates from other interfaces.
	IsSyntaxColonContext()
}

type SyntaxColonContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySyntaxColonContext() *SyntaxColonContext {
	var p = new(SyntaxColonContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_syntaxColon
	return p
}

func InitEmptySyntaxColonContext(p *SyntaxColonContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CQLParserRULE_syntaxColon
}

func (*SyntaxColonContext) IsSyntaxColonContext() {}

func NewSyntaxColonContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SyntaxColonContext {
	var p = new(SyntaxColonContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CQLParserRULE_syntaxColon

	return p
}

func (s *SyntaxColonContext) GetParser() antlr.Parser { return s.parser }

func (s *SyntaxColonContext) COLON() antlr.TerminalNode {
	return s.GetToken(CQLParserCOLON, 0)
}

func (s *SyntaxColonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SyntaxColonContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SyntaxColonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.EnterSyntaxColon(s)
	}
}

func (s *SyntaxColonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CQLParserListener); ok {
		listenerT.ExitSyntaxColon(s)
	}
}

func (p *CQLParser) SyntaxColon() (localctx ISyntaxColonContext) {
	localctx = NewSyntaxColonContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 552, CQLParserRULE_syntaxColon)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2318)
		p.Match(CQLParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

package generate

import (
	"bytes"
	"fmt"
	"go/format"
	"io"
	"maps"
	"slices"
	"strings"
	"text/template"
	"unicode"

	"github.com/razcoen/cqlc/pkg/cql"
)

type generateKeyspaceRequest struct {
	keyspace    *cql.Keyspace
	packageName string
	out         io.Writer
}

var (
	keyspaceGoTemplate = `// Code generated by cqlc. DO NOT EDIT.

package {{.PackageName}}

{{- if gt (len .Imports) 0}}
import (
{{- end}}
{{range .Imports}}
  "{{.}}"
{{end}}
{{- if gt (len .Imports) 0}}
)
{{- end}}
{{range .Structs}}
// Table: {{.TableName}}
type {{.Name}} struct {
  {{- range .Fields }}
  {{ .Name }} {{ .Type }}
  {{- end }}
}
{{end -}}
`
)

type goGenerator struct {
	keyspaceGoTemplate *template.Template
}

func newGoGenerator() (*goGenerator, error) {
	tpl, err := template.New("keyspace-go-template").Parse(keyspaceGoTemplate)
	if err != nil {
		return nil, fmt.Errorf("parse keyspace go template: %w", err)
	}
	return &goGenerator{keyspaceGoTemplate: tpl}, nil
}

type keyspaceGoTemplateValue struct {
	PackageName string
	Imports     []string
	Structs     []struct {
		TableName string
		Name      string
		Fields    []struct {
			Name string
			Type string
		}
	}
}

func (gg *goGenerator) generateKeyspace(req *generateKeyspaceRequest) error {
	v := keyspaceGoTemplateValue{
		PackageName: req.packageName,
		Structs: []struct {
			TableName string
			Name      string
			Fields    []struct {
				Name string
				Type string
			}
		}{},
	}
	imports := make(map[string]bool)
	for _, t := range req.keyspace.Tables {
		name := convertToSingularPascalCase(t.Name)
		st := struct {
			TableName string
			Name      string
			Fields    []struct {
				Name string
				Type string
			}
		}{
			TableName: t.Name,
			Name:      name,
		}
		for _, c := range t.Columns {
			name := convertToSingularPascalCase(c.Name)
			tp, imprt := convertToGoType(c.DataType)
			if imprt != "" {
				imports[imprt] = true
			}
			st.Fields = append(st.Fields, struct {
				Name string
				Type string
			}{Name: name, Type: tp})
		}
		v.Structs = append(v.Structs, st)
	}
	v.Imports = slices.Collect(maps.Keys(imports))
	buf := &bytes.Buffer{}
	if err := gg.keyspaceGoTemplate.Execute(buf, v); err != nil {
		return fmt.Errorf("execute keyspace template: %w", err)
	}
	out, err := format.Source(buf.Bytes())
	if err != nil {
		return fmt.Errorf("format out: %w", err)
	}
	if _, err := req.out.Write(out); err != nil {
		return fmt.Errorf("write out: %w", err)
	}
	return nil
}

var initialisms = map[string]bool{
	"ID":   true,
	"UUID": true,
	"HTTP": true,
	"JSON": true,
	"SQL":  true,
}

func convertToSingularPascalCase(s string) string {
	parts := strings.FieldsFunc(s, func(r rune) bool {
		return r == '_' || r == '-' || unicode.IsSpace(r)
	})
	for i, part := range parts {
		upper := strings.ToUpper(part)
		if initialisms[upper] {
			parts[i] = upper // Use the initialism as-is
		} else {
			parts[i] = strings.ToUpper(part[:1]) + strings.ToLower(part[1:])
		}
	}
	pscl := strings.Join(parts, "")
	if strings.HasSuffix(pscl, "s") {
		return pscl[:len(pscl)-1]
	}
	return pscl
}

func convertToGoType(dataType *cql.DataType) (tp string, importPath string) {
	if dataType.NativeType == nil {
		// TODO: Unsupported
		return "", ""
	}
	switch *dataType.NativeType {
	case cql.NativeTypeAscii, cql.NativeTypeInet, cql.NativeTypeText, cql.NativeTypeTimeuuid, cql.NativeTypeUUID, cql.NativeTypeVarchar:
		return "string", ""
	case cql.NativeTypeBigint, cql.NativeTypeCounter, cql.NativeTypeInt, cql.NativeTypeSmallint, cql.NativeTypeTinyint, cql.NativeTypeVarint:
		return "int64", ""
	case cql.NativeTypeBlob:
		return "[]byte", ""
	case cql.NativeTypeBoolean:
		return "bool", ""
	case cql.NativeTypeDate, cql.NativeTypeTime, cql.NativeTypeTimestamp:
		return "time.Time", "time"
	case cql.NativeTypeFloat, cql.NativeTypeDecimal, cql.NativeTypeDouble:
		return "float64", ""
	case cql.NativeTypeDuration:
		return "time.Duration", ""
	}
	// TODO: Unsupported
	return "", ""
}

package gocqlc

import (
	"context"
	"iter"

	"github.com/gocql/gocql"
	"github.com/razcoen/cqlc/pkg/log"
)

// ScanFunc implements a row scan into a structured data type with a given iterator.
type ScanFunc[T any] func(iter *gocql.Iter, dest *T) bool

// Querier is a wrapper around a gocql.Query that provides a convenient interface for scanning rows into a structured data type.
// It provides methods for executing queries and iterating over the results.
// The two methods are Iter and PageIter, where Iter iterates over all rows and may execute additional queries to fetch more data, while PageIter iterates over a single page of results.
type Querier[T any] struct {
	defaultQueryOptions []QueryOption
	query               *gocql.Query
	scan                ScanFunc[T]
	logger              log.Logger
}

// NewQuerier creates a new querier for the given query and scan function.
// A querier is a wrapper around a gocql.Query that provides a convenient interface for scanning rows into a structured data type.
func NewQuerier[T any](query *gocql.Query, scan ScanFunc[T], logger log.Logger, defaultQueryOptions ...QueryOption) *Querier[T] {
	return &Querier[T]{
		defaultQueryOptions: defaultQueryOptions,
		query:               query,
		scan:                scan,
		logger:              logger,
	}
}

// Iter is an iterator over the results of the query.
type Iter[T any] struct {
	rows iter.Seq[*T]
	err  error
}

// Rows returns an iterator over the results of the query.
func (p *Iter[T]) Rows() iter.Seq[*T] { return p.rows }

// Err returns the error encountered during iteration.
func (p *Iter[T]) Err() error { return p.err }

// Iter returns an iterator over the results of the query.
// It iterates over all rows and may execute additional queries to fetch more data.
// To use manual pagination, use PageIter instead.
//
// Usage:
//
//	iter := querier.Iter(ctx)
//	for row := range iter.Rows() {
//	  // Process row
//	}
//	if err := iter.Err(); err != nil {
//	  return err
//	}
func (q *Querier[T]) Iter(ctx context.Context, opts ...QueryOption) *Iter[T] {
	query := q.query.WithContext(ctx)
	ApplyQueryOptions(query, q.defaultQueryOptions...)
	ApplyQueryOptions(query, opts...)
	iter := query.Iter()
	typedIter := newTypedIter(iter, q.scan)
	i := &Iter[T]{}
	i.rows = func(yield func(*T) bool) {
		defer func() {
			if err := iter.Close(); err != nil {
				i.err = err
			}
		}()
		var t T
		for typedIter.Scan(&t) {
			t := t
			if !yield(&t) {
				return
			}
		}
	}
	return i
}

// PageIter is an iterator over the results of the query.
// It only iterates over a single page of results.
// The pagination information is returned by the Info method.
type PageIter[T any] struct {
	Iter[T]
	info *PageInfo
}

// Info returns the page information for the current page.
func (p *PageIter[T]) Info() *PageInfo { return p.info }

type PageInfo struct {
	numRows   int
	pageState []byte
	host      *gocql.HostInfo
	warnings  []string
}

// NumRows returns the number of rows returned by the query for this page.
func (p *PageInfo) NumRows() int { return p.numRows }

// PageState returns the page state required to fetch the next page of results.
func (p *PageInfo) PageState() []byte { return p.pageState }

// Host returns the host that executed the query for this page.
func (p *PageInfo) Host() *gocql.HostInfo { return p.host }

// Warnings returns any warnings generated by the query for this page.
func (p *PageInfo) Warnings() []string { return p.warnings }

// PageIter returns an iterator over the results of the query with pagination support.
// It only iterates over a single page of results.
// The pagination information is returned by the Info method.
//
// Usage:
//
//	iter := querier.PageIter(ctx, pageState)
//	for row := range iter.Rows() {
//	  // Process row
//	}
//	if err := iter.Err(); err != nil {
//	  return err
//	}
//	nextPageState := iter.Info().PageState()
func (q *Querier[T]) PageIter(ctx context.Context, pageState []byte, opts ...QueryOption) *PageIter[T] {
	query := q.query.WithContext(ctx).PageState(pageState)
	ApplyQueryOptions(query, q.defaultQueryOptions...)
	ApplyQueryOptions(query, opts...)
	iter := query.Iter()
	nextPageState := iter.PageState()
	if len(nextPageState) == 0 {
		nextPageState = nil
	}
	typedIter := newTypedIter(iter, q.scan)
	pi := &PageIter[T]{
		info: &PageInfo{
			numRows:   iter.NumRows(),
			pageState: nextPageState,
			host:      iter.Host(),
			warnings:  iter.Warnings(),
		},
	}
	pi.rows = func(yield func(*T) bool) {
		defer func() {
			if err := iter.Close(); err != nil {
				pi.err = err
			}
		}()
		var t T
		for typedIter.Scan(&t) {
			t := t
			if !yield(&t) {
				return
			}
		}
	}
	return pi
}

type typedIter[T any] struct {
	iter *gocql.Iter
	scan ScanFunc[T]
}

func newTypedIter[T any](it *gocql.Iter, scan ScanFunc[T]) *typedIter[T] {
	return &typedIter[T]{iter: it, scan: scan}
}

func (i *typedIter[T]) Scan(dest *T) bool {
	return i.scan(i.iter, dest)
}

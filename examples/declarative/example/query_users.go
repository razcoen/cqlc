// Code generated by cqlc. DO NOT EDIT.
// cqlc version: (devel)
// config: ../cqlc.yaml
// schema: ../schema.cql
// queries: ../queries.cql

package example

import (
	"context"
	"fmt"
	"time"

	"github.com/gocql/gocql"
	"github.com/razcoen/cqlc/pkg/gocqlc"
)

type CreateUserParams struct {
	UserID    gocql.UUID
	Username  string
	Email     string
	CreatedAt time.Time
}

func (c *Client) CreateUser(ctx context.Context, params *CreateUserParams, opts ...gocqlc.QueryOption) error {
	session := c.Session()
	q := session.Query("INSERT INTO users (user_id, username, email, created_at) VALUES (?, ?, ?, ?);", params.UserID, params.Username, params.Email, params.CreatedAt)
	q = q.WithContext(ctx)
	gocqlc.ApplyQueryOptions(q, c.DefaultQueryOptions()...)
	gocqlc.ApplyQueryOptions(q, opts...)
	if err := q.Exec(); err != nil {
		return fmt.Errorf("exec query: %w", err)
	}
	return nil
}

type CreateUsersParams struct {
	UserID    gocql.UUID
	Username  string
	Email     string
	CreatedAt time.Time
}

func (c *Client) CreateUsers(ctx context.Context, params []*CreateUsersParams, opts ...gocqlc.BatchOption) error {
	session := c.Session()
	b := session.NewBatch(gocql.LoggedBatch)
	for _, v := range params {
		b.Query("INSERT INTO users (user_id, username, email, created_at) VALUES (?, ?, ?, ?);", v.UserID, v.Username, v.Email, v.CreatedAt)
	}
	b = b.WithContext(ctx)
	gocqlc.ApplyBatchOptions(b, c.DefaultBatchOptions()...)
	gocqlc.ApplyBatchOptions(b, opts...)
	if err := session.ExecuteBatch(b); err != nil {
		return fmt.Errorf("exec batch: %w", err)
	}
	return nil
}

type FindUserParams struct {
	UserID gocql.UUID
}

type FindUserRow struct {
	UserID    gocql.UUID
	CreatedAt time.Time
	Email     string
	Username  string
}

func (c *Client) FindUser(ctx context.Context, params *FindUserParams, opts ...gocqlc.QueryOption) (*FindUserRow, error) {
	session := c.Session()
	q := session.Query("SELECT * FROM users WHERE user_id = ? LIMIT 1;", params.UserID)
	q = q.WithContext(ctx)
	gocqlc.ApplyQueryOptions(q, c.DefaultQueryOptions()...)
	gocqlc.ApplyQueryOptions(q, opts...)
	var row FindUserRow
	if err := q.Scan(&row.UserID, &row.CreatedAt, &row.Email, &row.Username); err != nil {
		return nil, fmt.Errorf("scan row: %w", err)
	}
	return &row, nil
}

type ListUserIDsRow struct {
	UserID gocql.UUID
}

func (c *Client) ListUserIDs(opts ...gocqlc.QueryOption) *gocqlc.Querier[ListUserIDsRow] {
	session := c.Session()
	q := session.Query("SELECT user_id FROM users;")
	scan := func(it *gocql.Iter, dest *ListUserIDsRow) bool {
		return it.Scan(&(*dest).UserID)
	}
	return gocqlc.NewQuerier(q, scan, c.Logger(), c.DefaultQueryOptions()...)
}

type ListUsersRow struct {
	UserID    gocql.UUID
	CreatedAt time.Time
	Email     string
	Username  string
}

func (c *Client) ListUsers(opts ...gocqlc.QueryOption) *gocqlc.Querier[ListUsersRow] {
	session := c.Session()
	q := session.Query("SELECT * FROM users;")
	scan := func(it *gocql.Iter, dest *ListUsersRow) bool {
		return it.Scan(&(*dest).UserID, &(*dest).CreatedAt, &(*dest).Email, &(*dest).Username)
	}
	return gocqlc.NewQuerier(q, scan, c.Logger(), c.DefaultQueryOptions()...)
}
